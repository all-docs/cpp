<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/named_req/Allocator by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:36:57 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>C++ named requirements: Allocator</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_named_req_Allocator skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading"><span style="font-size:0.7em; line-height:130%">C++ named requirements:</span> <span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span></h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>Encapsulates strategies for access/addressing, allocation/deallocation and construction/destruction of objects.
</p><p>Every standard library component that may need to allocate or release storage, from <span class="t-lc"><a href="../string/basic_string.html" title="cpp/string/basic string">std::string</a></span>, <span class="t-lc"><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></span>, and every container<span class="t-rev-inl t-since-cxx11"><span>, except <span class="t-lc"><a href="../container/array.html" title="cpp/container/array">std::array</a></span></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span><span class="t-rev-inl t-since-cxx26"><span> and <span class="t-lc">std::inplace_vector</span></span><span><span class="t-mark-rev t-since-cxx26">(since C++26)</span></span></span>, to <span class="t-lc"><a href="../memory/shared_ptr.html" title="cpp/memory/shared ptr">std::shared_ptr</a></span><span class="t-rev-inl t-until-cxx17"><span> and <span class="t-lc"><a href="../utility/functional/function.html" title="cpp/utility/functional/function">std::function</a></span></span><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span>, does so through an <strong class="selflink"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span></strong>: an object of a class type that satisfies the following requirements.
</p><p>The implementation of many allocator requirements is optional because all <a href="AllocatorAwareContainer.html" title="cpp/named req/AllocatorAwareContainer"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">AllocatorAwareContainer</span></a> access allocators indirectly through <span class="t-lc"><a href="../memory/allocator_traits.html" title="cpp/memory/allocator traits">std::allocator_traits</a></span>, and <span class="t-lc"><a href="../memory/allocator_traits.html" title="cpp/memory/allocator traits">std::allocator_traits</a></span> supplies the default implementation of those requirements.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Requirements"><span class="tocnumber">1</span> <span class="toctext">Requirements</span></a>
<ul>
<li class="toclevel-2"><a href="#Allocator_completeness_requirements"><span class="tocnumber">1.1</span> <span class="toctext">Allocator completeness requirements</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-3"><a href="#Stateful_and_stateless_allocators"><span class="tocnumber">2</span> <span class="toctext">Stateful and stateless allocators</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Fancy_pointers"><span class="tocnumber">3</span> <span class="toctext">Fancy pointers</span></a></li>
<li class="toclevel-1"><a href="#Concept"><span class="tocnumber">4</span> <span class="toctext">Concept</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Standard_library"><span class="tocnumber">5</span> <span class="toctext">Standard library</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Examples"><span class="tocnumber">6</span> <span class="toctext">Examples</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Defect_reports"><span class="tocnumber">7</span> <span class="toctext">Defect reports</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;action=edit&amp;section=1" title="Edit section: Requirements">edit</a>]</span> <span class="mw-headline" id="Requirements">Requirements</span></h3>
<p>Given
</p>
<ul><li> <code>T</code>, a <span class="t-rev-inl t-until-cxx11"><span>non-const, non-reference type</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11 t-until-cxx17"><span>non-const object type</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>cv-unqualified object type</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>,
</li><li> <code>A</code>, an <span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span> type for type <code>T</code>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">a</span></span>, an object of type <code>A</code>,
</li><li> <code>B</code>, the corresponding <span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span> type for some cv-unqualified object type <code>U</code> (as obtained by rebinding <code>A</code>),
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">b</span></span>, an object of type <code>B</code>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span>, a value of type <span class="mw-geshi cpp source-cpp"><a href="../memory/allocator_traits.html"><span class="kw705">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">pointer</span></span>, obtained by calling <span class="t-c"><span class="mw-geshi cpp source-cpp"><a href="../memory/allocator_traits.html"><span class="kw705">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">allocate</span><span class="br0">(</span><span class="br0">)</span></span></span>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">cp</span></span>, a value of type <span class="mw-geshi cpp source-cpp"><a href="../memory/allocator_traits.html"><span class="kw705">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_pointer</span></span>, obtained by conversion from <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">vp</span></span>, a value of type <span class="mw-geshi cpp source-cpp"><a href="../memory/allocator_traits.html"><span class="kw705">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">void_pointer</span></span>, obtained by conversion from <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">cvp</span></span>, a value of type <span class="mw-geshi cpp source-cpp"><a href="../memory/allocator_traits.html"><span class="kw705">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">const_void_pointer</span></span>, obtained by conversion from <span class="t-c"><span class="mw-geshi cpp source-cpp">cp</span></span> or from <span class="t-c"><span class="mw-geshi cpp source-cpp">vp</span></span>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">xp</span></span>, a dereferenceable pointer to some cv-unqualified object type <code>X</code>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">r</span></span>, an lvalue of type <code>T</code> obtained by the expression <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">*</span>p</span></span>,
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">n</span></span>, a value of type <span class="mw-geshi cpp source-cpp"><a href="../memory/allocator_traits.html"><span class="kw705">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">size_type</span></span>.
</li></ul>
<table class="wikitable">
<caption>Inner types
</caption>
<tbody><tr>
<th>Type-id</th>
<th>Aliased type</th>
<th>Requirements
</th></tr>
<tr>
<td><code>A::pointer</code> <span class="t-mark">(optional)</span>
</td>
<td><i>(unspecified)</i><sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup>
</td>
<td>
<ul><li> Satisfies <a href="NullablePointer.html" title="cpp/named req/NullablePointer"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">NullablePointer</span></a>, <a href="RandomAccessIterator.html" title="cpp/named req/RandomAccessIterator"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">LegacyRandomAccessIterator</span></a>, and <a href="ContiguousIterator.html" title="cpp/named req/ContiguousIterator"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">LegacyContiguousIterator</span></a>.
</li></ul>
</td></tr>
<tr>
<td><code>A::const_pointer</code> <span class="t-mark">(optional)</span>
</td>
<td><i>(unspecified)</i>
</td>
<td>
<ul><li> Satisfies <a href="NullablePointer.html" title="cpp/named req/NullablePointer"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">NullablePointer</span></a>, <a href="RandomAccessIterator.html" title="cpp/named req/RandomAccessIterator"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">LegacyRandomAccessIterator</span></a>, and <a href="ContiguousIterator.html" title="cpp/named req/ContiguousIterator"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">LegacyContiguousIterator</span></a>.
</li><li> <code>A::pointer</code> is convertible to <code>A::const_pointer</code>.
</li></ul>
</td></tr>
<tr>
<td><code>A::void_pointer</code> <span class="t-mark">(optional)</span>
</td>
<td><i>(unspecified)</i>
</td>
<td>
<ul><li> Satisfies <a href="NullablePointer.html" title="cpp/named req/NullablePointer"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">NullablePointer</span></a>.
</li><li> <code>A::pointer</code> is convertible to <code>A::void_pointer</code>.
</li><li> <code>B::void_pointer</code> and <code>A::void_pointer</code> are the same type.
</li></ul>
</td></tr>
<tr>
<td><code>A::const_void_pointer</code> <span class="t-mark">(optional)</span>
</td>
<td><i>(unspecified)</i>
</td>
<td>
<ul><li> Satisfies <a href="NullablePointer.html" title="cpp/named req/NullablePointer"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">NullablePointer</span></a>.
</li><li> <code>A::pointer</code>, <code>A::const_pointer</code>, and <code>A::void_pointer</code> are convertible to <code>A::const_void_pointer</code>.
</li><li> <code>B::const_void_pointer</code> and <code>A::const_void_pointer</code> are the same type.
</li></ul>
</td></tr>
<tr>
<td><code>A::value_type</code>
</td>
<td><code>T</code>
</td>
<td>
</td></tr>
<tr>
<td><code>A::size_type</code> <span class="t-mark">(optional)</span>
</td>
<td><i>(unspecified)</i>
</td>
<td>
<ul><li> An unsigned integer type.
</li><li> Can represent the size of the largest object <code>A</code> can allocate.
</li></ul>
</td></tr>
<tr>
<td><code>A::difference_type</code> <span class="t-mark">(optional)</span>
</td>
<td><i>(unspecified)</i>
</td>
<td>
<ul><li> A signed integer type.
</li><li> Can represent the difference of any two pointers to the objects allocated by <code>A</code>.
</li></ul>
</td></tr>
<tr>
<td><code>A::template&nbsp;rebind&lt;U&gt;::other</code><br><span class="t-mark">(optional)</span><sup id="cite_ref-2" class="reference"><a href="#cite_note-2">[2]</a></sup>
</td>
<td><code>B</code>
</td>
<td>
<ul><li> For any <code>U</code>, <code>B::template rebind&lt;T&gt;::other</code> is <code>A</code>.
</li></ul>
</td></tr></tbody></table>
<table class="wikitable">
<caption>Operations on pointers
</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Requirements
</th></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">*</span>p</span></span>
</td>
<td><code>T&amp;</code>
</td>
<td>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">*</span>cp</span></span>
</td>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T<span class="sy3">&amp;</span></span>
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">*</span>cp</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">*</span>p</span></span> identify the same object.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">p<span class="sy2">-</span><span class="sy1">&gt;</span>m</span></span>
</td>
<td><abbr title="The type of T::m."><i>(as is)</i></abbr>
</td>
<td>Same as <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span>.<span class="me1">m</span></span></span>, if <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span>.<span class="me1">m</span></span></span> is well-defined.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">cp<span class="sy2">-</span><span class="sy1">&gt;</span>m</span></span>
</td>
<td><abbr title="The type of T::m."><i>(as is)</i></abbr>
</td>
<td>Same as <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span><span class="sy2">*</span>cp<span class="br0">)</span>.<span class="me1">m</span></span></span>, if <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span><span class="sy2">*</span>cp<span class="br0">)</span>.<span class="me1">m</span></span></span> is well-defined.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">static_cast</span><span class="sy1">&lt;</span>A<span class="sy4">::</span><span class="me2">pointer</span><span class="sy1">&gt;</span><span class="br0">(</span>vp<span class="br0">)</span></span></span>
</td>
<td><abbr title="A::pointer"><i>(as is)</i></abbr>
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">static_cast</span><span class="sy1">&lt;</span>A<span class="sy4">::</span><span class="me2">pointer</span><span class="sy1">&gt;</span><span class="br0">(</span>vp<span class="br0">)</span> <span class="sy1">==</span> p</span></span>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">static_cast</span><span class="sy1">&lt;</span>A<span class="sy4">::</span><span class="me2">const_pointer</span><span class="sy1">&gt;</span><span class="br0">(</span>cvp<span class="br0">)</span></span></span>
</td>
<td><abbr title="A::const_pointer"><i>(as is)</i></abbr>
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw1">static_cast</span><span class="sy1">&lt;</span>A<span class="sy4">::</span><span class="me2">const_pointer</span><span class="sy1">&gt;</span><span class="br0">(</span>cvp<span class="br0">)</span> <span class="sy1">==</span> cp</span></span>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp"><a href="../memory/pointer_traits.html"><span class="kw760">std::<span class="me2">pointer_traits</span></span></a><span class="sy1">&lt;</span>A<span class="sy4">::</span><span class="me2">pointer</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">pointer_to</span><span class="br0">(</span>r<span class="br0">)</span></span></span>
</td>
<td><abbr title="A::pointer"><i>(as is)</i></abbr>
</td>
<td>
</td></tr></tbody></table>
<table class="wikitable">
<caption>Storage and lifetime operations
</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Requirements
</th></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">allocate</span><span class="br0">(</span>n<span class="br0">)</span></span></span>
</td>
<td rowspan="2"><code>A::pointer</code>
</td>
<td>Allocates storage suitable for an array object of type <code>T[n]</code> and creates the array, but does not construct array elements. May throw exceptions. If <span class="t-c"><span class="mw-geshi cpp source-cpp">n <span class="sy1">==</span> <span class="nu0">0</span></span></span>, the return value is unspecified.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">allocate</span><span class="br0">(</span>n, cvp<span class="br0">)</span></span></span> <span class="t-mark">(optional)</span>
</td>
<td>Same as <span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">allocate</span><span class="br0">(</span>n<span class="br0">)</span></span></span>, but may use <span class="t-c"><span class="mw-geshi cpp source-cpp">cvp</span></span> (<span class="t-c"><span class="mw-geshi cpp source-cpp">nullptr</span></span> or a pointer obtained from <span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">allocate</span><span class="br0">(</span><span class="br0">)</span></span></span>) in unspecified manner to aid locality.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">allocate_at_least</span><span class="br0">(</span>n<span class="br0">)</span></span></span> <span class="t-mark">(optional)</span> <span class="t-mark-rev t-since-cxx23">(since C++23)</span>
</td>
<td><span class="mw-geshi cpp source-cpp"><a href="../memory/allocation_result.html"><span class="kw3411">std::<span class="me2">allocation_result</span></span></a><br>
<p>&nbsp; &nbsp; <span class="sy1">&lt;</span>A<span class="sy4">::</span><span class="me2">pointer</span><span class="sy1">&gt;</span>
</p>
</span></td>
<td>Allocates storage suitable for an array object of type <code>T[cnt]</code> and creates the array, but does not construct array elements, then returns <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">{</span>p, cnt<span class="br0">}</span></span></span>, where <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span> points to the storage and <span class="t-c"><span class="mw-geshi cpp source-cpp">cnt</span></span> is not less than <span class="t-c"><span class="mw-geshi cpp source-cpp">n</span></span>. May throw exceptions.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">deallocate</span><span class="br0">(</span>p, n<span class="br0">)</span></span></span>
</td>
<td><i>(not used)</i>
</td>
<td>Deallocates storage pointed to <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span>, which must be a value returned by a previous call to <code>allocate</code> <span class="t-rev-inl t-since-cxx23"><span>or <code>allocate_at_least</code></span><span><span class="t-mark-rev t-since-cxx23">(since C++23)</span></span></span> that has not been invalidated by an intervening call to <code>deallocate</code>. <span class="t-c"><span class="mw-geshi cpp source-cpp">n</span></span> must match the value previously passed to <code>allocate</code><span class="t-rev-inl t-since-cxx23"><span>or be between the request and returned number of elements via <code>allocate_at_least</code> (may be equal to either bound)</span><span><span class="t-mark-rev t-since-cxx23">(since C++23)</span></span></span>. Does not throw exceptions.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">max_size</span><span class="br0">(</span><span class="br0">)</span></span></span> <span class="t-mark">(optional)</span>
</td>
<td><code>A::size_type</code>
</td>
<td>The largest value that can be passed to <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="sy4">::</span><span class="me2">allocate</span><span class="br0">(</span><span class="br0">)</span></span></span>.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">construct</span><span class="br0">(</span>xp, args...<span class="br0">)</span></span></span> <span class="t-mark">(optional)</span>
</td>
<td><i>(not used)</i>
</td>
<td>Constructs an object of type <code>X</code> in previously-allocated storage at the address pointed to by <span class="t-c"><span class="mw-geshi cpp source-cpp">xp</span></span>, using <span class="t-c"><span class="mw-geshi cpp source-cpp">args...</span></span> as the constructor arguments.
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">destroy</span><span class="br0">(</span>xp<span class="br0">)</span></span></span> <span class="t-mark">(optional)</span>
</td>
<td><i>(not used)</i>
</td>
<td>Destructs an object of type <code>X</code> pointed to by <span class="t-c"><span class="mw-geshi cpp source-cpp">xp</span></span>, but does not deallocate any storage.
</td></tr></tbody></table>
<table class="wikitable">
<caption>Relationship between instances
</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Requirements
</th></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a1 <span class="sy1">==</span> a2</span></span>
</td>
<td rowspan="2"><span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>
</td>
<td>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span> only if the storage allocated by the allocator <span class="t-c"><span class="mw-geshi cpp source-cpp">a1</span></span> can be deallocated through <span class="t-c"><span class="mw-geshi cpp source-cpp">a2</span></span>.
</li><li> Establishes reflexive, symmetric, and transitive relationship.
</li><li> Does not throw exceptions.
</li></ul>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a1 <span class="sy3">!</span><span class="sy1">=</span> a2</span></span>
</td>
<td>
<ul><li> Same as <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">!</span><span class="br0">(</span>a1 <span class="sy1">==</span> a2<span class="br0">)</span></span></span>.
</li></ul>
</td></tr>
<tr>
<th>Declaration</th>
<th>Effect</th>
<th>Requirements
</th></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">A a1<span class="br0">(</span>a<span class="br0">)</span></span></span>
</td>
<td rowspan="2">Copy-constructs <span class="t-c"><span class="mw-geshi cpp source-cpp">a1</span></span> such that <span class="t-c"><span class="mw-geshi cpp source-cpp">a1 <span class="sy1">==</span> a</span></span>.<br>(Note: Every <span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span> also satisfies <a href="CopyConstructible.html" title="cpp/named req/CopyConstructible"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">CopyConstructible</span></a>.)
</td>
<td rowspan="2">
<ul><li> Does not throw exceptions.
</li></ul>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">A a1 <span class="sy1">=</span> a</span></span>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">A a<span class="br0">(</span>b<span class="br0">)</span></span></span>
</td>
<td>Constructs <span class="t-c"><span class="mw-geshi cpp source-cpp">a</span></span> such that <span class="t-c"><span class="mw-geshi cpp source-cpp">B<span class="br0">(</span>a<span class="br0">)</span> <span class="sy1">==</span> b</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="br0">(</span>b<span class="br0">)</span> <span class="sy1">==</span> a</span></span>.<br>(Note: This implies that all allocators related by <code>rebind</code> maintain each other's resources, such as memory pools.)
</td>
<td>
<ul><li> Does not throw exceptions.
</li></ul>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">A a1<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>a<span class="br0">)</span><span class="br0">)</span></span></span>
</td>
<td rowspan="2">Constructs <span class="t-c"><span class="mw-geshi cpp source-cpp">a1</span></span> such that it equals the prior value of <span class="t-c"><span class="mw-geshi cpp source-cpp">a</span></span>.
</td>
<td rowspan="2">
<ul><li> Does not throw exceptions.
</li><li> The value of <span class="t-c"><span class="mw-geshi cpp source-cpp">a</span></span> is unchanged and <span class="t-c"><span class="mw-geshi cpp source-cpp">a1 <span class="sy1">==</span> a</span></span>.
</li></ul>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">A a1 <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>a<span class="br0">)</span></span></span>
</td></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">A a<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>b<span class="br0">)</span><span class="br0">)</span></span></span>
</td>
<td>Constructs <span class="t-c"><span class="mw-geshi cpp source-cpp">a</span></span> such that it equals the prior value of <span class="t-c"><span class="mw-geshi cpp source-cpp">A<span class="br0">(</span>b<span class="br0">)</span></span></span>.
</td>
<td>
<ul><li> Does not throw exceptions.
</li></ul>
</td></tr>
<tr>
<th>Type-id</th>
<th>Aliased type</th>
<th>Requirements
</th></tr>
<tr>
<td><code>A::is_always_equal</code><br><span class="t-mark">(optional)</span>
</td>
<td><span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::false_type</a></span> or derived from such.
</td>
<td>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span> if any two allocators of type <code>A</code> always compare equal.
</li><li> (If not provided, <span class="t-lc"><a href="../memory/allocator_traits.html" title="cpp/memory/allocator traits">std::allocator_traits</a></span> defaults this to <span class="mw-geshi cpp source-cpp"><a href="../types/is_empty.html"><span class="kw515">std::<span class="me2">is_empty</span></span></a><span class="sy1">&lt;</span>A<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span></span>.)
</li></ul>
</td></tr></tbody></table>
<table class="wikitable">
<caption>Influence on container operations
</caption>
<tbody><tr>
<th>Expression</th>
<th>Return type</th>
<th>Description
</th></tr>
<tr>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">select_on_container_copy_construction</span><span class="br0">(</span><span class="br0">)</span></span></span><br><span class="t-mark">(optional)</span>
</td>
<td><code>A</code>
</td>
<td>
<ul><li> Provides an instance of <code>A</code> to be used by the container that is copy-constructed from the one that uses <span class="t-c"><span class="mw-geshi cpp source-cpp">a</span></span> currently.
</li><li> (Usually returns either a copy of <span class="t-c"><span class="mw-geshi cpp source-cpp">a</span></span> or a default-constructed <code>A</code>.)
</li></ul>
</td></tr>
<tr>
<th>Type-id</th>
<th>Aliased type</th>
<th>Description
</th></tr>
<tr>
<td><code>A::propagate_on_container_copy_assignment</code><br><span class="t-mark">(optional)</span>
</td>
<td rowspan="3"><span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::false_type</a></span> or derived from such.
</td>
<td>
<ul><li> <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or derived from it if the allocator of type <code>A</code> needs to be copied when the container that uses it is copy-assigned.
</li><li> If this member is <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or derived from it, then <code>A</code> must satisfy <a href="CopyAssignable.html" title="cpp/named req/CopyAssignable"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">CopyAssignable</span></a> and the copy operation must not throw exceptions.
</li><li> Note that if the allocators of the source and the target containers do not compare equal, copy assignment has to deallocate the target's memory using the old allocator and then allocate it using the new allocator before copying the elements (and the allocator).
</li></ul>
</td></tr>
<tr>
<td><code>A::propagate_on_container_move_assignment</code><br><span class="t-mark">(optional)</span>
</td>
<td>
<ul><li> <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or derived from it if the allocator of type <code>A</code> needs to be moved when the container that uses it is move-assigned.
</li><li> If this member is <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or derived from it, then <code>A</code> must satisfy <a href="MoveAssignable.html" title="cpp/named req/MoveAssignable"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">MoveAssignable</span></a> and the move operation must not throw exceptions.
</li><li> If this member is not provided or derived from <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::false_type</a></span> and the allocators of the source and the target containers do not compare equal, move assignment cannot take ownership of the source memory and must move-assign or move-construct the elements individually, resizing its own memory as needed.
</li></ul>
</td></tr>
<tr>
<td><code>A::propagate_on_container_swap</code><br><span class="t-mark">(optional)</span>
</td>
<td>
<ul><li> <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or derived from it if the allocators of type <code>A</code> need to be swapped when two containers that use them are swapped.
</li><li> If this member is <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::true_type</a></span> or derived from it, type <code>A</code> must satisfy <a href="Swappable.html" title="cpp/named req/Swappable"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Swappable</span></a> and the swap operation must not throw exceptions.
</li><li> If this member is not provided or derived from <span class="t-lc"><a href="../types/integral_constant.html" title="cpp/types/integral constant">std::false_type</a></span> and the allocators of the two containers do not compare equal, the behavior of container swap is undefined.
</li></ul>
</td></tr></tbody></table>
<p>Notes:
</p>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite_ref-1">↑</a></span> <span class="reference-text">See also <a href="#Fancy_pointers">fancy pointers</a> below.</span>
</li>
<li id="cite_note-2"><span class="mw-cite-backlink"><a href="#cite_ref-2">↑</a></span> <span class="reference-text"><code>rebind</code> is only optional (provided by <span class="t-lc"><a href="../memory/allocator_traits.html" title="cpp/memory/allocator traits">std::allocator_traits</a></span>) if this allocator is a template of the form <code>SomeAllocator&lt;T, Args&gt;</code>, where <code>Args</code> is zero or more additional template type parameters.</span>
</li>
</ol>
<p>Given
</p>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">x1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">x2</span></span>, objects of (possibly different) types <code>X::void_pointer</code>, <code>X::const_void_pointer</code>, <code>X::pointer</code>, or <code>X::const_pointer</code>
</li></ul>
<dl><dd>Then, <span class="t-c"><span class="mw-geshi cpp source-cpp">x1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">x2</span></span> are <i>equivalently-valued</i> pointer values, if and only if both <span class="t-c"><span class="mw-geshi cpp source-cpp">x1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">x2</span></span> can be explicitly converted to the two corresponding objects <span class="t-c"><span class="mw-geshi cpp source-cpp">px1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">px2</span></span> of type <code>X::const_pointer</code>, using a sequence of <span class="mw-geshi cpp source-cpp"><span class="kw1">static_cast</span></span>s using only these four types, and the expression <span class="t-c"><span class="mw-geshi cpp source-cpp">px1 <span class="sy1">==</span> px2</span></span> evaluates to <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span>.
</dd></dl>
<p>Given
</p>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">w1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">w2</span></span>, objects of type <code>X::void_pointer</code>
</li></ul>
<dl><dd>Then, for the expression <span class="t-c"><span class="mw-geshi cpp source-cpp">w1 <span class="sy1">==</span> w2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">w1 <span class="sy3">!</span><span class="sy1">=</span> w2</span></span> either or both objects may be replaced by an <i>equivalently-valued</i> object of type <code>X::const_void_pointer</code> with no change in semantics.
</dd></dl>
<p>Given
</p>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span>, objects of type <code>X::pointer</code>
</li></ul>
<dl><dd>Then, for the expressions <span class="t-c"><span class="mw-geshi cpp source-cpp">p1 <span class="sy1">==</span> p2</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1 <span class="sy3">!</span><span class="sy1">=</span> p2</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1 <span class="sy1">&lt;</span> p2</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1 <span class="sy1">&lt;=</span> p2</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1 <span class="sy1">&gt;=</span> p2</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1 <span class="sy1">&gt;</span> p2</span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1 <span class="sy2">-</span> p2</span></span> either or both objects may be replaced by an <i>equivalently-valued</i> object of type <code>X::const_pointer</code> with no change in semantics.
</dd></dl>
<p>The above requirements make it possible to compare <a href="Container.html" title="cpp/named req/Container"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Container</span></a>'s <code>iterator</code>s and <code>const_iterator</code>s.
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<h4> <span class="mw-headline" id="Allocator_completeness_requirements">Allocator completeness requirements</span></h4>
<p>An allocator type <code>X</code> for type <code>T</code> additionally satisfies the <i>allocator completeness requirements</i> if both of the following are true regardless of whether <code>T</code> is a complete type:
</p>
<ul><li> <code>X</code> is a complete type.
</li><li> Except for <code>value_type</code>, all the member types of <span class="mw-geshi cpp source-cpp"><a href="../memory/allocator_traits.html"><span class="kw705">std::<span class="me2">allocator_traits</span></span></a><span class="sy1">&lt;</span>X<span class="sy1">&gt;</span></span> are complete types.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;action=edit&amp;section=3" title="Edit section: Stateful and stateless allocators">edit</a>]</span> <span class="mw-headline" id="Stateful_and_stateless_allocators">Stateful and stateless allocators</span></h3>
<p>Every <span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span> type is either <i>stateful</i> or <i>stateless</i>. Generally, a stateful allocator type can have unequal values which denote distinct memory resources, while a stateless allocator type denotes a single memory resource.
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx11"><td>
<p>Although custom allocators are not required to be stateless, whether and how the use of stateful allocators in the standard library is implementation-defined. Use of unequal allocator values may result in implementation-defined runtime errors or undefined behavior if the implementation does not support such usage.
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td></tr>
<tr class="t-rev t-since-cxx11"><td>
<p>Custom allocators may contain state. Each container or another allocator-aware object stores an instance of the supplied allocator and controls allocator replacement through <span class="t-lc"><a href="../memory/allocator_traits.html" title="cpp/memory/allocator traits">std::allocator_traits</a></span>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<p>Instances of a stateless allocator type always compare equal. Stateless allocator types are typically implemented as empty classes and suitable for <a href="../language/ebo.html" title="cpp/language/ebo">empty base class optimization</a>.
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<p>The member type <code>is_always_equal</code> of <span class="t-lc"><a href="../memory/allocator_traits.html" title="cpp/memory/allocator traits">std::allocator_traits</a></span> is intendedly used for determining whether an allocator type is stateless.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;action=edit&amp;section=4" title="Edit section: Fancy pointers">edit</a>]</span> <span class="mw-headline" id="Fancy_pointers">Fancy pointers</span></h3>
<p>When the member type <code>pointer</code> is not a raw pointer type, it is commonly referred to as a  <a rel="nofollow" class="external text" href="https://wg21.link/P0773R0">"fancy pointer"</a>. Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer <a rel="nofollow" class="external text" href="https://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html"><code>boost::interprocess::offset_ptr</code></a>, which makes it possible to allocate node-based data structures such as <span class="t-lc"><a href="../container/set.html" title="cpp/container/set">std::set</a></span> in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them<span class="t-rev-inl t-since-cxx11"><span>, through the class template <span class="t-lc"><a href="../memory/pointer_traits.html" title="cpp/memory/pointer traits">std::pointer_traits</a></span></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>. <span class="t-rev-inl t-since-cxx20"><span>The function <span class="t-lc">std::to_address</span> can be used to obtain a raw pointer from a fancy pointer.</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx11"><td>
<p>Use of fancy pointers and customized size/different type in the standard libary are conditionally supported. Implementations may require that member type <code>pointer</code>, <code>const_pointer</code>, <code>size_type</code>, and <code>difference_type</code> are <code>value_type*</code>, <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> value_type<span class="sy2">*</span></span>, <span class="t-lc"><a href="../types/size_t.html" title="cpp/types/size t">std::size_t</a></span>, and <span class="t-lc"><a href="../types/ptrdiff_t.html" title="cpp/types/ptrdiff t">std::ptrdiff_t</a></span>, respectively.
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td></tr>
</tbody></table>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx26"><td>
<h3> <span class="mw-headline" id="Concept">Concept</span></h3>
<p>For the definition of the query object <span class="t-lc">std::get_allocator</span>, the following exposition-only concept is defined.
</p>
<table class="t-dcl-begin"><tbody>
<tr class="t-dcl">
<td class="t-dcl-nopad"> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> Alloc<span class="sy1">&gt;</span><br>
<p>concept <span class="coMULTI">/*simple-allocator*/</span> <span class="sy1">=</span> requires<span class="br0">(</span>Alloc alloc, <a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a> n<span class="br0">)</span><br>
<span class="br0">{</span><br>
&nbsp; &nbsp; <span class="br0">{</span> <span class="sy2">*</span>alloc.<span class="me1">allocate</span><span class="br0">(</span>n<span class="br0">)</span> <span class="br0">}</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <a href="../concepts/same_as.html"><span class="kw2951">std::<span class="me2">same_as</span></span></a><span class="sy1">&lt;</span><span class="kw1">typename</span> Alloc<span class="sy4">::</span><span class="me2">value_type</span><span class="sy3">&amp;</span><span class="sy1">&gt;</span><span class="sy4">;</span><br>
&nbsp; &nbsp; <span class="br0">{</span> alloc.<span class="me1">deallocate</span><span class="br0">(</span>alloc.<span class="me1">allocate</span><span class="br0">(</span>n<span class="br0">)</span>, n<span class="br0">)</span> <span class="br0">}</span><span class="sy4">;</span> &nbsp;<br>
<span class="br0">}</span> <span class="sy3">&amp;&amp;</span> <a href="../concepts/copy_constructible.html"><span class="kw2967">std::<span class="me2">copy_constructible</span></span></a><span class="sy1">&lt;</span>Alloc<span class="sy1">&gt;</span><br>
</p>
&nbsp; <span class="sy3">&amp;&amp;</span> <a href="../concepts/equality_comparable.html"><span class="kw2968">std::<span class="me2">equality_comparable</span></span></a><span class="sy1">&lt;</span>Alloc<span class="sy1">&gt;</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td class="t-dcl-nopad">  </td>
</tr>
<tr class="t-dcl-sep"><td></td><td></td><td></td></tr>
</tbody></table>
<p>The exposition-only concept <span class="mw-geshi cpp source-cpp"><span class="coMULTI">/*simple-allocator*/</span></span> defines the minimal usability constraints of the <strong class="selflink"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span></strong> requirement.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx26">(since C++26)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;action=edit&amp;section=6" title="Edit section: Standard library">edit</a>]</span> <span class="mw-headline" id="Standard_library">Standard library</span></h3>
<p>The following standard library components satisfy the <span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">Allocator</span> requirements:
</p>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../memory/allocator.html" title="cpp/memory/allocator"> <span class="t-lines"><span>allocator</span></span></a></div></div>
</td>
<td>  the default allocator <br> <span class="t-mark">(class template)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/dsc_allocator&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../memory/scoped_allocator_adaptor.html" title="cpp/memory/scoped allocator adaptor"> <span class="t-lines"><span>scoped_allocator_adaptor</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>  implements multi-level allocator for multi-level containers <br> <span class="t-mark">(class template)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/dsc_scoped_allocator_adaptor&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../memory/polymorphic_allocator.html" title="cpp/memory/polymorphic allocator"> <span class="t-lines"><span>polymorphic_allocator</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div></div>
</td>
<td>  an allocator that supports run-time polymorphism based on the <span class="t-lc"><a href="../memory/memory_resource.html" title="cpp/memory/memory resource">std::pmr::memory_resource</a></span> it is constructed with <br> <span class="t-mark">(class template)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/dsc_polymorphic_allocator&amp;action=edit">[edit]</a></span>
</td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;action=edit&amp;section=7" title="Edit section: Examples">edit</a>]</span> <span class="mw-headline" id="Examples">Examples</span></h3>
<div class="t-example"><p>Demonstrates a C++11 allocator, except for <code>[[<a href="../language/attributes/nodiscard.html" title="cpp/language/attributes/nodiscard">nodiscard</a>]]</code> added to match C++20 style.</p><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;cstdlib&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;limits&gt;</span>
<span class="co2">#include &lt;new&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> Mallocator
<span class="br0">{</span>
    <span class="kw1">typedef</span> T value_type<span class="sy4">;</span>
&nbsp;
    Mallocator<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
&nbsp;
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> U<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> Mallocator<span class="br0">(</span><span class="kw4">const</span> Mallocator <span class="sy1">&lt;</span>U<span class="sy1">&gt;</span><span class="sy3">&amp;</span><span class="br0">)</span> <span class="kw1">noexcept</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    <span class="br0">[</span><span class="br0">[</span>nodiscard<span class="br0">]</span><span class="br0">]</span> T<span class="sy2">*</span> allocate<span class="br0">(</span><a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a> n<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>n <span class="sy1">&gt;</span> <a href="../types/numeric_limits.html"><span class="kw351">std::<span class="me2">numeric_limits</span></span></a><span class="sy1">&lt;</span><a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">max</span><span class="br0">(</span><span class="br0">)</span> <span class="sy2">/</span> sizeof<span class="br0">(</span>T<span class="br0">)</span><span class="br0">)</span>
            <span class="kw1">throw</span> <a href="../memory/new/bad_array_new_length.html"><span class="kw699">std::<span class="me2">bad_array_new_length</span></span></a><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">(</span><span class="kw4">auto</span> p <span class="sy1">=</span> <span class="kw1">static_cast</span><span class="sy1">&lt;</span>T<span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span><a href="../memory/c/malloc.html"><span class="kw763">std::<span class="me2">malloc</span></span></a><span class="br0">(</span>n <span class="sy2">*</span> sizeof<span class="br0">(</span>T<span class="br0">)</span><span class="br0">)</span><span class="br0">)</span><span class="br0">)</span>
        <span class="br0">{</span>
            report<span class="br0">(</span>p, n<span class="br0">)</span><span class="sy4">;</span>
            <span class="kw1">return</span> p<span class="sy4">;</span>
        <span class="br0">}</span>
&nbsp;
        <span class="kw1">throw</span> <a href="../memory/new/bad_alloc.html"><span class="kw698">std::<span class="me2">bad_alloc</span></span></a><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw4">void</span> deallocate<span class="br0">(</span>T<span class="sy2">*</span> p, <a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a> n<span class="br0">)</span> <span class="kw1">noexcept</span>
    <span class="br0">{</span>
        report<span class="br0">(</span>p, n, <span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>
        <a href="../memory/c/free.html"><span class="kw767">std::<span class="me2">free</span></span></a><span class="br0">(</span>p<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="kw1">private</span><span class="sy4">:</span>
    <span class="kw4">void</span> report<span class="br0">(</span>T<span class="sy2">*</span> p, <a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a> n, <span class="kw4">bool</span> alloc <span class="sy1">=</span> <span class="kw2">true</span><span class="br0">)</span> <span class="kw4">const</span>
    <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="br0">(</span>alloc <span class="sy4">?</span> <span class="st0">"Alloc: "</span> <span class="sy4">:</span> <span class="st0">"Dealloc: "</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> sizeof<span class="br0">(</span>T<span class="br0">)</span> <span class="sy2">*</span> n
                  <span class="sy1">&lt;&lt;</span> <span class="st0">" bytes at "</span> <span class="sy1">&lt;&lt;</span> <a href="../io/manip/hex.html"><span class="kw1799">std::<span class="me2">hex</span></span></a> <span class="sy1">&lt;&lt;</span> <a href="../io/manip/showbase.html"><span class="kw1783">std::<span class="me2">showbase</span></span></a>
                  <span class="sy1">&lt;&lt;</span> <span class="kw1">reinterpret_cast</span><span class="sy1">&lt;</span><span class="kw4">void</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>p<span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <a href="../io/manip/hex.html"><span class="kw1798">std::<span class="me2">dec</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span>
<span class="kw4">bool</span> operator<span class="sy1">==</span><span class="br0">(</span><span class="kw4">const</span> Mallocator <span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy3">&amp;</span>, <span class="kw4">const</span> Mallocator <span class="sy1">&lt;</span>U<span class="sy1">&gt;</span><span class="sy3">&amp;</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span>
<span class="kw4">bool</span> operator<span class="sy3">!</span><span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> Mallocator <span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy3">&amp;</span>, <span class="kw4">const</span> Mallocator <span class="sy1">&lt;</span>U<span class="sy1">&gt;</span><span class="sy3">&amp;</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">false</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1277">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, Mallocator<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;&gt;</span> v<span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span><span class="sy4">;</span>
    v.<span class="me1">push_back</span><span class="br0">(</span><span class="nu0">42</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Possible output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">Alloc: 32 bytes at 0x2020c20
Alloc: 64 bytes at 0x2023c60
Dealloc: 32 bytes at 0x2020c20
Dealloc: 64 bytes at 0x2023c60</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;action=edit&amp;section=8" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue179">LWG 179</a>
</td>
<td>C++98
</td>
<td><code>pointer</code> and <code>const_pointer</code> were not<br>required to be comparable with each other
</td>
<td>required
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue199">LWG 199</a>
</td>
<td>C++98
</td>
<td>the return value of <span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">allocate</span><span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span></span></span> was unclear
</td>
<td>it is unspecified
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue258">LWG 258</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/N2436">N2436</a>)
</td>
<td>C++98
</td>
<td>the equality relationship between allocators were<br>not required to be reflexive, symmetric or transitive
</td>
<td>required to be reflexive,<br>symmetric and transitive
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue274">LWG 274</a>
</td>
<td>C++98
</td>
<td><code>T</code> could be a const-qualified type or reference type,<br>making <span class="t-lc"><a href="../memory/allocator.html" title="cpp/memory/allocator">std::allocator</a></span> possibly ill-formed<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[1]</a></sup>
</td>
<td>prohibited these types
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2016">LWG 2016</a>
</td>
<td>C++11
</td>
<td>the copy, move and swap operations of<br>allocator might be throwing when used
</td>
<td>required to be non-throwing
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2081">LWG 2081</a>
</td>
<td>C++98<br>C++11
</td>
<td>allocators were not required to support copy<br>assignment (C++98) and move assignment (C++11)
</td>
<td>required
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2108">LWG 2108</a>
</td>
<td>C++11
</td>
<td>there was no way to show an allocator is stateless
</td>
<td><code>is_always_equal</code> provided
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2263">LWG 2263</a>
</td>
<td>C++11
</td>
<td>the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue179">LWG issue 179</a> was accidently dropped in C++11<br>and not generalized to <code>void_pointer</code> and <code>const_void_pointer</code>
</td>
<td>restored and generalized
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2447">LWG 2447</a>
</td>
<td>C++11
</td>
<td><code>T</code> could be a volatile-qualified object type
</td>
<td>prohibited these types
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/LWG/issue2593">LWG 2593</a>
</td>
<td>C++11
</td>
<td>moving from an allocator might modify its value
</td>
<td>modification forbidden
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://wg21.link/P0593R6">P0593R6</a>
</td>
<td>C++98
</td>
<td><code>allocate</code> were not required to create an<br>array object in the storage it allocated
</td>
<td>required
</td></tr></tbody></table>
<ol class="references">
<li id="cite_note-3"><span class="mw-cite-backlink"><a href="#cite_ref-3">↑</a></span> <span class="reference-text">The member types <code>reference</code> and <code>const_reference</code> of <span class="t-lc"><a href="../memory/allocator.html" title="cpp/memory/allocator">std::allocator</a></span> are defined as <code>T&amp;</code> and <code>const T&amp;</code> respectively.
<ul><li> If <code>T</code> is a reference type, <code>reference</code> and <code>const_reference</code> are ill-formed because reference to reference cannot be formed (<a href="../language/reference.html#Reference_collapsing" title="cpp/language/reference">reference collapsing</a> was introduced in C++11).
</li><li> If <code>T</code> is const-qualified, <code>reference</code> and <code>const_reference</code> are the same, and the overload set of <a href="../memory/allocator/address.html" title="cpp/memory/allocator/address"><tt>address()</tt></a> is ill-formed.
</li></ul>
</span></li>
</ol>

<!-- 
NewPP limit report
Preprocessor visited node count: 12732/1000000
Preprocessor generated node count: 17743/1000000
Post‐expand include size: 263969/4194304 bytes
Template argument size: 56948/4194304 bytes
Highest expansion depth: 20/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9133-0!*!0!!en!*!* and timestamp 20250103105531 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;oldid=177185">https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Allocator&amp;oldid=177185</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"><div id="mw-hidden-catlinks" class="mw-hidden-catlinks mw-hidden-cats-hidden">Hidden category: <ul><li><a href="https://en.cppreference.com/w/Category:Pages_with_unreviewed_LWG_DR_marker" title="Category:Pages with unreviewed LWG DR marker">Pages with unreviewed LWG DR marker</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 11.595 secs. -->
	




</body><!-- Cached 20250103105531 --><!-- Mirrored from en.cppreference.com/w/cpp/named_req/Allocator by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:36:57 GMT --></html>