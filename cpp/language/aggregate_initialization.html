<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/aggregate_initialization by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:30:58 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>Aggregate initialization</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_aggregate_initialization skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">Aggregate initialization</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>Initializes an aggregate from an initializer list<span class="t-rev-inl t-since-cxx11"><span>. It is a form of <a href="list_initialization.html" title="cpp/language/list initialization">list-initialization</a></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Definitions"><span class="tocnumber">2</span> <span class="toctext">Definitions</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Aggregate"><span class="tocnumber">2.1</span> <span class="toctext">Aggregate</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Element"><span class="tocnumber">2.2</span> <span class="toctext">Element</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Appertainment"><span class="tocnumber">2.3</span> <span class="toctext">Appertainment</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Initialization_process"><span class="tocnumber">3</span> <span class="toctext">Initialization process</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#Determining_element_kind"><span class="tocnumber">3.1</span> <span class="toctext">Determining element kind</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Explicitly_initialized_elements"><span class="tocnumber">3.2</span> <span class="toctext">Explicitly initialized elements</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Implicitly_initialized_elements"><span class="tocnumber">3.3</span> <span class="toctext">Implicitly initialized elements</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Arrays_with_unknown_bounds"><span class="tocnumber">4</span> <span class="toctext">Arrays with unknown bounds</span></a></li>
<li class="toclevel-1"><a href="#Designated_initializers"><span class="tocnumber">5</span> <span class="toctext">Designated initializers</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Character_arrays"><span class="tocnumber">6</span> <span class="toctext">Character arrays</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Notes"><span class="tocnumber">7</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Example"><span class="tocnumber">8</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Defect_reports"><span class="tocnumber">9</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#See_also"><span class="tocnumber">10</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=1" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span></h3>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">T object</span><code>&nbsp;</code><code><b>= {</b></code> <span class="t-spar">arg1, arg2, ...</span> <code><b>};</b></code>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">T object</span> <code><b>{</b></code> <span class="t-spar">arg1, arg2, ...</span> <code><b>};</b></code>
</td>
<td> (2)
</td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">T object</span><code>&nbsp;</code><code><b>= { .</b></code><span class="t-spar">des1</span><code>&nbsp;</code><code><b>=</b></code><code>&nbsp;</code><span class="t-spar">arg1</span> <code><b>, .</b></code><span class="t-spar">des2</span> <code><b>{</b></code> <span class="t-spar">arg2</span> <code><b>}</b></code> <span class="t-spar">...</span> <code><b>};</b></code>
</td>
<td> (3)
</td>
<td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">T object</span> <code><b>{ .</b></code><span class="t-spar">des1</span><code>&nbsp;</code><code><b>=</b></code><code>&nbsp;</code><span class="t-spar">arg1</span> <code><b>, .</b></code><span class="t-spar">des2</span> <code><b>{</b></code> <span class="t-spar">arg2</span> <code><b>}</b></code> <span class="t-spar">...</span> <code><b>};</b></code>
</td>
<td> (4)
</td>
<td> <span class="t-mark-rev t-since-cxx20">(since C++20)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<div class="t-li1"><span class="t-li">1,2)</span> Initializing an aggregate with an ordinary initializer list.</div>
<div class="t-li1"><span class="t-li">3,4)</span> Initializing an aggregate with <a href="#Designated_initializers">designated initializers</a> (aggregate class only).</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=2" title="Edit section: Definitions">edit</a>]</span> <span class="mw-headline" id="Definitions">Definitions</span></h3>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=3" title="Edit section: Aggregate">edit</a>]</span> <span class="mw-headline" id="Aggregate">Aggregate</span></h4>
<p>An <i>aggregate</i> is one of the following types:
</p>
<ul><li> array types
</li><li> class types that has
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx11"><td>
<dl><dd><ul><li> no user-declared constructors
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td></tr>
<tr class="t-rev t-since-cxx11 t-until-cxx20"><td>
<dl><dd><ul><li> no <a href="function.html#User-provided_functions" title="cpp/language/function">user-provided</a>, <a href="using_declaration.html#Inheriting_constructors" title="cpp/language/using declaration">inherited</a>, or <a href="explicit.html" title="cpp/language/explicit">explicit</a> constructors
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<dl><dd><ul><li> no user-declared or inherited constructors
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</tbody></table>
<dl><dd><ul><li> no private or protected direct non-static data members
</li></ul>
</dd></dl>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx17"><td>
<dl><dd><ul><li> no <a href="derived_class.html" title="cpp/language/derived class">base classes</a>
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td></tr>
<tr class="t-rev t-since-cxx17"><td>
<dl><dd><ul><li> no <a href="derived_class.html#Virtual_base_classes" title="cpp/language/derived class">virtual base classes</a>
</li><li> no <a href="derived_class.html#Private_inheritance" title="cpp/language/derived class">private</a> or <a href="derived_class.html#Protected_inheritance" title="cpp/language/derived class">protected</a> direct base classes
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<dl><dd><ul><li> no virtual member functions
</li></ul>
</dd></dl>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11 t-until-cxx14"><td>
<dl><dd><ul><li> no <a href="data_members.html#Member_initialization" title="cpp/language/data members">default member initializers</a>
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td></tr>
</tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=4" title="Edit section: Element">edit</a>]</span> <span class="mw-headline" id="Element">Element</span></h4>
<p>The <i>elements</i> of an aggregate are:
</p>
<ul><li> for an array, the array elements in increasing subscript order, or
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx17"><td>
<ul><li> for a class, the non-static data members that are not anonymous <a href="bit_field.html" title="cpp/language/bit field">bit-fields</a>, in declaration order.
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td></tr>
<tr class="t-rev t-since-cxx17"><td>
<ul><li> for a class, the direct base classes in declaration order, followed by the direct non-static data members that are neither anonymous <a href="bit_field.html" title="cpp/language/bit field">bit-fields</a> nor members of an <a href="union.html#Anonymous_unions" title="cpp/language/union">anonymous union</a>, in declaration order.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=5" title="Edit section: Appertainment">edit</a>]</span> <span class="mw-headline" id="Appertainment">Appertainment</span></h4>
<p>Each <a href="initialization.html" title="cpp/language/initialization">initializer clause</a> in a brace-enclosed initializer list is said to <i>appertain</i> to an element of the aggregate being initialized or to an element of one of its subaggregates.
</p><p>Considering the sequence of initializer clauses, and the sequence of aggregate elements initially formed as the sequence of elements of the aggregate being initialized and potentially modified as described below:
</p>
<ul><li> For each initializer clause, if any of the following conditions is satisfied, it appertains to the corresponding aggregate element <span class="t-c"><span class="mw-geshi cpp source-cpp">elem</span></span>:
</li></ul>
<dl><dd><ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">elem</span></span> is not an aggregate.
</li><li> The initializer clause begins with <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">{</span></span></span>.
</li><li> The initializer clause is an expression, and an <a href="implicit_conversion.html" title="cpp/language/implicit conversion">implicit conversion sequence</a> can be formed that converts the expression to the type of <span class="t-c"><span class="mw-geshi cpp source-cpp">elem</span></span>.
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">elem</span></span> is an aggregate that itself has no aggregate elements.
</li></ul>
</dd></dl>
<ul><li> Otherwise, <span class="t-c"><span class="mw-geshi cpp source-cpp">elem</span></span> is an aggregate and that subaggregate is replaced in the list of aggregate elements by the sequence of its own aggregate elements, and the appertainment analysis resumes with the first such element and the same initializer clause. In other words, these rules apply recursively to the aggregate’s subaggregates.
</li></ul>
<p>The analysis is complete when all initializer clauses have been exhausted. If any initializer clause remains that does not appertain to an element of the aggregate or one of its subaggregates, the program is ill-formed.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> S1 <span class="br0">{</span> <span class="kw4">int</span> a, b<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> S2 <span class="br0">{</span> S1 s, t<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// Each subaggregate of “x” is appertained to an initializer clause starting with {</span>
S2 x<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span>
<span class="br0">{</span>
    <span class="co1">// appertains to “x[0]”</span>
    <span class="br0">{</span>
        <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">}</span>, <span class="co1">// appertains to “x[0].s”</span>
        <span class="br0">{</span><span class="nu0">3</span>, <span class="nu0">4</span><span class="br0">}</span>  <span class="co1">// appertains to “x[0].t”</span>
    <span class="br0">}</span>,
    <span class="co1">// appertains to “x[1]”</span>
    <span class="br0">{</span>
        <span class="br0">{</span><span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span>, <span class="co1">// appertains to “x[1].s”</span>
        <span class="br0">{</span><span class="nu0">7</span>, <span class="nu0">8</span><span class="br0">}</span>  <span class="co1">// appertains to “x[1].t”</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// “x” and “y” have the same value (see below)</span>
S2 y<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span>, <span class="nu0">7</span>, <span class="nu0">8</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// The process of the appertainment analysis of “y”:</span>
<span class="co1">// 1. Initializes the aggregate element sequence (x[0], x[1]) and</span>
<span class="co1">//    the initializer clause sequence (1, 2, 3, 4, 5, 6, 7, 8).</span>
<span class="co1">// 2. Starting from the first elements of each sequence,</span>
<span class="co1">//    checks whether 1 appertains to x[0]:</span>
<span class="co1">//    · x[0] is an aggregate.</span>
<span class="co1">//    · 1 does not begin with {.</span>
<span class="co1">//    · 1 is an expression, but it cannot be implicitly converted to S2.</span>
<span class="co1">//    · x[0] has aggregate elements.</span>
<span class="co1">// 3. 0 cannot appertain to x[0], therefore x[0] is replaced by x[0].s and x[0].t,</span>
<span class="co1">//    the aggregate element sequence becomes (x[0].s, x[0].t, x[1]).</span>
<span class="co1">// 4. Resumes the appertainment check, but 1 cannot appertain to x[0].s either.</span>
<span class="co1">// 5. The aggregate element sequence now becomes (x[0].s.a, x[0].s.b, x[0].t, x[1]).</span>
<span class="co1">// 6. Resumes the appertainment check again:</span>
<span class="co1">//    1 appertains to x[0].s.a, and 2 appertains to x[0].s.b.</span>
<span class="co1">// 7. The rest of the appertainment analysis works similarly.</span>
&nbsp;
<span class="kw4">char</span> cv<span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="st0">'a'</span>, <span class="st0">'s'</span>, <span class="st0">'d'</span>, <span class="st0">'f'</span>, <span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// Error: too many initializer clauses</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=6" title="Edit section: Initialization process">edit</a>]</span> <span class="mw-headline" id="Initialization_process">Initialization process</span></h3>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=7" title="Edit section: Determining element kind">edit</a>]</span> <span class="mw-headline" id="Determining_element_kind">Determining element kind</span></h4>
<p>The effects of aggregate initialization are:
</p>
<div class="t-li1"><span class="t-li">1)</span> Determine the <i>explicitly initialized elements</i> of the aggregate as follows:</div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx20"><td>
<dl><dd><ul><li> If the initializer list is a <a href="#Designated_initializers">designated initializer list</a> (the aggregate can only be of class type), the identifier in each designator shall name a direct non-static data member of the class, and the explicitly initialized elements of the aggregate are the elements that are, or contain, those members.
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</tbody></table>
<dl><dd><ul><li> Otherwise, if the initializer list is non-empty, the explicitly initialized elements of the aggregate are the elements with an appertained initializer clause and the elements having a subaggregate with an appertained initializer clause.
</li><li> Otherwise, the initializer list must be empty (<span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">{</span><span class="br0">}</span></span></span>), and there are no explicitly initialized elements.
</li></ul>
</dd></dl>
<dl><dd>The program is ill-formed if the aggregate is a union and there are two or more explicitly initialized elements:
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">union</span> u <span class="br0">{</span> <span class="kw4">int</span> a<span class="sy4">;</span> <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> b<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
u a <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="br0">}</span><span class="sy4">;</span>                   <span class="co1">// OK: explicitly initializes member `a`</span>
u b <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">0</span>, <span class="st0">"asdf"</span><span class="br0">}</span><span class="sy4">;</span>           <span class="co1">// error: explicitly initializes two members</span>
u c <span class="sy1">=</span> <span class="br0">{</span><span class="st0">"asdf"</span><span class="br0">}</span><span class="sy4">;</span>              <span class="co1">// error: int cannot be initialized by "asdf"</span>
&nbsp;
<span class="co1">// C++20 designated initializer lists</span>
u d <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">b</span> <span class="sy1">=</span> <span class="st0">"asdf"</span><span class="br0">}</span><span class="sy4">;</span>         <span class="co1">// OK: can explicitly initialize a non-initial member</span>
u e <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">a</span> <span class="sy1">=</span> <span class="nu0">1</span>, .<span class="me1">b</span> <span class="sy1">=</span> <span class="st0">"asdf"</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error: explicitly initializes two members</span></pre></div></div>
<div class="t-li1"><span class="t-li">2)</span> Initialize each element of the aggregate<span class="t-rev-inl t-since-cxx11"><span> in the element order. That is, all value computations and side effects associated with a given element are <a href="eval_order.html" title="cpp/language/eval order">sequenced before</a> those of any element that follows it in order</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.</div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=8" title="Edit section: Explicitly initialized elements">edit</a>]</span> <span class="mw-headline" id="Explicitly_initialized_elements">Explicitly initialized elements</span></h4>
<p>For each explicitly initialized element:
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx20"><td>
<ul><li> If the element is an anonymous union member and the initializer list is a <a href="#Designated_initializers">designated initializer list</a>, the element is initialized by the designated initializer list <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">{</span>D<span class="br0">}</span></span></span>, where <code>D</code> is the designated initializer clause naming a member of the anonymous union member. There shall be only one such designated initializer clause.
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C
<span class="br0">{</span>
    <span class="kw1">union</span>
    <span class="br0">{</span>
        <span class="kw4">int</span> a<span class="sy4">;</span>
        <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> p<span class="sy4">;</span>
    <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
    <span class="kw4">int</span> x<span class="sy4">;</span>
<span class="br0">}</span> c <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">a</span> <span class="sy1">=</span> <span class="nu0">1</span>, .<span class="me1">x</span> <span class="sy1">=</span> <span class="nu0">3</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// initializes c.a with 1 and c.x with 3</span></pre></div></div>
<ul><li> Otherwise, if the initializer list is a designated initializer list, the element is initialized with the initializer of the corresponding designated initializer clause.
</li></ul>
<dl><dd><ul><li> If that initializer is of <a href="initialization.html" title="cpp/language/initialization">syntax <span class="t-v">(1)</span></a>, and a narrowing conversion is required to convert the expression, the program is ill-formed.
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</tbody></table>
<p><br>
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx20"><td>
<ul><li> The initializer list is a brace-enclosed initializer list:
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<ul><li> Otherwise, the initializer list is a non-designated brace-enclosed initializer list:
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</tbody></table>
<dl><dd><ul><li> If an initializer clause appertains to the aggregate element, then the aggregate element is <a href="copy_initialization.html" title="cpp/language/copy initialization">copy-initialized</a> from the initializer clause.
</li><li> Otherwise, the aggregate element is copy-initialized from a brace-enclosed initializer list consisting of all of the initializer clauses that appertain to subobjects of the aggregate element, in the order of appearance.
</li></ul>
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A
<span class="br0">{</span>
    <span class="kw4">int</span> x<span class="sy4">;</span>
&nbsp;
    <span class="kw1">struct</span> B
    <span class="br0">{</span>
        <span class="kw4">int</span> i<span class="sy4">;</span>
        <span class="kw4">int</span> j<span class="sy4">;</span>
    <span class="br0">}</span> b<span class="sy4">;</span>
<span class="br0">}</span> a <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="br0">{</span><span class="nu0">2</span>, <span class="nu0">3</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// initializes a.x with 1, a.b.i with 2, a.b.j with 3</span>
&nbsp;
<span class="kw1">struct</span> base1 <span class="br0">{</span> <span class="kw4">int</span> b1, b2 <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> base2
<span class="br0">{</span>
    base2<span class="br0">(</span><span class="br0">)</span>
    <span class="br0">{</span>
        b3 <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw4">int</span> b3<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> derived <span class="sy4">:</span> base1, base2
<span class="br0">{</span>
    <span class="kw4">int</span> d<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
derived d1<span class="br0">{</span><span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">}</span>, <span class="br0">{</span><span class="br0">}</span>, <span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// initializes d1.b1 with 1, d1.b2 with 2,</span>
                           <span class="co1">//             d1.b3 with 42, d1.d with 4</span>
derived d2<span class="br0">{</span><span class="br0">{</span><span class="br0">}</span>, <span class="br0">{</span><span class="br0">}</span>, <span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span>     <span class="co1">// initializes d2.b1 with 0, d2.b2 with 42,</span>
                           <span class="co1">//             d2.b3 with 42, d2.d with 4</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=9" title="Edit section: Implicitly initialized elements">edit</a>]</span> <span class="mw-headline" id="Implicitly_initialized_elements">Implicitly initialized elements</span></h4>
<p>For a non-union aggregate, each element that is not an explicitly initialized element is initialized as follows:
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<ul><li> If the element has a <a href="data_members.html#Member_initialization" title="cpp/language/data members">default member initializer</a>, the element is initialized from that initializer.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<ul><li> Otherwise, if the element is not a reference, the element is <a href="copy_initialization.html" title="cpp/language/copy initialization">copy-initialized</a> from an empty initializer list.
</li><li> Otherwise, the program is ill-formed.
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> S
<span class="br0">{</span>
    <span class="kw4">int</span> a<span class="sy4">;</span>
    <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> b<span class="sy4">;</span>
    <span class="kw4">int</span> c<span class="sy4">;</span>
    <span class="kw4">int</span> d <span class="sy1">=</span> b<span class="br0">[</span>a<span class="br0">]</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// initializes ss.a with 1,</span>
<span class="co1">//             ss.b with "asdf",</span>
<span class="co1">//             ss.c with the value of an expression of the form int{} (that is, 0),</span>
<span class="co1">//         and ss.d with the value of ss.b[ss.a] (that is, 's')</span>
S ss <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="st0">"asdf"</span><span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>If the aggregate is a union and the initializer list is empty, then
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<ul><li> If any variant member has a default member initializer, that member is initialized from its default member initializer.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<ul><li> Otherwise, the first member of the union (if any) is copy-initialized from an empty initializer list.
</li></ul>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=10" title="Edit section: Arrays with unknown bounds">edit</a>]</span> <span class="mw-headline" id="Arrays_with_unknown_bounds">Arrays with unknown bounds</span></h3>
<p>The number of elements in an array of unknown bound initialized with a brace-enclosed initializer list is the number of explicitly initialized elements of the array. An array of unknown bound cannot be initialized with <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">{</span><span class="br0">}</span></span></span>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> x<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">3</span>, <span class="nu0">5</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// x has 3 elements</span>
&nbsp;
<span class="kw1">struct</span> Y <span class="br0">{</span> <span class="kw4">int</span> i, j, k<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
Y y<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// y has only 2 elements:</span>
                            <span class="co1">// 1, 2 and 3 appertain to y[0],</span>
                            <span class="co1">// 4, 5 and 6 appertain to y[1]</span>
&nbsp;
<span class="kw4">int</span> z<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// Error: cannot declare an array without any element</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx20"><td>
<h3> <span class="mw-headline" id="Designated_initializers">Designated initializers</span></h3>
<p>The syntax forms <span class="t-v">(3,4)</span> are known as designated initializers: each <span class="t-spar">designator</span> must name a direct non-static data member of T, and all <span class="t-spar">designator</span> ﻿s used in the expression must appear in the same order as the data members of T.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span> <span class="kw4">int</span> x<span class="sy4">;</span> <span class="kw4">int</span> y<span class="sy4">;</span> <span class="kw4">int</span> z<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
A a<span class="br0">{</span>.<span class="me1">y</span> <span class="sy1">=</span> <span class="nu0">2</span>, .<span class="me1">x</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error; designator order does not match declaration order</span>
A b<span class="br0">{</span>.<span class="me1">x</span> <span class="sy1">=</span> <span class="nu0">1</span>, .<span class="me1">z</span> <span class="sy1">=</span> <span class="nu0">2</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// ok, b.y initialized to 0</span></pre></div></div>
<p>Each direct non-static data member named by the designated initializer is initialized from the corresponding brace-or-equals initializer that follows the designator. Narrowing conversions are prohibited.
</p><p>Designated initializer can be used to initialize a <a href="union.html" title="cpp/language/union">union</a> into the state other than the first. Only one initializer may be provided for a union.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">union</span> u <span class="br0">{</span> <span class="kw4">int</span> a<span class="sy4">;</span> <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> b<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
u f <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">b</span> <span class="sy1">=</span> <span class="st0">"asdf"</span><span class="br0">}</span><span class="sy4">;</span>         <span class="co1">// OK, active member of the union is b</span>
u g <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">a</span> <span class="sy1">=</span> <span class="nu0">1</span>, .<span class="me1">b</span> <span class="sy1">=</span> <span class="st0">"asdf"</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// Error, only one initializer may be provided</span></pre></div></div>
<p>For a non-union aggregate, elements for which a designated initializer is not provided are initialized the same as described above for when the number of initializer clauses is less than the number of members (default member initializers where provided, empty list-initialization otherwise):
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A
<span class="br0">{</span>
    string str<span class="sy4">;</span>
    <span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span>
    <span class="kw4">int</span> m <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
A<span class="br0">{</span>.<span class="me1">m</span> <span class="sy1">=</span> <span class="nu0">21</span><span class="br0">}</span> <span class="co1">// Initializes str with {}, which calls the default constructor</span>
           <span class="co1">// then initializes n with = 42</span>
           <span class="co1">// then initializes m with = 21</span></pre></div></div>
<p>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.
</p><p>Note: out-of-order designated initialization, nested designated initialization, mixing of designated initializers and regular initializers, and designated initialization of arrays are all supported in the <a href="https://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">C programming language</a>, but are not allowed in C++.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span> <span class="kw4">int</span> x, y<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> B <span class="br0">{</span> <span class="kw1">struct</span> A a<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> A a <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">y</span> <span class="sy1">=</span> <span class="nu0">1</span>, .<span class="me1">x</span> <span class="sy1">=</span> <span class="nu0">2</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// valid C, invalid C++ (out of order)</span>
<span class="kw4">int</span> arr<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="br0">[</span><span class="nu0">1</span><span class="br0">]</span> <span class="sy1">=</span> <span class="nu0">5</span><span class="br0">}</span><span class="sy4">;</span>        <span class="co1">// valid C, invalid C++ (array)</span>
<span class="kw1">struct</span> B b <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">a</span>.<span class="me1">x</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">}</span><span class="sy4">;</span>       <span class="co1">// valid C, invalid C++ (nested)</span>
<span class="kw1">struct</span> A a <span class="sy1">=</span> <span class="br0">{</span>.<span class="me1">x</span> <span class="sy1">=</span> <span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">}</span><span class="sy4">;</span>      <span class="co1">// valid C, invalid C++ (mixed)</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=12" title="Edit section: Character arrays">edit</a>]</span> <span class="mw-headline" id="Character_arrays">Character arrays</span></h3>
<p>Arrays of ordinary character types (<span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">signed</span> <span class="kw4">char</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span>)<span class="t-rev-inl t-since-cxx20"><span>, <span class="mw-geshi cpp source-cpp">char8_t</span></span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">char16_t</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">char32_t</span></span></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, or <span class="mw-geshi cpp source-cpp"><span class="kw4">wchar_t</span></span> can be initialized from ordinary <a href="string_literal.html" title="cpp/language/string literal">string literals</a><span class="t-rev-inl t-since-cxx20"><span>, UTF-8 string literals</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>, UTF-16 string literals, UTF-32 string literals</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, or wide string literals, respectively, optionally enclosed in braces<span class="t-rev-inl t-since-cxx20"><span>. Additionally, an array of <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span> may be initialized by a UTF-8 string literal, optionally enclosed in braces</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array<span class="t-rev-inl t-since-cxx20"><span>, with an <a href="implicit_conversion.html#Integral_conversions" title="cpp/language/implicit conversion">integral conversion</a> if necessary for the source and destination value</span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">char</span> a<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="st0">"abc"</span><span class="sy4">;</span>
<span class="co1">// equivalent to char a[4] = {'a', 'b', 'c', '\0'};</span>
&nbsp;
<span class="co1">//  unsigned char b[3] = "abc"; // Error: initializer string too long</span>
<span class="kw4">unsigned</span> <span class="kw4">char</span> b<span class="br0">[</span><span class="nu0">5</span><span class="br0">]</span><span class="br0">{</span><span class="st0">"abc"</span><span class="br0">}</span><span class="sy4">;</span>
<span class="co1">// equivalent to unsigned char b[5] = {'a', 'b', 'c', '\0', '\0'};</span>
&nbsp;
<span class="kw4">wchar_t</span> c<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span>L<span class="st0">"кошка"</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// optional braces</span>
<span class="co1">// equivalent to wchar_t c[6] = {L'к', L'о', L'ш', L'к', L'а', L'\0'};</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=13" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<p>An aggregate class or array may include non-aggregate<span class="t-rev-inl t-since-cxx17"><span> public bases</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).
</p><p>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed.
</p><p>Until C++11, aggregate initialization could only be used in variable definition, and could not be used in a <a href="constructor.html" title="cpp/language/constructor">constructor initializer list</a>, a <a href="new.html" title="cpp/language/new">new-expression</a>, or temporary object creation due to syntax restrictions.
</p><p>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.
</p>
<table class="wikitable sortable ftm-begin ftm-has-value">

<tbody><tr>
<th>Feature-test macro
</th>
<th><abbr title="The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.">Value</abbr>
</th>
<th><abbr title="Standard in which the feature is introduced; DR means defect report against that revision">Std</abbr>
</th>
<th>Feature
</th></tr>
<tr>
<td><a href="../feature_test.html#cpp_aggregate_bases" title="cpp/feature test"><code>__cpp_aggregate_bases</code></a></td>
<td><a href="../compiler_support/17.html#cpp_aggregate_bases_201603L" title="cpp/compiler support/17"><code>201603L</code></a></td>
<td><span class="t-mark">(C++17)</span></td>
<td>Aggregate classes with base classes
</td></tr>
<tr>
<td><a href="../feature_test.html#cpp_aggregate_nsdmi" title="cpp/feature test"><code>__cpp_aggregate_nsdmi</code></a></td>
<td><a href="../compiler_support/14.html#cpp_aggregate_nsdmi_201304L" title="cpp/compiler support/14"><code>201304L</code></a></td>
<td><span class="t-mark">(C++14)</span></td>
<td>Aggregate classes with default member initializers
</td></tr>
<tr>
<td><a href="../feature_test.html#cpp_aggregate_paren_init" title="cpp/feature test"><code>__cpp_aggregate_paren_init</code></a></td>
<td><a href="../compiler_support/20.html#cpp_aggregate_paren_init_201902L" title="cpp/compiler support/20"><code>201902L</code></a></td>
<td><span class="t-mark">(C++20)</span></td>
<td>Aggregate initialization in the form of <a href="direct_initialization.html" title="cpp/language/direct initialization">direct initialization</a>
</td></tr>
<tr>
<td><a href="../feature_test.html#cpp_char8_t" title="cpp/feature test"><code>__cpp_char8_t</code></a></td>
<td><a href="../compiler_support/23.html#cpp_char8_t_202207L" title="cpp/compiler support/23"><code>202207L</code></a></td>
<td><span class="t-mark">(C++23)</span><br><span class="t-mark">(DR20)</span></td>
<td><span class="mw-geshi cpp source-cpp">char8_t</span> compatibility and portability fix (<a href="#Character_arrays">allow initialization of (<span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span> arrays</a> from <a href="string_literal.html" title="cpp/language/string literal">UTF-8 string literals</a>)
</td></tr>
<tr>
<td><a href="../feature_test.html#cpp_designated_initializers" title="cpp/feature test"><code>__cpp_designated_initializers</code></a></td>
<td><a href="../compiler_support/20.html#cpp_designated_initializers_201707L" title="cpp/compiler support/20"><code>201707L</code></a></td>
<td><span class="t-mark">(C++20)</span></td>
<td><a href="#Designated_initializers">Designated initializers</a>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=14" title="Edit section: Example">edit</a>]</span> <span class="mw-headline" id="Example">Example</span></h3>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;array&gt;</span>
<span class="co2">#include &lt;cstdio&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
&nbsp;
<span class="kw1">struct</span> S
<span class="br0">{</span>
    <span class="kw4">int</span> x<span class="sy4">;</span>
&nbsp;
    <span class="kw1">struct</span> Foo
    <span class="br0">{</span>
        <span class="kw4">int</span> i<span class="sy4">;</span>
        <span class="kw4">int</span> j<span class="sy4">;</span>
        <span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="sy4">;</span>
    <span class="br0">}</span> b<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    S s1 <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="br0">{</span><span class="nu0">2</span>, <span class="nu0">3</span>, <span class="br0">{</span><span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span>
    S s2 <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// same, but with brace elision</span>
    S s3<span class="br0">{</span><span class="nu0">1</span>, <span class="br0">{</span><span class="nu0">2</span>, <span class="nu0">3</span>, <span class="br0">{</span><span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// same, using direct-list-initialization syntax</span>
    S s4<span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span>, <span class="nu0">5</span>, <span class="nu0">6</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// error until CWG 1270:</span>
                            <span class="co1">// brace elision only allowed with equals sign</span>
&nbsp;
    <span class="kw4">int</span> ar<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// ar is int[3]</span>
<span class="co1">//  char cr[3] = {'a', 'b', 'c', 'd'}; // too many initializer clauses</span>
    <span class="kw4">char</span> cr<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="st0">'a'</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// array initialized as {'a', '\0', '\0'}</span>
&nbsp;
    <span class="kw4">int</span> ar2d1<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">}</span>, <span class="br0">{</span><span class="nu0">3</span>, <span class="nu0">4</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// fully-braced 2D array: {1, 2}</span>
                                        <span class="co1">//                        {3, 4}</span>
    <span class="kw4">int</span> ar2d2<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span>, <span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// brace elision: {1, 2}</span>
                                    <span class="co1">//                {3, 4}</span>
    <span class="kw4">int</span> ar2d3<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="br0">{</span><span class="nu0">1</span><span class="br0">}</span>, <span class="br0">{</span><span class="nu0">2</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span>   <span class="co1">// only first column: {1, 0}</span>
                                    <span class="co1">//                    {2, 0}</span>
&nbsp;
    <a href="../container/array.html"><span class="kw1276">std::<span class="me2">array</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="nu0">3</span><span class="sy1">&gt;</span> std_ar2<span class="br0">{</span><span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span>  <span class="co1">// std::array is an aggregate</span>
    <a href="../container/array.html"><span class="kw1276">std::<span class="me2">array</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="nu0">3</span><span class="sy1">&gt;</span> std_ar1 <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// brace-elision okay</span>
&nbsp;
<span class="co1">//  int ai[] = {1, 2.0}; // narrowing conversion from double to int:</span>
                         <span class="co1">// error in C++11, okay in C++03</span>
&nbsp;
    <a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a> ars<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a><span class="br0">(</span><span class="st0">"one"</span><span class="br0">)</span>, <span class="co1">// copy-initialization</span>
                         <span class="st0">"two"</span>,              <span class="co1">// conversion, then copy-initialization</span>
                         <span class="br0">{</span><span class="st0">'t'</span>, <span class="st0">'h'</span>, <span class="st0">'r'</span>, <span class="st0">'e'</span>, <span class="st0">'e'</span><span class="br0">}</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// list-initialization</span>
    <span class="kw1">union</span> U
    <span class="br0">{</span>
        <span class="kw4">int</span> a<span class="sy4">;</span>
        <span class="kw4">const</span> <span class="kw4">char</span><span class="sy2">*</span> b<span class="sy4">;</span>
    <span class="br0">}</span><span class="sy4">;</span>
    U u1 <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="br0">}</span><span class="sy4">;</span>         <span class="co1">// OK, first member of the union</span>
<span class="co1">//  U u2 = {0, "asdf"}; // error: too many initializers for union</span>
<span class="co1">//  U u3 = {"asdf"};    // error: invalid conversion to int</span>
&nbsp;
    <span class="br0">[</span><span class="br0">]</span><span class="br0">(</span>...<span class="br0">)</span> <span class="br0">{</span> <a href="../io/c/puts.html"><span class="kw1847">std::<span class="me2">puts</span></span></a><span class="br0">(</span><span class="st0">"Garbage collecting unused variables... Done."</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
    <span class="br0">(</span>
        s1, s2, s3, s4, ar, cr, ar2d1, ar2d2, ar2d3, std_ar2, std_ar1, u1
    <span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// aggregate</span>
<span class="kw1">struct</span> base1 <span class="br0">{</span> <span class="kw4">int</span> b1, b2 <span class="sy1">=</span> <span class="nu0">42</span><span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// non-aggregate</span>
<span class="kw1">struct</span> base2
<span class="br0">{</span>
    base2<span class="br0">(</span><span class="br0">)</span> <span class="sy4">:</span> b3<span class="br0">(</span><span class="nu0">42</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    <span class="kw4">int</span> b3<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// aggregate in C++17</span>
<span class="kw1">struct</span> derived <span class="sy4">:</span> base1, base2 <span class="br0">{</span> <span class="kw4">int</span> d<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
derived d1<span class="br0">{</span><span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span><span class="br0">}</span>, <span class="br0">{</span><span class="br0">}</span>, <span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// d1.b1 = 1, d1.b2 = 2,  d1.b3 = 42, d1.d = 4</span>
derived d2<span class="br0">{</span><span class="br0">{</span><span class="br0">}</span>, <span class="br0">{</span><span class="br0">}</span>, <span class="nu0">4</span><span class="br0">}</span><span class="sy4">;</span>     <span class="co1">// d2.b1 = 0, d2.b2 = 42, d2.b3 = 42, d2.d = 4</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">Garbage collecting unused variables... Done.</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=15" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/413.html">CWG 413</a>
</td>
<td>C++98
</td>
<td>anonymous bit-fields were initialized in aggregate initialization
</td>
<td>they are ignored
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/737.html">CWG 737</a>
</td>
<td>C++98
</td>
<td>when a character array is initialized with a string literal<br>having fewer characters than the array size, the character<br>elements after the trailing <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="st0">'<span class="es5">\0</span>'</span></span></span> was uninitialized
</td>
<td>they are<br>zero-initialized
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1270.html">CWG 1270</a>
</td>
<td>C++11
</td>
<td>brace elision was only allowed to be used in copy-list-initialization
</td>
<td>allowed elsewhere
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1518.html">CWG 1518</a>
</td>
<td>C++11
</td>
<td>a class that declares  an explicit default constructor or<br>has inherited constructors should could be an aggregate
</td>
<td>it is not an<br>aggregate
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1622.html">CWG 1622</a>
</td>
<td>C++98
</td>
<td>a union could not be initialized with <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">{</span><span class="br0">}</span></span></span>
</td>
<td>allowed
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2149.html">CWG 2149</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/P3106R1">P3106R1</a>)
</td>
<td>C++98
</td>
<td>it was unclear whether brace elision is<br>applicable during array size deduction
</td>
<td>applicable
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2272.html">CWG 2272</a>
</td>
<td>C++98
</td>
<td>a non-static reference member that is not explicitly<br>initialized was copy-initialized from an empty initializer list
</td>
<td>the program is ill-<br>formed in this case
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2610.html">CWG 2610</a>
</td>
<td>C++17
</td>
<td>aggregate types could not have private or protected indirect base classes
</td>
<td>allowed
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2619.html">CWG 2619</a>
</td>
<td>C++20
</td>
<td>the kind of the initialization from designated initializers was unclear
</td>
<td>it depends on the<br>kind of the initializer
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://wg21.link/P2513R4">P2513R4</a>
</td>
<td>C++20
</td>
<td>a UTF-8 string literal could not initialize an array of <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span><br>or <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span>, which was incompatible with C or C++17
</td>
<td>such initialization<br>is valid
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;action=edit&amp;section=16" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<ul><li> <a href="copy_elision.html" title="cpp/language/copy elision">copy elision</a>
</li><li> <a href="initialization.html" title="cpp/language/initialization">initialization</a>
<ul><li> <a href="constant_initialization.html" title="cpp/language/constant initialization">constant initialization</a>
</li><li> <a href="list_initialization.html" title="cpp/language/list initialization">list initialization</a>
</li><li> <a href="reference_initialization.html" title="cpp/language/reference initialization">reference initialization</a>
</li><li> <a href="value_initialization.html" title="cpp/language/value initialization">value initialization</a>
</li><li> <a href="zero_initialization.html" title="cpp/language/zero initialization">zero initialization</a>
</li></ul>
</li></ul>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see"><span><a href="https://en.cppreference.com/w/c/language/struct_initialization" title="c/language/struct initialization">C documentation</a></span> for <span class=""><span>Struct and union initialization</span></span></div>
</td></tr>

</tbody></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 6023/1000000
Preprocessor generated node count: 13129/1000000
Post‐expand include size: 173624/4194304 bytes
Template argument size: 43610/4194304 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:8871-0!*!0!!en!*!* and timestamp 20250111211158 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;oldid=179506">https://en.cppreference.com/mwiki/index.php?title=cpp/language/aggregate_initialization&amp;oldid=179506</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 0.038 secs. -->
	




</body><!-- Cached 20250111211552 --><!-- Mirrored from en.cppreference.com/w/cpp/language/aggregate_initialization by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:30:58 GMT --></html>