<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/constraints by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:30:58 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>Constraints and concepts (since C++20)</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_constraints skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">Constraints and concepts <span class="t-mark-rev t-since-cxx20">(since C++20)</span></h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p><a href="class_template.html" title="cpp/language/class template">Class templates</a>, <a href="function_template.html" title="cpp/language/function template">function templates</a> (include <a href="lambda.html" title="cpp/language/lambda">generic lambdas</a>), and other <a href="templates.html#Templated_entity" title="cpp/language/templates">templated functions</a> (typically members of class templates) might be associated with a <i>constraint</i>, which specifies the requirements on template arguments, which can be used to select the most appropriate function overloads and template specializations.
</p><p>Named sets of such <a href="requires.html" title="cpp/language/requires">requirements</a> are called <i>concepts</i>. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;cstddef&gt;</span>
<span class="co2">#include &lt;concepts&gt;</span>
<span class="co2">#include &lt;functional&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
&nbsp;
<span class="co1">// Declaration of the concept “Hashable”, which is satisfied by any type “T”</span>
<span class="co1">// such that for values “a” of type “T”, the expression std::hash&lt;T&gt;{}(a)</span>
<span class="co1">// compiles and its result is convertible to std::size_t</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept Hashable <span class="sy1">=</span> requires<span class="br0">(</span>T a<span class="br0">)</span>
<span class="br0">{</span>
    <span class="br0">{</span> <a href="../utility/hash.html"><span class="kw1132">std::<span class="me2">hash</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span><span class="br0">(</span>a<span class="br0">)</span> <span class="br0">}</span> <span class="sy2">-</span><span class="sy1">&gt;</span> <a href="../concepts/convertible_to.html"><span class="kw2953">std::<span class="me2">convertible_to</span></span></a><span class="sy1">&lt;</span><a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="sy1">&gt;</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> meow <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// Constrained C++20 function template:</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>Hashable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="co1">//</span>
<span class="co1">// Alternative ways to apply the same constraint:</span>
<span class="co1">// template&lt;typename T&gt;</span>
<span class="co1">//     requires Hashable&lt;T&gt;</span>
<span class="co1">// void f(T) {}</span>
<span class="co1">//</span>
<span class="co1">// template&lt;typename T&gt;</span>
<span class="co1">// void f(T) requires Hashable&lt;T&gt; {}</span>
<span class="co1">//</span>
<span class="co1">// void f(Hashable auto /* parameter-name */) {}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">using</span> std<span class="sy4">::</span><span class="me2">operator</span><span class="st0">""</span>s<span class="sy4">;</span>
&nbsp;
    f<span class="br0">(</span><span class="st0">"abc"</span>s<span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// OK, std::string satisfies Hashable</span>
    <span class="co1">// f(meow{}); // Error: meow does not satisfy Hashable</span>
<span class="br0">}</span></pre></div></div>
</div>
<p>Violations of constraints are detected at compile time, early in the template instantiation process, which leads to easy to follow error messages:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><a href="../container/list.html"><span class="kw1283">std::<span class="me2">list</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> l <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">3</span>, <span class="sy2">-</span><span class="nu0">1</span>, <span class="nu0">10</span><span class="br0">}</span><span class="sy4">;</span>
<a href="../algorithm/sort.html"><span class="kw1630">std::<span class="me2">sort</span></span></a><span class="br0">(</span>l.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, l.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> 
<span class="co1">// Typical compiler diagnostic without concepts:</span>
<span class="co1">// invalid operands to binary expression ('std::_List_iterator&lt;int&gt;' and</span>
<span class="co1">// 'std::_List_iterator&lt;int&gt;')</span>
<span class="co1">//                           std::__lg(__last - __first) * 2);</span>
<span class="co1">//                                     ~~~~~~ ^ ~~~~~~~</span>
<span class="co1">// ... 50 lines of output ...</span>
<span class="co1">//</span>
<span class="co1">// Typical compiler diagnostic with concepts:</span>
<span class="co1">// error: cannot call std::sort with std::_List_iterator&lt;int&gt;</span>
<span class="co1">// note:  concept RandomAccessIterator&lt;std::_List_iterator&lt;int&gt;&gt; was not satisfied</span></pre></div></div>
<p>The intent of concepts is to model semantic categories (Number, Range, RegularFunction) rather than syntactic restrictions (HasPlus, Array). According to <a rel="nofollow" class="external text" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#t20-avoid-concepts-without-meaningful-semantics">ISO C++ core guideline T.20</a>, "The ability to specify meaningful semantics is a defining characteristic of a true concept, as opposed to a syntactic constraint."
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Concepts"><span class="tocnumber">1</span> <span class="toctext">Concepts</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Constraints"><span class="tocnumber">2</span> <span class="toctext">Constraints</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Redeclarations"><span class="tocnumber">2.1</span> <span class="toctext">Redeclarations</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Conjunctions"><span class="tocnumber">2.2</span> <span class="toctext">Conjunctions</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Disjunctions"><span class="tocnumber">2.3</span> <span class="toctext">Disjunctions</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="#Atomic_constraints"><span class="tocnumber">2.4</span> <span class="toctext">Atomic constraints</span></a></li>
<li class="toclevel-2"><a href="#Fold_expanded_constraints"><span class="tocnumber">2.5</span> <span class="toctext">Fold expanded constraints</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Constraint_normalization"><span class="tocnumber">2.6</span> <span class="toctext">Constraint normalization</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#requires_clauses"><span class="tocnumber">3</span> <span class="toctext"><span>requires</span> clauses</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Partial_ordering_of_constraints"><span class="tocnumber">4</span> <span class="toctext">Partial ordering of constraints</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Notes"><span class="tocnumber">5</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Keywords"><span class="tocnumber">6</span> <span class="toctext">Keywords</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Defect_reports"><span class="tocnumber">7</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#See_also"><span class="tocnumber">8</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=1" title="Edit section: Concepts">edit</a>]</span> <span class="mw-headline" id="Concepts">Concepts</span></h3>
<p>A concept is a named set of <a href="requires.html" title="cpp/language/requires">requirements</a>. The definition of a concept must appear at namespace scope.
</p><p>The definition of a concept has the form
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td class="t-sdsc-nopad"> <code><b>template &lt;</b></code> <span class="t-spar">template-parameter-list</span> <code><b>&gt;</b></code>
<p><code><b>concept</b></code> <span class="t-spar">concept-name attr</span> ﻿<span class="t-mark">(optional)</span> <code><b>=</b></code> <span class="t-spar">constraint-expression</span><code><b>;</b></code>
</p>
</td>
<td class="t-sdsc-nopad">
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<table class="t-par-begin">


<tbody><tr class="t-par">
<td> <span class="t-spar">attr</span>
</td>
<td> -
</td>
<td> sequence of any number of <a href="attributes.html" title="cpp/language/attributes">attributes</a>
</td></tr></tbody></table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// concept</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span>
concept Derived <span class="sy1">=</span> <a href="../types/is_base_of.html"><span class="kw593">std::<span class="me2">is_base_of</span></span></a><span class="sy1">&lt;</span>U, T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span></pre></div></div>
<p>Concepts cannot recursively refer to themselves and cannot be constrained:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept V <span class="sy1">=</span> V<span class="sy1">&lt;</span>T<span class="sy2">*</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// error: recursive concept</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept C1 <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>C1 T<span class="sy1">&gt;</span>
concept Error1 <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="co1">// Error: C1 T attempts to constrain a concept definition</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> requires C1<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span>
concept Error2 <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="co1">// Error: the requires clause attempts to constrain a concept</span></pre></div></div>
<p>Explicit instantiations, explicit specializations, or partial specializations of concepts are not allowed (the meaning of the original definition of a constraint cannot be changed).
</p><p>Concepts can be named in an id-expression. The value of the id-expression is <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span> if the constraint expression is satisfied, and <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span> otherwise.
</p><p>Concepts can also be named in a type-constraint, as part of
</p>
<ul><li> <a href="template_parameters.html#Type_template_parameter" title="cpp/language/template parameters">type template parameter declaration</a>,
</li><li> <a href="auto.html" title="cpp/language/auto">placeholder type specifier</a>,
</li><li> <a href="requires.html#Compound_Requirements" title="cpp/language/requires">compound requirement</a>.
</li></ul>
<p>In a <span class="t-spar">type-constraint</span>, a concept takes one less template argument than its parameter list demands, because the contextually deduced type is implicitly used as the first argument of the concept.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span>
concept Derived <span class="sy1">=</span> <a href="../types/is_base_of.html"><span class="kw593">std::<span class="me2">is_base_of</span></span></a><span class="sy1">&lt;</span>U, T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Derived<span class="sy1">&lt;</span>Base<span class="sy1">&gt;</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// T is constrained by Derived&lt;T, Base&gt;</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=2" title="Edit section: Constraints">edit</a>]</span> <span class="mw-headline" id="Constraints">Constraints</span></h3>
<p>A constraint is a sequence of logical operations and operands that specifies requirements on template arguments. They can appear within <a href="requires.html" title="cpp/language/requires"><span class="mw-geshi cpp source-cpp">requires</span> expressions</a> or directly as bodies of concepts.
</p><p>There are <span class="t-rev-inl t-until-cxx26"><span>three</span><span><span class="t-mark-rev t-until-cxx26">(until C++26)</span></span></span><span class="t-rev-inl t-since-cxx26"><span>four</span><span><span class="t-mark-rev t-since-cxx26">(since C++26)</span></span></span> types of constraints:
</p>
<div class="t-li1"><span class="t-li">1)</span> conjunctions</div>
<div class="t-li1"><span class="t-li">2)</span> disjunctions</div>
<div class="t-li1"><span class="t-li">3)</span> atomic constraints</div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx26"><td>
<div class="t-li1"><span class="t-li">4)</span> fold expanded constraints</div>
</td>
<td><span class="t-mark-rev t-since-cxx26">(since C++26)</span></td></tr>
</tbody></table>
<p>The constraint associated with a declaration is determined by <a href="#Constraint_normalization">normalizing</a> a logical AND expression whose operands are in the following order:
</p>
<ol><li> the constraint expression introduced for each constrained <a href="template_parameters.html#Type_template_parameter" title="cpp/language/template parameters">type template parameter</a> or non-type template parameter declared with a constrained <a href="auto.html" title="cpp/language/auto">placeholder type</a>, in order of appearance;
</li><li> the constraint expression in the <a href="constraints.html#Requires_clauses" title="cpp/language/constraints"><span class="mw-geshi cpp source-cpp">requires</span> clause</a> after the template parameter list;
</li><li> the constraint expression introduced for each parameter with constrained <a href="auto.html" title="cpp/language/auto">placeholder type</a> in an <a href="function_template.html#Abbreviated_function_template" title="cpp/language/function template">abbreviated function template</a> declaration;
</li><li> the constraint expression in the trailing <a href="constraints.html#Requires_clauses" title="cpp/language/constraints"><span class="mw-geshi cpp source-cpp">requires</span> clause</a>.
</li></ol>
<p>This order determines the order in which constraints are instantiated when checking for satisfaction.
</p>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=3" title="Edit section: Redeclarations">edit</a>]</span> <span class="mw-headline" id="Redeclarations">Redeclarations</span></h4>
<p>A constrained declaration may only be redeclared using the same syntactic form. No diagnostic is required:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// These first two declarations of f are fine</span>
<span class="kw1">template</span><span class="sy1">&lt;</span>Incrementable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span> requires Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Incrementable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span> requires Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// OK, redeclaration</span>
&nbsp;
<span class="co1">// Inclusion of this third, logically-equivalent-but-syntactically-different</span>
<span class="co1">// declaration of f is ill-formed, no diagnostic required</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
    requires Incrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// The following two declarations have different constraints:</span>
<span class="co1">// the first declaration has Incrementable&lt;T&gt; &amp;&amp; Decrementable&lt;T&gt;</span>
<span class="co1">// the second declaration has Decrementable&lt;T&gt; &amp;&amp; Incrementable&lt;T&gt;</span>
<span class="co1">// Even though they are logically equivalent.</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Incrementable T<span class="sy1">&gt;</span> 
<span class="kw4">void</span> g<span class="br0">(</span>T<span class="br0">)</span> requires Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Decrementable T<span class="sy1">&gt;</span> 
<span class="kw4">void</span> g<span class="br0">(</span>T<span class="br0">)</span> requires Incrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// ill-formed, no diagnostic required</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=4" title="Edit section: Conjunctions">edit</a>]</span> <span class="mw-headline" id="Conjunctions">Conjunctions</span></h4>
<p>The conjunction of two constraints is formed by using the <code>&amp;&amp;</code> operator in the constraint expression:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept Integral <span class="sy1">=</span> <a href="../types/is_integral.html"><span class="kw463">std::<span class="me2">is_integral</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept SignedIntegral <span class="sy1">=</span> Integral<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> <a href="../types/is_signed.html"><span class="kw523">std::<span class="me2">is_signed</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept UnsignedIntegral <span class="sy1">=</span> Integral<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> <span class="sy3">!</span>SignedIntegral<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span></pre></div></div>
<p>A conjunction of two constraints is satisfied only if both constraints are satisfied. Conjunctions are evaluated left to right and short-circuited (if the left constraint is not satisfied, template argument substitution into the right constraint is not attempted: this prevents failures due to substitution outside of immediate context).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">constexpr</span> <span class="kw4">bool</span> get_value<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> T<span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
    requires <span class="br0">(</span>sizeof<span class="br0">(</span>T<span class="br0">)</span> <span class="sy1">&gt;</span> <span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> get_value<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// #1</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #2</span>
&nbsp;
<span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    f<span class="br0">(</span><span class="st0">'A'</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, calls #2. When checking the constraints of #1,</span>
            <span class="co1">// 'sizeof(char) &gt; 1' is not satisfied, so get_value&lt;T&gt;() is not checked</span>
<span class="br0">}</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=5" title="Edit section: Disjunctions">edit</a>]</span> <span class="mw-headline" id="Disjunctions">Disjunctions</span></h4>
<p>The disjunction of two constraints is formed by using the <code>||</code> operator in the constraint expression.
</p><p>A disjunction of two constraints is satisfied if either constraint is satisfied. Disjunctions are evaluated left to right and short-circuited (if the left constraint is satisfied, template argument substitution into the right constraint is not attempted). 
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T <span class="sy1">=</span> <span class="kw4">void</span><span class="sy1">&gt;</span>
    requires EqualityComparable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">||</span> Same<span class="sy1">&lt;</span>T, <span class="kw4">void</span><span class="sy1">&gt;</span>
<span class="kw1">struct</span> equal_to<span class="sy4">;</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=6" title="Edit section: Atomic constraints">edit</a>]</span> <span class="mw-headline" id="Atomic_constraints">Atomic constraints</span></h4>
<p>An atomic constraint consists of an expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> and a mapping from the template parameters that appear within <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> to template arguments involving the template parameters of the constrained entity, called its <i>parameter mapping</i>. 
</p><p>Atomic constraints are formed during <a href="#Constraint_normalization">constraint normalization</a>. <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> is never a logical AND or logical OR expression (those form conjunctions and disjunctions, respectively).
</p><p>Satisfaction of an atomic constraint is checked by substituting the parameter mapping and template arguments into the expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span>. If the substitution results in an invalid type or expression, the constraint is not satisfied. Otherwise, <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span>, after any lvalue-to-rvalue conversion, must be a prvalue constant expression of type <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>, and the constraint is satisfied if and only if it evaluates to <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span>. 
</p><p>The type of <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> after substitution must be exactly <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>. No conversion is permitted:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> S
<span class="br0">{</span>
    <span class="kw4">constexpr</span> operator <span class="kw4">bool</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
    requires <span class="br0">(</span>S<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span><span class="br0">)</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span>   <span class="co1">// #1</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #2</span>
&nbsp;
<span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    f<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error: S&lt;int&gt;{} does not have type bool when checking #1,</span>
          <span class="co1">// even though #2 is a better match</span>
<span class="br0">}</span></pre></div></div>
<p>Two atomic constraints are considered <i>identical</i> if they are formed from the same expression at the source level and their parameter mappings are equivalent.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">constexpr</span> <span class="kw4">bool</span> is_meowable <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">constexpr</span> <span class="kw4">bool</span> is_cat <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept Meowable <span class="sy1">=</span> is_meowable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept BadMeowableCat <span class="sy1">=</span> is_meowable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> is_cat<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
concept GoodMeowableCat <span class="sy1">=</span> Meowable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> is_cat<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Meowable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f1<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #1</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>BadMeowableCat T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f1<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #2</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Meowable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f2<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #3</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>GoodMeowableCat T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f2<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #4</span>
&nbsp;
<span class="kw4">void</span> g<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    f1<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error, ambiguous:</span>
           <span class="co1">// the is_meowable&lt;T&gt; in Meowable and BadMeowableCat forms distinct atomic</span>
           <span class="co1">// constraints that are not identical (and so do not subsume each other)</span>
&nbsp;
    f2<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, calls #4, more constrained than #3</span>
           <span class="co1">// GoodMeowableCat got its is_meowable&lt;T&gt; from Meowable</span>
<span class="br0">}</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx26"><td>
<h4> <span class="mw-headline" id="Fold_expanded_constraints">Fold expanded constraints</span></h4>
<p>A <i>fold expanded constraint</i> is formed from a constraint <code>C</code> and a fold operator (either <code>&amp;&amp;</code> or <code>||</code>). A fold expanded constraint is a <a href="pack.html" title="cpp/language/parameter pack" class="mw-redirect">pack expansion</a>.
</p><p>Let <span class="t-c"><span class="mw-geshi cpp source-cpp">N</span></span> be the number of elements in the pack expansion parameters:
</p>
<ul><li> If the pack expansion is invalid (such as expanding packs of different size), the fold expanded constraint is not satisfied.
</li><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">N</span></span> is <span class="t-c"><span class="mw-geshi cpp source-cpp">​<span class="nu0">0</span>​</span></span>, the fold expanded constraint is satisfied if the fold operator is <code>&amp;&amp;</code>, or not satisfied if the fold operator is <code>||</code>.
</li><li> For a fold expanded constraint with a positive <span class="t-c"><span class="mw-geshi cpp source-cpp">N</span></span>,for each <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span> in <span style="display: inline-block;"><code>[</code><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="nu0">1</span></span></span><code>,&nbsp;</code><span class="t-c"><span class="mw-geshi cpp source-cpp">N</span></span><code>]</code></span>, each pack expansion parameter is replaced with the corresponding <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span>th element in increasing order:
</li></ul>
<dl><dd><ul><li> For fold expanded constraints whose fold operator is <code>&amp;&amp;</code>, if the replacement of the <span class="t-c"><span class="mw-geshi cpp source-cpp">j</span></span>th element violates <code>C</code>, the fold expanded constraint is not satisfied. In this case, no substitution takes place for any <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span> greater than <span class="t-c"><span class="mw-geshi cpp source-cpp">j</span></span>. Otherwise, the fold expanded constraint is satisfied.
</li><li> For fold expanded constraints whose fold operator is <code>||</code>, if the replacement of the <span class="t-c"><span class="mw-geshi cpp source-cpp">j</span></span>th element satisfies <code>C</code>, the fold expanded constraint is satisfied. In this case, no substitution takes place for any <span class="t-c"><span class="mw-geshi cpp source-cpp">i</span></span> greater than <span class="t-c"><span class="mw-geshi cpp source-cpp">j</span></span>. Otherwise, the fold expanded constraint is not satisfied.
</li></ul>
</dd></dl>
<p><br>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> concept A <span class="sy1">=</span> <a href="../types/is_move_constructible.html"><span class="kw546">std::<span class="me2">is_move_constructible_v</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> concept B <span class="sy1">=</span> <a href="../types/is_copy_constructible.html"><span class="kw540">std::<span class="me2">is_copy_constructible_v</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> concept C <span class="sy1">=</span> A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> B<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// in C++23, these two overloads of g() have distinct atomic constraints </span>
<span class="co1">// that are not identical and so do not subsume each other: calls to g() are ambiguous</span>
<span class="co1">// in C++26, the folds are expanded and constraint on overload #2 (both move and copy</span>
<span class="co1">// required), subsumes constraint on overload #1 (just the move is required)</span>
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span>... <span class="me1">T</span><span class="sy1">&gt;</span>
requires <span class="br0">(</span>A<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ...<span class="br0">)</span> <span class="kw4">void</span> g<span class="br0">(</span>T...<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #1</span>
&nbsp;
<span class="kw1">template</span> <span class="sy1">&lt;</span><span class="kw1">class</span>... <span class="me1">T</span><span class="sy1">&gt;</span>
requires <span class="br0">(</span>C<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ...<span class="br0">)</span> <span class="kw4">void</span> g<span class="br0">(</span>T...<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #2</span></pre></div></div>
<p><br>
</p>
</td>
<td><span class="t-mark-rev t-since-cxx26">(since C++26)</span></td></tr>
</tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=8" title="Edit section: Constraint normalization">edit</a>]</span> <span class="mw-headline" id="Constraint_normalization">Constraint normalization</span></h4>
<p><i>Constraint normalization</i> is the process that transforms a constraint expression into a sequence of conjunctions and disjunctions of atomic constraints. The <i>normal form</i> of an expression is defined as follows:
</p>
<ul><li> The normal form of an expression <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>E<span class="br0">)</span></span></span> is the normal form of <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span>.
</li><li> The normal form of an expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E1 <span class="sy3">&amp;&amp;</span> E2</span></span> is the conjunction of the normal forms of <span class="t-c"><span class="mw-geshi cpp source-cpp">E1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span>.
</li><li> The normal form of an expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E1 <span class="sy3">||</span> E2</span></span> is the disjunction of the normal forms of <span class="t-c"><span class="mw-geshi cpp source-cpp">E1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span>.
</li><li> The normal form of an expression <span class="t-c"><span class="mw-geshi cpp source-cpp">C<span class="sy1">&lt;</span>A1, A2, ... , AN<span class="sy1">&gt;</span></span></span>, where <code>C</code> names a concept, is the normal form of the constraint expression of <code>C</code>, after substituting <code>A1</code>, <code>A2</code>, ... , <code>AN</code> for <code>C</code>'s respective template parameters in the parameter mappings of each atomic constraint of <code>C</code>. If any such substitution into the parameter mappings results in an invalid type or expression, the program is ill-formed, no diagnostic required.
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept A <span class="sy1">=</span> T<span class="sy4">::</span><span class="me2">value</span> <span class="sy3">||</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> U<span class="sy1">&gt;</span>
concept B <span class="sy1">=</span> A<span class="sy1">&lt;</span>U<span class="sy2">*</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// OK: normalized to the disjunction of </span>
                   <span class="co1">// - T::value (with mapping T -&gt; U*) and</span>
                   <span class="co1">// - true (with an empty mapping).</span>
                   <span class="co1">// No invalid type in mapping even though</span>
                   <span class="co1">// T::value is ill-formed for all pointer types</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> V<span class="sy1">&gt;</span>
concept C <span class="sy1">=</span> B<span class="sy1">&lt;</span>V<span class="sy3">&amp;</span><span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// Normalizes to the disjunction of</span>
                   <span class="co1">// - T::value (with mapping T-&gt; V&amp;*) and</span>
                   <span class="co1">// - true (with an empty mapping).</span>
                   <span class="co1">// Invalid type V&amp;* formed in mapping =&gt; ill-formed NDR</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx26"><td>
<ul><li> The normal form of expressions <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>E <span class="sy3">&amp;&amp;</span> ...<span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>... <span class="sy3">&amp;&amp;</span> E<span class="br0">)</span></span></span> is a fold expanded constraint, where <code>C</code> is the normal form of <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> and the fold operator is <code>&amp;&amp;</code>.
</li><li> The normal form of expressions <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>E <span class="sy3">||</span> ...<span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>... <span class="sy3">||</span> E<span class="br0">)</span></span></span> is a fold expanded constraint, where <code>C</code> is the normal form of <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> and the fold operator is <code>||</code>.
</li><li> The normal forms of expressions <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>E1 <span class="sy3">&amp;&amp;</span> ... <span class="sy3">&amp;&amp;</span> E2<span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>E1 <span class="sy3">||</span> ... <span class="sy3">||</span> E2<span class="br0">)</span></span></span> are the normal forms of
</li></ul>
<dl><dd><ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>E1 <span class="sy3">&amp;&amp;</span> ...<span class="br0">)</span> <span class="sy3">&amp;&amp;</span> E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span>E1 <span class="sy3">||</span> ...<span class="br0">)</span> <span class="sy3">||</span> E2</span></span> respectively, if <span class="t-c"><span class="mw-geshi cpp source-cpp">E1</span></span> contains an unexpanded pack, or
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">E1 <span class="sy3">&amp;&amp;</span> <span class="br0">(</span>... <span class="sy3">&amp;&amp;</span> E2<span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E1 <span class="sy3">||</span> <span class="br0">(</span>... <span class="sy3">||</span> E2<span class="br0">)</span></span></span> respectively otherwise.
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx26">(since C++26)</span></td></tr>
</tbody></table>
<ul><li> The normal form of any other expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> is the atomic constraint whose expression is <span class="t-c"><span class="mw-geshi cpp source-cpp">E</span></span> and whose parameter mapping is the identity mapping. This includes all <a href="fold.html" title="cpp/language/fold">fold expressions</a>, even those folding over the <code>&amp;&amp;</code> or <code>||</code> operators.
</li></ul>
<p>User-defined overloads of <code>&amp;&amp;</code> or <code>||</code> have no effect on constraint normalization.
</p><p><span id="Requires_clauses"></span>
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=9" title="Edit section: requires clauses">edit</a>]</span> <span class="mw-headline" id="requires_clauses"><span class="mw-geshi cpp source-cpp">requires</span> clauses</span></h3>
<p>The keyword <a href="../keyword/requires.html" title="cpp/keyword/requires"><tt>requires</tt></a> is used to introduce a <i><span class="mw-geshi cpp source-cpp">requires</span> clause</i>, which specifies constraints on template arguments or on a function declaration.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="sy3">&amp;&amp;</span><span class="br0">)</span> requires Eq<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// can appear as the last element of a function declarator</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span> requires Addable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="co1">// or right after a template parameter list</span>
T add<span class="br0">(</span>T a, T b<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a <span class="sy2">+</span> b<span class="sy4">;</span> <span class="br0">}</span></pre></div></div>
<p>In this case, the keyword <span class="mw-geshi cpp source-cpp">requires</span> must be followed by some constant expression (so it's possible to write <span class="t-c"><span class="mw-geshi cpp source-cpp">requires <span class="kw2">true</span></span></span>), but the intent is that a named concept (as in the example above) or a conjunction/disjunction of named concepts or a <a href="requires.html" title="cpp/language/requires">requires expression</a> is used.
</p><p>The expression must have one of the following forms:
</p>
<ul><li> A <a href="expressions.html#Primary_expressions" title="cpp/language/expressions">primary expression</a>, e.g. <span class="t-c"><span class="mw-geshi cpp source-cpp">Swappable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp"><a href="../types/is_integral.html"><span class="kw463">std::<span class="me2">is_integral</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span></span></span>, <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="br0">(</span><a href="../types/is_object.html"><span class="kw494">std::<span class="me2">is_object_v</span></span></a><span class="sy1">&lt;</span>Args<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ...<span class="br0">)</span></span></span>, or any parenthesized expression.
</li><li> A sequence of primary expressions joined with the operator <code>&amp;&amp;</code>.
</li><li> A sequence of aforementioned expressions joined with the operator <code>||</code>.
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">constexpr</span> <span class="kw4">bool</span> is_meowable <span class="sy1">=</span> <span class="kw2">true</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">constexpr</span> <span class="kw4">bool</span> is_purrable<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span> requires is_meowable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">;</span> <span class="co1">// OK</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> g<span class="br0">(</span>T<span class="br0">)</span> requires is_purrable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// error, is_purrable&lt;T&gt;() is not a primary expression</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> h<span class="br0">(</span>T<span class="br0">)</span> requires <span class="br0">(</span>is_purrable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=10" title="Edit section: Partial ordering of constraints">edit</a>]</span> <span class="mw-headline" id="Partial_ordering_of_constraints">Partial ordering of constraints</span></h3>
<p>Before any further analysis, constraints are <a href="#Constraint_normalization">normalized</a> by substituting the body of every named concept and every <a href="requires.html" title="cpp/language/requires">requires expression</a> until what is left is a sequence of conjunctions and disjunctions on atomic constraints.
</p><p>A constraint <code>P</code> is said to <i>subsume</i> constraint <code>Q</code> if it can be proven that <code>P</code> <a href="https://en.wikipedia.org/wiki/Logical_consequence" class="extiw" title="enwiki:Logical consequence">implies</a> <code>Q</code> up to the identity of atomic constraints in P and Q. (Types and expressions are not analyzed for equivalence: <code>N &gt; 0</code> does not subsume <code>N &gt;= 0</code>).
</p><p>Specifically, first <code>P</code> is converted to disjunctive normal form and <code>Q</code> is converted to conjunctive normal form. <code>P</code> subsumes <code>Q</code> if and only if:
</p>
<ul><li> every disjunctive clause in the disjunctive normal form of <code>P</code> subsumes every conjunctive clause in the conjunctive normal form of <code>Q</code>, where
</li><li> a disjunctive clause subsumes a conjunctive clause if and only if there is an atomic constraint <code>U</code> in the disjunctive clause and an atomic constraint <code>V</code> in the conjunctive clause such that <code>U</code> subsumes <code>V</code>; 
</li><li> an atomic constraint <code>A</code> subsumes an atomic constraint <code>B</code> if and only if they are identical using the rules described <a href="#Atomic_constraints">above</a>.
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx26"><td>
<ul><li> A fold expanded constraint <code>A</code> subsumes another fold expanded constraint <code>B</code> if they have the same fold operator, the constraint <code>C</code> of <code>A</code> subsumes that of <code>B</code>, and both <code>C</code> contain an equivalent unexpanded pack.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx26">(since C++26)</span></td></tr>
</tbody></table>
<p>Subsumption relationship defines partial order of constraints, which is used to determine:
</p>
<ul><li> the best viable candidate for a non-template function in <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>
</li><li> the <a href="overloaded_address.html" title="cpp/language/overloaded address">address of a non-template function</a> in an overload set
</li><li> the best match for a template template argument
</li><li> partial ordering of class template specializations
</li><li> <a href="function_template.html#Function_template_overloading" title="cpp/language/function template">partial ordering</a> of function templates
</li></ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: backlinks from the above to here </td></tr></tbody></table>
<p>If declarations <code>D1</code> and <code>D2</code> are constrained and <code>D1</code>'s associated constraints subsume <code>D2</code>'s associated constraints (or if <code>D2</code> is unconstrained), then <code>D1</code> is said to be <i>at least as constrained</i> as <code>D2</code>. If <code>D1</code> is at least as constrained as <code>D2</code>, and <code>D2</code> is not at least as constrained as <code>D1</code>, then <code>D1</code> is <i>more constrained</i> than <code>D2</code>.
</p><p>If all following conditions are satisfied, a non-template function <code>F1</code> is <i>more partial-ordering-constrained</i> than a non-template function <code>F2</code>:
</p>
<ul><li> They have the same parameter-type-list<span class="t-rev-inl t-since-cxx23"><span>, omitting the types of <a href="member_functions.html#Explicit_object_parameter" title="cpp/language/member functions">explicit object parameters</a></span><span><span class="t-mark-rev t-since-cxx23">(since C++23)</span></span></span>.
</li><li> If they are member functions, both are direct members of the same class.
</li><li> If both are non-static member functions, they have the same types for their object parameters.
</li><li> <code>F1</code> is more constrained than <code>F2</code>.
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept Decrementable <span class="sy1">=</span> requires<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="sy2">--</span>t<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept RevIterator <span class="sy1">=</span> Decrementable<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> requires<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="sy2">*</span>t<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// RevIterator subsumes Decrementable, but not the other way around</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Decrementable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #1</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>RevIterator T<span class="sy1">&gt;</span>
<span class="kw4">void</span> f<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #2, more constrained than #1</span>
&nbsp;
f<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>       <span class="co1">// int only satisfies Decrementable, selects #1</span>
f<span class="br0">(</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// int* satisfies both constraints, selects #2 as more constrained</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> g<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #3 (unconstrained)</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Decrementable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> g<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #4</span>
&nbsp;
g<span class="br0">(</span><span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// bool does not satisfy Decrementable, selects #3</span>
g<span class="br0">(</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// int satisfies Decrementable, selects #4 because it is more constrained</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
concept RevIterator2 <span class="sy1">=</span> requires<span class="br0">(</span>T t<span class="br0">)</span> <span class="br0">{</span> <span class="sy2">--</span>t<span class="sy4">;</span> <span class="sy2">*</span>t<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>Decrementable T<span class="sy1">&gt;</span>
<span class="kw4">void</span> h<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #5</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span>RevIterator2 T<span class="sy1">&gt;</span>
<span class="kw4">void</span> h<span class="br0">(</span>T<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #6</span>
&nbsp;
h<span class="br0">(</span><span class="br0">(</span><span class="kw4">int</span><span class="sy2">*</span><span class="br0">)</span><span class="nu0">0</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// ambiguous</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=11" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<table class="wikitable ftm-begin ftm-has-value">

<tbody><tr>
<th>Feature-test macro
</th>
<th><abbr title="The year/month in which the feature was adopted. The hyperlink under each value opens a compiler support page with entry for given feature.">Value</abbr>
</th>
<th><abbr title="Standard in which the feature is introduced; DR means defect report against that revision">Std</abbr>
</th>
<th>Feature
</th></tr>
<tr>
<td rowspan="2"><a href="../feature_test.html#cpp_concepts" title="cpp/feature test"><code>__cpp_concepts</code></a></td>
<td><a href="../compiler_support/20.html#cpp_concepts_201907L" title="cpp/compiler support/20"><code>201907L</code></a></td>
<td><span class="t-mark">(C++20)</span></td>
<td><a href="#top">Constraints</a>
</td></tr>
<tr>
<td><a href="../compiler_support/20.html#cpp_concepts_202002L" title="cpp/compiler support/20"><code>202002L</code></a></td>
<td><span class="t-mark">(C++20)</span></td>
<td>Conditionally trivial <a href="member_functions.html#Special_member_functions" title="cpp/language/member functions">special member functions</a>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=12" title="Edit section: Keywords">edit</a>]</span> <span class="mw-headline" id="Keywords">Keywords</span></h3>
<p><a href="../keyword/concept.html" title="cpp/keyword/concept"><tt>concept</tt></a>,
<a href="../keyword/requires.html" title="cpp/keyword/requires"><tt>requires</tt></a>,
<a href="../keyword/typename.html" title="cpp/keyword/typename"><tt>typename</tt></a>
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=13" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2428.html">CWG 2428</a>
</td>
<td>C++20
</td>
<td>could not apply attributes to concepts
</td>
<td>allowed
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;action=edit&amp;section=14" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<ul><li> <a href="../experimental/constraints.html" title="cpp/experimental/constraints">Concepts TS</a>
</li><li> <a href="../named_req.html" title="cpp/named req">Named requirements</a>
</li></ul>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td> <a href="requires.html" title="cpp/language/requires">Requires expression</a><span class="t-mark-rev t-since-cxx20">(C++20)</span>
</td>
<td> yields a prvalue expression of type <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span> that describes the constraints<span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/language/dsc_requires&amp;action=edit">[edit]</a></span>
</td></tr>
</tbody></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 8009/1000000
Preprocessor generated node count: 18694/1000000
Post‐expand include size: 264250/4194304 bytes
Template argument size: 49287/4194304 bytes
Highest expansion depth: 17/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:17699-0!*!0!!en!*!* and timestamp 20250124075656 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;oldid=179831">https://en.cppreference.com/mwiki/index.php?title=cpp/language/constraints&amp;oldid=179831</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 0.038 secs. -->
	




</body><!-- Cached 20250124075857 --><!-- Mirrored from en.cppreference.com/w/cpp/language/constraints by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:30:59 GMT --></html>