<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/pimpl by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:53 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>PImpl</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_pimpl skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">PImpl</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>"Pointer to implementation" or "pImpl" is a C++ <a href="#External_links">programming technique</a> that removes implementation details of a class from its object representation by placing them in a separate class, accessed through an opaque pointer:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// --------------------</span>
<span class="co1">// interface (widget.h)</span>
<span class="kw1">struct</span> widget
<span class="br0">{</span>
    <span class="co1">// public members</span>
<span class="kw1">private</span><span class="sy4">:</span>
    <span class="kw1">struct</span> impl<span class="sy4">;</span> <span class="co1">// forward declaration of the implementation class</span>
    <span class="co1">// One implementation example: see below for other design options and trade-offs</span>
    <a href="../experimental/propagate_const.html"><span class="kw2442">std::<span class="me2">experimental</span><span class="sy4">::</span><span class="me2">propagate_const</span></span></a><span class="sy1">&lt;</span> <span class="co1">// const-forwarding pointer wrapper</span>
        <a href="../memory/unique_ptr.html"><span class="kw737">std::<span class="me2">unique_ptr</span></span></a><span class="sy1">&lt;</span>                <span class="co1">// unique-ownership opaque pointer</span>
            impl<span class="sy1">&gt;&gt;</span> pImpl<span class="sy4">;</span>               <span class="co1">// to the forward-declared implementation class</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// ---------------------------</span>
<span class="co1">// implementation (widget.cpp)</span>
<span class="kw1">struct</span> widget<span class="sy4">::</span><span class="me2">impl</span>
<span class="br0">{</span>
    <span class="co1">// implementation details</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Explanation"><span class="tocnumber">1</span> <span class="toctext">Explanation</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Trade-offs"><span class="tocnumber">2</span> <span class="toctext">Trade-offs</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Compilation_firewall"><span class="tocnumber">2.1</span> <span class="toctext">Compilation firewall</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Runtime_overhead"><span class="tocnumber">2.2</span> <span class="toctext">Runtime overhead</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Maintenance_overhead"><span class="tocnumber">2.3</span> <span class="toctext">Maintenance overhead</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Implementation"><span class="tocnumber">3</span> <span class="toctext">Implementation</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Notes"><span class="tocnumber">4</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Example"><span class="tocnumber">5</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#External_links"><span class="tocnumber">6</span> <span class="toctext">External links</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=1" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span></h3>
<p>Because private data members of a class participate in its object representation, affecting size and layout, and because private member functions of a class participate in <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a> (which takes place before member access checking), any change to those implementation details requires recompilation of all users of the class.
</p><p>pImpl removes this compilation dependency; changes to the implementation do not cause recompilation. Consequently, if a library uses pImpl in its ABI, newer versions of the library may change the implementation while remaining ABI-compatible with older versions.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=2" title="Edit section: Trade-offs">edit</a>]</span> <span class="mw-headline" id="Trade-offs">Trade-offs</span></h3>
<p>The alternatives to the pImpl idiom are
</p>
<ul><li> inline implementation: private members and public members are members of the same class.
</li><li> pure abstract class (OOP factory): users obtain a unique pointer to a lightweight or abstract base class, the implementation details are in the derived class that overrides its virtual member functions.
</li></ul>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=3" title="Edit section: Compilation firewall">edit</a>]</span> <span class="mw-headline" id="Compilation_firewall">Compilation firewall</span></h4>
<p>In simple cases, both pImpl and factory method remove compile-time dependency between the implementation and the users of the class interface. Factory method creates a hidden dependency on the vtable, and so reordering, adding, or removing virtual member functions breaks the ABI. The pImpl approach has no hidden dependencies, however if the implementation class is a class template specialization, the compilation firewall benefit is lost: the users of the interface must observe the entire template definition in order to instantiate the correct specialization. A common design approach in this case is to refactor the implementation in a way that avoids parametrization, this is another use case for the C++ Core Guidelines:
</p>
<ul><li> <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary">T.61 Do not over-parametrize members</a> and
</li><li> <a rel="nofollow" class="external text" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface">T.84 Use a non-template core implementation to provide an ABI-stable interface</a>.
</li></ul>
<p>For example, the following class template does not use the type <code>T</code> in its private member or in the body of <code>push_back</code>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">class</span> ptr_vector
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1277">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">void</span><span class="sy2">*</span><span class="sy1">&gt;</span> vp<span class="sy4">;</span>
<span class="kw1">public</span><span class="sy4">:</span>
    <span class="kw4">void</span> push_back<span class="br0">(</span>T<span class="sy2">*</span> p<span class="br0">)</span>
    <span class="br0">{</span>
        vp.<span class="me1">push_back</span><span class="br0">(</span>p<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>Therefore, private members can be transferred to implementation as-is, and <code>push_back</code> can forward to an implementation that does not use <code>T</code> in the interface either:
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// ---------------------</span>
<span class="co1">// header (ptr_vector.hpp)</span>
<span class="co2">#include &lt;memory&gt;</span>
&nbsp;
<span class="kw1">class</span> ptr_vector_base
<span class="br0">{</span>
    <span class="kw1">struct</span> impl<span class="sy4">;</span> <span class="co1">// does not depend on T</span>
    <a href="../memory/unique_ptr.html"><span class="kw737">std::<span class="me2">unique_ptr</span></span></a><span class="sy1">&lt;</span>impl<span class="sy1">&gt;</span> pImpl<span class="sy4">;</span>
<span class="kw1">protected</span><span class="sy4">:</span>
    <span class="kw4">void</span> push_back_fwd<span class="br0">(</span><span class="kw4">void</span><span class="sy2">*</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">void</span> print<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span>
    <span class="co1">// ... see implementation section for special member functions</span>
<span class="kw1">public</span><span class="sy4">:</span>
    ptr_vector_base<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    ~ptr_vector_base<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">class</span> ptr_vector <span class="sy4">:</span> <span class="kw1">private</span> ptr_vector_base
<span class="br0">{</span>
<span class="kw1">public</span><span class="sy4">:</span>
    <span class="kw4">void</span> push_back<span class="br0">(</span>T<span class="sy2">*</span> p<span class="br0">)</span> <span class="br0">{</span> push_back_fwd<span class="br0">(</span>p<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
    <span class="kw4">void</span> print<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> ptr_vector_base<span class="sy4">::</span><span class="me2">print</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// -----------------------</span>
<span class="co1">// source (ptr_vector.cpp)</span>
<span class="co1">// #include "ptr_vector.hpp"</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;vector&gt;</span>
&nbsp;
<span class="kw1">struct</span> ptr_vector_base<span class="sy4">::</span><span class="me2">impl</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1277">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><span class="kw4">void</span><span class="sy2">*</span><span class="sy1">&gt;</span> vp<span class="sy4">;</span>
&nbsp;
    <span class="kw4">void</span> push_back<span class="br0">(</span><span class="kw4">void</span><span class="sy2">*</span> p<span class="br0">)</span>
    <span class="br0">{</span>
        vp.<span class="me1">push_back</span><span class="br0">(</span>p<span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw4">void</span> print<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span>
    <span class="br0">{</span>
        <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">void</span> <span class="kw4">const</span> <span class="sy2">*</span> <span class="kw4">const</span> p<span class="sy4">:</span> vp<span class="br0">)</span> <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> p <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> ptr_vector_base<span class="sy4">::</span><span class="me2">push_back_fwd</span><span class="br0">(</span><span class="kw4">void</span><span class="sy2">*</span> p<span class="br0">)</span> <span class="br0">{</span> pImpl<span class="sy2">-</span><span class="sy1">&gt;</span>push_back<span class="br0">(</span>p<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
ptr_vector_base<span class="sy4">::</span><span class="me2">ptr_vector_base</span><span class="br0">(</span><span class="br0">)</span> <span class="sy4">:</span> pImpl<span class="br0">{</span><a href="../memory/unique_ptr/make_unique.html"><span class="kw739">std::<span class="me2">make_unique</span></span></a><span class="sy1">&lt;</span>impl<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="br0">}</span> <span class="br0">{</span><span class="br0">}</span>
ptr_vector_base<span class="sy4">::</span>~ptr_vector_base<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="kw4">void</span> ptr_vector_base<span class="sy4">::</span><span class="me2">print</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> pImpl<span class="sy2">-</span><span class="sy1">&gt;</span>print<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="co1">// ---------------</span>
<span class="co1">// user (main.cpp)</span>
<span class="co1">// #include "ptr_vector.hpp"</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> x<span class="br0">{</span><span class="br0">}</span>, y<span class="br0">{</span><span class="br0">}</span>, z<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
    ptr_vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> v<span class="sy4">;</span>
    v.<span class="me1">push_back</span><span class="br0">(</span><span class="sy3">&amp;</span>x<span class="br0">)</span><span class="sy4">;</span>
    v.<span class="me1">push_back</span><span class="br0">(</span><span class="sy3">&amp;</span>y<span class="br0">)</span><span class="sy4">;</span>
    v.<span class="me1">push_back</span><span class="br0">(</span><span class="sy3">&amp;</span>z<span class="br0">)</span><span class="sy4">;</span>
    v.<span class="me1">print</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Possible output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">0x7ffd6200a42c
0x7ffd6200a430
0x7ffd6200a434</pre></div></div> 
</div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=4" title="Edit section: Runtime overhead">edit</a>]</span> <span class="mw-headline" id="Runtime_overhead">Runtime overhead</span></h4>
<ul><li> Access overhead: In pImpl, each call to a private member function indirects through a pointer. Each access to a public member made by a private member indirects through another pointer. Both indirections cross translation unit boundaries and so can only be optimized out by link-time optimization. Note that OO factory requires indirection across translation units to access both public data and implementation detail, and offers even fewer opportunities for the link time optimizer due to virtual dispatch.
</li><li> Space overhead: pImpl adds one pointer to the public component and, if any private member needs access to a public member, another pointer is either added to the implementation component or passed as a parameter for each call to the private member that requires it. If stateful custom allocators are supported, the allocator instance also has to be stored.
</li><li> Lifetime management overhead: pImpl (as well as OO factory) place the implementation object on the heap, which imposes significant runtime overhead at construction and destruction. This may be partially offset by custom allocators, since allocation size for pImpl (but not OO factory) is known at compile time.
</li></ul>
<p>On the other hand, pImpl classes are move-friendly; refactoring a large class as movable pImpl may improve performance of algorithms that manipulate containers holding such objects, although movable pImpl has an additional source of runtime overhead: any public member function that is permitted on a moved-from object and needs access to private implementation incurs a null pointer check.
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: Microbenchmark?) </td></tr></tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=5" title="Edit section: Maintenance overhead">edit</a>]</span> <span class="mw-headline" id="Maintenance_overhead">Maintenance overhead</span></h4>
<p>Use of pImpl requires a dedicated translation unit (a header-only library cannot use pImpl), introduces an additional class, a set of forwarding functions, and, if allocators are used, exposes the implementation detail of allocator use in the public interface.
</p><p>Since virtual members are part of the interface component of pImpl, mocking a pImpl implies mocking the interface component alone. A testable pImpl is typically designed to allow full test coverage through the available interface.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=6" title="Edit section: Implementation">edit</a>]</span> <span class="mw-headline" id="Implementation">Implementation</span></h3>
<p>As the object of the interface type controls the lifetime of the object of the implementation type, the pointer to implementation is usually <span class="t-lc"><a href="../memory/unique_ptr.html" title="cpp/memory/unique ptr">std::unique_ptr</a></span>.
</p><p>Because <span class="t-lc"><a href="../memory/unique_ptr.html" title="cpp/memory/unique ptr">std::unique_ptr</a></span> requires that the pointed-to type is a complete type in any context where the deleter is instantiated, the special member functions must be user-declared and defined out-of-line, in the implementation file, where the implementation class is complete.
</p><p>Because when const member function calls a function through a non-const member pointer, the non-const overload of the implementation function is called, the pointer has to be wrapped in <span class="t-lc"><a href="../experimental/propagate_const.html" title="cpp/experimental/propagate const">std::experimental::propagate_const</a></span> or equivalent.
</p><p>All private data members and all private non-virtual member functions are placed in the implementation class. All public, protected, and virtual members remain in the interface class (see <a rel="nofollow" class="external text" href="https://herbsutter.com/gotw/_100/">GOTW #100</a> for the discussion of the alternatives).
</p><p>If any of the private members needs to access a public or protected member, a reference or pointer to the interface may be passed to the private function as a parameter. Alternatively, the back-reference may be maintained as part of the implementation class.
</p><p>If non-default allocators are intended to be supported for the allocation of the implementation object, any of the usual allocator awareness patterns may be utilized, including allocator template parameter defaulting to <span class="t-lc"><a href="../memory/allocator.html" title="cpp/memory/allocator">std::allocator</a></span> and constructor argument of type <a href="../memory/memory_resource.html" title="cpp/memory/memory resource"><tt>std::pmr::memory_resource*</tt></a>.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=7" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: note connection to value-semantic polymorphism </td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=8" title="Edit section: Example">edit</a>]</span> <span class="mw-headline" id="Example">Example</span></h3>
<div class="t-example"><p>Demonstrates a pImpl with const propagation, with back-reference passed as a parameter, without allocator awareness, and move-enabled without runtime checks:</p><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// ----------------------</span>
<span class="co1">// interface (widget.hpp)</span>
<span class="co2">#include &lt;experimental/propagate_const&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;memory&gt;</span>
&nbsp;
<span class="kw1">class</span> widget
<span class="br0">{</span>
    <span class="kw1">class</span> impl<span class="sy4">;</span>
    <a href="../experimental/propagate_const.html"><span class="kw2442">std::<span class="me2">experimental</span><span class="sy4">::</span><span class="me2">propagate_const</span></span></a><span class="sy1">&lt;</span><a href="../memory/unique_ptr.html"><span class="kw737">std::<span class="me2">unique_ptr</span></span></a><span class="sy1">&lt;</span>impl<span class="sy1">&gt;&gt;</span> pImpl<span class="sy4">;</span>
<span class="kw1">public</span><span class="sy4">:</span>
    <span class="kw4">void</span> draw<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span><span class="sy4">;</span> <span class="co1">// public API that will be forwarded to the implementation</span>
    <span class="kw4">void</span> draw<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">bool</span> shown<span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw2">true</span><span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// public API that implementation has to call</span>
&nbsp;
    widget<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// even the default ctor needs to be defined in the implementation file</span>
              <span class="co1">// Note: calling draw() on default constructed object is UB</span>
    <span class="kw1">explicit</span> widget<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
    ~widget<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// defined in the implementation file, where impl is a complete type</span>
    widget<span class="br0">(</span>widget<span class="sy3">&amp;&amp;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// defined in the implementation file</span>
                      <span class="co1">// Note: calling draw() on moved-from object is UB</span>
    widget<span class="br0">(</span><span class="kw4">const</span> widget<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> delete<span class="sy4">;</span>
    widget<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>widget<span class="sy3">&amp;&amp;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// defined in the implementation file</span>
    widget<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> widget<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> delete<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// ---------------------------</span>
<span class="co1">// implementation (widget.cpp)</span>
<span class="co1">// #include "widget.hpp"</span>
&nbsp;
<span class="kw1">class</span> widget<span class="sy4">::</span><span class="me2">impl</span>
<span class="br0">{</span>
    <span class="kw4">int</span> n<span class="sy4">;</span> <span class="co1">// private data</span>
<span class="kw1">public</span><span class="sy4">:</span>
    <span class="kw4">void</span> draw<span class="br0">(</span><span class="kw4">const</span> widget<span class="sy3">&amp;</span> w<span class="br0">)</span> <span class="kw4">const</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>w.<span class="me1">shown</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="co1">// this call to public member function requires the back-reference </span>
            <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"drawing a const widget "</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw4">void</span> draw<span class="br0">(</span><span class="kw4">const</span> widget<span class="sy3">&amp;</span> w<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>w.<span class="me1">shown</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span>
            <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"drawing a non-const widget "</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="br0">}</span>
&nbsp;
    impl<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="sy4">:</span> n<span class="br0">(</span>n<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> widget<span class="sy4">::</span><span class="me2">draw</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="br0">{</span> pImpl<span class="sy2">-</span><span class="sy1">&gt;</span>draw<span class="br0">(</span><span class="sy2">*</span>this<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="kw4">void</span> widget<span class="sy4">::</span><span class="me2">draw</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> pImpl<span class="sy2">-</span><span class="sy1">&gt;</span>draw<span class="br0">(</span><span class="sy2">*</span>this<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span>
widget<span class="sy4">::</span><span class="me2">widget</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
widget<span class="sy4">::</span><span class="me2">widget</span><span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="sy4">:</span> pImpl<span class="br0">{</span><a href="../memory/unique_ptr/make_unique.html"><span class="kw739">std::<span class="me2">make_unique</span></span></a><span class="sy1">&lt;</span>impl<span class="sy1">&gt;</span><span class="br0">(</span>n<span class="br0">)</span><span class="br0">}</span> <span class="br0">{</span><span class="br0">}</span>
widget<span class="sy4">::</span><span class="me2">widget</span><span class="br0">(</span>widget<span class="sy3">&amp;&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
widget<span class="sy4">::</span>~widget<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
widget<span class="sy3">&amp;</span> widget<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span>widget<span class="sy3">&amp;&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// ---------------</span>
<span class="co1">// user (main.cpp)</span>
<span class="co1">// #include "widget.hpp"</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    widget w<span class="br0">(</span><span class="nu0">7</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">const</span> widget w2<span class="br0">(</span><span class="nu0">8</span><span class="br0">)</span><span class="sy4">;</span>
    w.<span class="me1">draw</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    w2.<span class="me1">draw</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">drawing a non-const widget 7
drawing a const widget 8</pre></div></div> 
</div>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: describe yet another alternative — "fast PImpl". The main difference is that the memory for the implementation is reserved in a data member that is an opaque C-array (inside the PImpl class definition), while in cpp file that memory is mapped (via <code>reinterpret_cast</code> or placement-<code>new</code>) to the implementation structure. This approach has it's own pros and cons, in particular, an obvious <i>pro</i> is no extra allocation, on condition that enough memory was initially reserved at <i>design-time</i> of the PImpl class. (Whereas among <i>cons</i> is reduced move-friendliness.) </td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;action=edit&amp;section=9" title="Edit section: External links">edit</a>]</span> <span class="mw-headline" id="External_links">External links</span></h3>
<table style="border-top:solid 1px;border-bottom:none;border-left:none;border-right:none;">

<tbody><tr style="vertical-align:top;">
<td>1.&nbsp;</td>
<td><a rel="nofollow" class="external text" href="http://www.gotw.ca/gotw/028.htm">GotW #28</a>&nbsp;: The Fast Pimpl Idiom.
</td></tr>
<tr style="vertical-align:top;">
<td>2.&nbsp;</td>
<td><a rel="nofollow" class="external text" href="https://herbsutter.com/gotw/_100/">GotW #100</a>: Compilation Firewalls.
</td></tr>
<tr style="vertical-align:top;">
<td>3.&nbsp;</td>
<td><a rel="nofollow" class="external text" href="https://www.cppstories.com/2018/01/pimpl/">The Pimpl Pattern - what you should know.</a>
</td></tr></tbody></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 3107/1000000
Preprocessor generated node count: 8605/1000000
Post‐expand include size: 124301/4194304 bytes
Template argument size: 26004/4194304 bytes
Highest expansion depth: 17/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:14656-0!*!0!!en!*!* and timestamp 20250103104113 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;oldid=178591">https://en.cppreference.com/mwiki/index.php?title=cpp/language/pimpl&amp;oldid=178591</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 3.283 secs. -->
	




</body><!-- Cached 20250103104113 --><!-- Mirrored from en.cppreference.com/w/cpp/language/pimpl by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:53 GMT --></html>