<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/lifetime by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:37 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>Lifetime</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_lifetime skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">Lifetime</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>Every <a href="object.html" title="cpp/language/object">object</a> and <a href="reference.html" title="cpp/language/reference">reference</a> has a <i>lifetime</i>, which is a runtime property: for any object or reference, there is a point of execution of a program when its lifetime begins, and there is a moment when it ends.
</p><p>The lifetime of an object begins when: 
</p>
<ul><li> storage with the proper alignment and size for its type is obtained, and
</li><li> its initialization (if any) is complete (including <a href="default_initialization.html" title="cpp/language/default initialization">default initialization</a> via no constructor or <a href="default_constructor.html#Trivial_default_constructor" title="cpp/language/default constructor">trivial default constructor</a>), except that
</li></ul>
<dl><dd><ul><li> if the object is a <a href="union.html#Member_lifetime" title="cpp/language/union">union member</a> or subobject thereof, its lifetime only begins if that union member is the initialized member in the union, or it is made active,
</li><li> if the object is nested in a union object, its lifetime may begin if the containing union object is assigned or constructed by a trivial special member function,
</li><li> an array object's lifetime may also begin if it is allocated by <span class="t-lc"><a href="../memory/allocator/allocate.html" title="cpp/memory/allocator/allocate">std::allocator::allocate</a></span>.
</li></ul>
</dd></dl>
<p>Some operations <a href="object.html#Object_creation" title="cpp/language/object">implicitly create objects</a> of <a href="../named_req/ImplicitLifetimeType.html" title="cpp/named req/ImplicitLifetimeType">implicit-lifetime types</a> in given region of storage and start their lifetime. If a subobject of an implicitly created object is not of an implicit-lifetime type, its lifetime does not begin implicitly.
</p><p>The lifetime of an object ends when: 
</p>
<ul><li> if it is of a non-class type, the object is destroyed (maybe via a pseudo-destructor call), or
</li><li> if it is of a class type, the <a href="destructor.html" title="cpp/language/destructor">destructor</a> call starts, or
</li><li> the storage which the object occupies is released, or is <a href="#Storage_reuse">reused</a> by an object that is not nested within it.
</li></ul>
<p>Lifetime of an object is equal to or is nested within the lifetime of its storage, see <a href="storage_duration.html" title="cpp/language/storage duration">storage duration</a>.
</p><p>The lifetime of a <a href="reference.html" title="cpp/language/reference">reference</a> begins when its initialization is complete and ends as if it were a scalar object.
</p><p>Note: the lifetime of the referred object may end before the end of the lifetime of the reference, which makes <a href="reference.html#Dangling_references" title="cpp/language/reference">dangling references</a> possible.
</p><p>Lifetimes of non-static data members and base subobjects begin and end following <a href="constructor.html#Initialization_order" title="cpp/language/initializer list" class="mw-redirect">class initialization order</a>.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Temporary_object_lifetime"><span class="tocnumber">1</span> <span class="toctext">Temporary object lifetime</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Storage_reuse"><span class="tocnumber">2</span> <span class="toctext">Storage reuse</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Providing_storage"><span class="tocnumber">2.1</span> <span class="toctext">Providing storage</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#Access_outside_of_lifetime"><span class="tocnumber">3</span> <span class="toctext">Access outside of lifetime</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Notes"><span class="tocnumber">4</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Defect_reports"><span class="tocnumber">5</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#References"><span class="tocnumber">6</span> <span class="toctext">References</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#See_also"><span class="tocnumber">7</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=1" title="Edit section: Temporary object lifetime">edit</a>]</span> <span class="mw-headline" id="Temporary_object_lifetime">Temporary object lifetime</span></h3>
<p>Temporary objects are created <span class="t-rev-inl t-since-cxx17"><span>when a prvalue is <a href="implicit_conversion.html#Temporary_materialization" title="cpp/language/implicit conversion">materialized</a> so that it can be used as a glvalue, which occurs</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> in the following situations:
</p>
<ul><li> <a href="reference_initialization.html" title="cpp/language/reference initialization">binding a reference to a prvalue</a>
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<ul><li> <a href="list_initialization.html" title="cpp/language/list initialization">initializing</a> an object of type <span class="mw-geshi cpp source-cpp"><a href="../utility/initializer_list.html"><span class="kw964">std::<span class="me2">initializer_list</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span></span> from a <a href="initialization.html" title="cpp/language/initialization">brace-enclosed initializer list</a>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx17"><td>
<ul><li> returning a prvalue from a function
</li><li> <a href="expressions.html#Conversions" title="cpp/language/expressions">conversion</a> that creates a prvalue (<a href="explicit_cast.html" title="cpp/language/explicit cast">including</a> <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="br0">(</span>a, b, c<span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="br0">{</span><span class="br0">}</span></span></span>)
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<ul><li> <a href="lambda.html" title="cpp/language/lambda">lambda expression</a>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<ul><li> <a href="copy_initialization.html" title="cpp/language/copy initialization">copy-initialization</a> that requires conversion of the initializer,
</li><li> <a href="reference_initialization.html" title="cpp/language/reference initialization">reference-initialization</a> to a different but convertible type or to a bitfield.
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td></tr>
<tr class="t-rev t-since-cxx17"><td>
<ul><li> when performing <a href="operator_member_access.html#Built-in_member_access_operators" title="cpp/language/operator member access">member access</a> on a class prvalue
</li><li> when performing an <a href="array.html#Array-to-pointer_decay" title="cpp/language/array">array-to-pointer</a> conversion or <a href="operator_member_access.html#Built-in_subscript_operator" title="cpp/language/operator member access">subscripting</a> on an array prvalue
</li><li> for unevaluated operands in <a href="sizeof.html" title="cpp/language/sizeof"><code>sizeof</code></a> and <a href="typeid.html" title="cpp/language/typeid"><code>typeid</code></a>
</li><li> when a prvalue appears as a <a href="expressions.html#Discarded-value_expressions" title="cpp/language/expressions">discarded-value expression</a>
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<p>Also, temporary objects are created:
</p>
<ul><li> if supported by the implementation, when passing or returning an object of trivially-copyable type in a <a href="operator_other.html#Built-in_function_call_operator" title="cpp/language/operator other">function call expression</a> (this allows passing structs in CPU registers)
</li></ul>
<p>The materialization of a temporary object is generally delayed as long as possible in order to avoid creating unnecessary temporary object: see <a href="copy_elision.html" title="cpp/language/copy elision">copy elision</a>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<p>All temporary objects are destroyed as the last step in evaluating the <a href="expressions.html#Full-expressions" title="cpp/language/expressions">full-expression</a> that (lexically) contains the point where they were created, and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation. This is true even if that evaluation ends in throwing an exception.
</p><p>There are the following exceptions from that:
</p>
<ul><li> The lifetime of a temporary object may be extended by binding to a reference, see <a href="reference_initialization.html#Lifetime_of_a_temporary" title="cpp/language/reference initialization">reference initialization</a> for details.
</li><li> The lifetime of a temporary object created when evaluating the default arguments of a default or copy constructor used to initialize or copy an element of an array ends before the next element of the array begins initialization.
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<ul><li> The lifetime of a temporary object created in a <a href="structured_binding.html" title="cpp/language/structured binding">structured binding</a> declaration (introduced by the initializer for a variable with unique name) is extended to the end of the structured binding declaration.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
<tr class="t-rev t-since-cxx23"><td>
<ul><li> The lifetime of a temporary object created in the <span class="t-spar">range-initializer</span> of a <a href="range-for.html" title="cpp/language/range-for">range-<span class="mw-geshi cpp source-cpp"><span class="kw1">for</span></span></a> statement that would otherwise be destroyed at the end of the <span class="t-spar">range-initializer</span> is extended to the end of the loop body.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=2" title="Edit section: Storage reuse">edit</a>]</span> <span class="mw-headline" id="Storage_reuse">Storage reuse</span></h3>
<p>A program is not required to call the destructor of an object to end its lifetime if the object is <a href="destructor.html#Trivial_destructor" title="cpp/language/destructor">trivially-destructible</a> (be careful that the correct behavior of the program may depend on the destructor). However, if a program ends the lifetime of a non-trivially destructible object that is a variable explicitly, it must ensure that a new object of the same type is constructed in-place (e.g. via placement <span class="mw-geshi cpp source-cpp">new</span>) before the destructor may be called implicitly, i.e. due to scope exit or exception for automatic objects<span class="t-rev-inl t-since-cxx11"><span>, due to thread exit for thread-local objects,</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> or due to program exit for static objects; otherwise the behavior is undefined.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">class</span> T <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// trivial</span>
&nbsp;
<span class="kw1">struct</span> B
<span class="br0">{</span>
    ~B<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// non-trivial</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> x<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">long</span> <span class="kw4">long</span> n<span class="sy4">;</span> <span class="co1">// automatic, trivial</span>
    new <span class="br0">(</span><span class="sy3">&amp;</span>n<span class="br0">)</span> <span class="kw4">double</span><span class="br0">(</span><span class="nu16">3.14</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// reuse with a different type okay</span>
<span class="br0">}</span> <span class="co1">// okay</span>
&nbsp;
<span class="kw4">void</span> h<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    B b<span class="sy4">;</span> <span class="co1">// automatic non-trivially destructible</span>
    b.~B<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// end lifetime (not required, since no side-effects)</span>
    new <span class="br0">(</span><span class="sy3">&amp;</span>b<span class="br0">)</span> T<span class="sy4">;</span> <span class="co1">// wrong type: okay until the destructor is called</span>
<span class="br0">}</span> <span class="co1">// destructor is called: undefined behavior</span></pre></div></div>
<p>It is undefined behavior to reuse storage that is or was occupied by a const complete object of static<span class="t-rev-inl t-since-cxx11"><span>, thread-local,</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> or automatic storage duration because such objects may be stored in read-only memory:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> B
<span class="br0">{</span>
    B<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// non-trivial</span>
    ~B<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// non-trivial</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">const</span> B b<span class="sy4">;</span> <span class="co1">// const static</span>
&nbsp;
<span class="kw4">void</span> h<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    b.~B<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// end the lifetime of b</span>
    new <span class="br0">(</span><span class="kw1">const_cast</span><span class="sy1">&lt;</span>B<span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy3">&amp;</span>b<span class="br0">)</span><span class="br0">)</span> <span class="kw4">const</span> B<span class="sy4">;</span> <span class="co1">// undefined behavior: attempted reuse of a const</span>
<span class="br0">}</span></pre></div></div>
<p>When evaluating a <a href="new.html" title="cpp/language/new">new expression</a>, storage is considered reused after it is returned from the <a href="../memory/new/operator_new.html" title="cpp/memory/new/operator new">allocation function</a>, but before the evaluation of the <span class="t-spar">initializer</span> of the new expression:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> S
<span class="br0">{</span>
    <span class="kw4">int</span> m<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    S x<span class="br0">{</span><span class="nu0">1</span><span class="br0">}</span><span class="sy4">;</span>
    new<span class="br0">(</span><span class="sy3">&amp;</span>x<span class="br0">)</span> S<span class="br0">(</span>x.<span class="me1">m</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// undefined behavior: the storage is reused</span>
<span class="br0">}</span></pre></div></div>
<p>If a new object is created at the address that was occupied by another object, then all pointers, references, and the name of the original object will automatically refer to the new object and, once the lifetime of the new object begins, can be used to manipulate the new object, but only if the original object is transparently replaceable by the new object.
</p><p>If all following conditions are satisfied, object <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span> is <i>transparently replaceable</i> by object <span class="t-c"><span class="mw-geshi cpp source-cpp">y</span></span>:
</p>
<ul><li> The storage for <span class="t-c"><span class="mw-geshi cpp source-cpp">y</span></span> exactly overlays the storage location which <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span> occupied.
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">y</span></span> is of the same type as <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span> (ignoring the top-level cv-qualifiers).
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span> is not a complete const object.
</li><li> Neither <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span> nor <span class="t-c"><span class="mw-geshi cpp source-cpp">y</span></span> is a base class subobject<span class="t-rev-inl t-since-cxx20"><span>, or a member subobject declared with <code>[[<a href="attributes/no_unique_address.html" title="cpp/language/attributes/no unique address">no_unique_address</a>]]</code></span><span><span class="t-mark-rev t-since-cxx20">(since C++20)</span></span></span>.
</li><li> One of the following conditions is satisfied:
</li></ul>
<dl><dd><ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">y</span></span> are both complete objects.
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">x</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">y</span></span> are direct subobjects of objects <span class="t-c"><span class="mw-geshi cpp source-cpp">ox</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">oy</span></span> respectively, and <span class="t-c"><span class="mw-geshi cpp source-cpp">ox</span></span> is transparently replaceable by <span class="t-c"><span class="mw-geshi cpp source-cpp">oy</span></span>.
</li></ul>
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C
<span class="br0">{</span>
    <span class="kw4">int</span> i<span class="sy4">;</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw4">const</span> C<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> C<span class="sy3">&amp;</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">const</span> C<span class="sy3">&amp;</span> C<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> C<span class="sy3">&amp;</span> other<span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">if</span> <span class="br0">(</span>this <span class="sy3">!</span><span class="sy1">=</span> <span class="sy3">&amp;</span>other<span class="br0">)</span>
    <span class="br0">{</span>
        this<span class="sy2">-</span><span class="sy1">&gt;</span>~C<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>          <span class="co1">// lifetime of *this ends</span>
        new <span class="br0">(</span>this<span class="br0">)</span> C<span class="br0">(</span>other<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// new object of type C created</span>
        f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>                 <span class="co1">// well-defined</span>
    <span class="br0">}</span>
    <span class="kw1">return</span> <span class="sy2">*</span>this<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
C c1<span class="sy4">;</span>
C c2<span class="sy4">;</span>
c1 <span class="sy1">=</span> c2<span class="sy4">;</span> <span class="co1">// well-defined</span>
c1.<span class="me1">f</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// well-defined; c1 refers to a new object of type C</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<p>If the conditions listed above are not met, a valid pointer to the new object may still be obtained by applying the pointer optimization barrier <span class="t-lc"><a href="../utility/launder.html" title="cpp/utility/launder">std::launder</a></span>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A
<span class="br0">{</span> 
    <span class="kw1">virtual</span> <span class="kw4">int</span> transmogrify<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> B <span class="sy4">:</span> A
<span class="br0">{</span>
    <span class="kw4">int</span> transmogrify<span class="br0">(</span><span class="br0">)</span> override <span class="br0">{</span> <span class="sy4">::</span><span class="me2">new</span><span class="br0">(</span>this<span class="br0">)</span> A<span class="sy4">;</span> <span class="kw1">return</span> <span class="nu0">2</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">inline</span> <span class="kw4">int</span> A<span class="sy4">::</span><span class="me2">transmogrify</span><span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <span class="sy4">::</span><span class="me2">new</span><span class="br0">(</span>this<span class="br0">)</span> B<span class="sy4">;</span> <span class="kw1">return</span> <span class="nu0">1</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> test<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    A i<span class="sy4">;</span>
    <span class="kw4">int</span> n <span class="sy1">=</span> i.<span class="me1">transmogrify</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="co1">// int m = i.transmogrify(); // undefined behavior:</span>
    <span class="co1">// the new A object is a base subobject, while the old one is a complete object</span>
    <span class="kw4">int</span> m <span class="sy1">=</span> <a href="../utility/launder.html"><span class="kw1130">std::<span class="me2">launder</span></span></a><span class="br0">(</span><span class="sy3">&amp;</span>i<span class="br0">)</span><span class="sy2">-</span><span class="sy1">&gt;</span>transmogrify<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK</span>
    <a href="../error/assert.html"><span class="kw778">assert</span></a><span class="br0">(</span>m <span class="sy2">+</span> n <span class="sy1">==</span> <span class="nu0">3</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<p>Similarly, if an object is created in the storage of a class member or array element, the created object is only a subobject (member or element) of the original object's containing object if:
</p>
<ul><li> the lifetime of the containing object has begun and not ended
</li><li> the storage for the new object exactly overlays the storage of the original object
</li><li> the new object is of the same type as the original object (ignoring cv-qualification).
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<p>Otherwise, the name of the original subobject cannot be used to access the new object without <span class="t-lc"><a href="../utility/launder.html" title="cpp/utility/launder">std::launder</a></span>:
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: an appropriate example </td></tr></tbody></table>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=3" title="Edit section: Providing storage">edit</a>]</span> <span class="mw-headline" id="Providing_storage">Providing storage</span></h4>
<p>As a special case, objects can be created in arrays of <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span><span class="t-rev-inl t-since-cxx17"><span> or <a href="../types/byte.html" title="cpp/types/byte"><tt>std::byte</tt></a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> (in which case it is said that the array <i>provides storage</i> for the object) if
</p>
<ul><li> the lifetime of the array has begun and not ended
</li><li> the storage for the new object fits entirely within the array
</li><li> there is no array object that satisfies these constraints nested within the array.
</li></ul>
<p>If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused, however the lifetime of the array itself does not end (its storage is not considered to have been reused).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span>... <span class="me1">T</span><span class="sy1">&gt;</span>
<span class="kw1">struct</span> AlignedUnion
<span class="br0">{</span>
    alignas<span class="br0">(</span>T...<span class="br0">)</span> <span class="kw4">unsigned</span> <span class="kw4">char</span> data<span class="br0">[</span>max<span class="br0">(</span>sizeof<span class="br0">(</span>T<span class="br0">)</span>...<span class="br0">)</span><span class="br0">]</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    AlignedUnion<span class="sy1">&lt;</span><span class="kw4">int</span>, <span class="kw4">char</span><span class="sy1">&gt;</span> au<span class="sy4">;</span>
    <span class="kw4">int</span> <span class="sy2">*</span>p <span class="sy1">=</span> new <span class="br0">(</span>au.<span class="me1">data</span><span class="br0">)</span> <span class="kw4">int</span><span class="sy4">;</span>     <span class="co1">// OK, au.data provides storage</span>
    <span class="kw4">char</span> <span class="sy2">*</span>c <span class="sy1">=</span> new <span class="br0">(</span>au.<span class="me1">data</span><span class="br0">)</span> <span class="kw4">char</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK, ends lifetime of *p</span>
    <span class="kw4">char</span> <span class="sy2">*</span>d <span class="sy1">=</span> new <span class="br0">(</span>au.<span class="me1">data</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">)</span> <span class="kw4">char</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">return</span> <span class="sy2">*</span>c <span class="sy2">+</span> <span class="sy2">*</span>d<span class="sy4">;</span> <span class="co1">// OK</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=4" title="Edit section: Access outside of lifetime">edit</a>]</span> <span class="mw-headline" id="Access_outside_of_lifetime">Access outside of lifetime</span></h3>
<p>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, the behaviors of the following uses of the glvalue expression that identifies that object are undefined, unless the object is being constructed or destructed (separate set of rules applies):
</p>
<ol><li> Lvalue to rvalue conversion (e.g. function call to a function that takes a value).
</li><li> Access to a non-static data member or a call to a non-static member function.
</li><li> Binding a reference to a virtual base class subobject.
</li><li> <a href="dynamic_cast.html" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> or <a href="typeid.html" title="cpp/language/typeid"><code>typeid</code></a> expressions.
</li></ol>
<p>The above rules apply to pointers as well (binding a reference to virtual base is replaced by implicit conversion to a pointer to virtual base), with two additional rules:
</p>
<ol><li> <a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> of a pointer to storage without an object is only allowed when casting to (possibly cv-qualified) <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span>.
</li><li> Pointers to storage without an object that were cast to possibly cv-qualified <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span> can only be <a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> to pointers to possibly cv-qualified <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span>, or possibly cv-qualified <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span><span class="t-rev-inl t-since-cxx17"><span>, or possibly cv-qualified <a href="../types/byte.html" title="cpp/types/byte"><tt>std::byte</tt></a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.
</li></ol>
<p>During construction and destruction it is generally allowed to call non-static member functions, access non-static data members, and use <a href="typeid.html" title="cpp/language/typeid"><code>typeid</code></a> and <a href="dynamic_cast.html" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a>. However, because the lifetime either has not begun yet (during construction) or has already ended (during destruction), only specific operations are allowed. For one restriction, see <a href="virtual.html#During_construction_and_destruction" title="cpp/language/virtual">virtual function calls during construction and destruction</a>.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=5" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<p>Until the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2256.html">CWG issue 2256</a>, the end of lifetime rules are different between non-class objects (end of storage duration) and class objects (reverse order of construction):
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A
<span class="br0">{</span>
    <span class="kw4">int</span><span class="sy2">*</span> p<span class="sy4">;</span>
    ~A<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="sy2">*</span>p<span class="sy4">;</span> <span class="br0">}</span> <span class="co1">// undefined behavior since CWG2256: n does not outlive a</span>
                              <span class="co1">// well-defined until CWG2256: prints 123</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    A a<span class="sy4">;</span>
    <span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">123</span><span class="sy4">;</span> <span class="co1">// if n did not outlive a, this could have been optimized out (dead store)</span>
    a.<span class="me1">p</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Until the resolution of <a rel="nofollow" class="external text" href="https://wg21.link/p1971r0#RU007">RU007</a>, a non-static member of a const-qualified type or a reference type prevents its containing object from being transparently replaceable, which makes <span class="t-lc"><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></span> and <span class="t-lc"><a href="../container/deque.html" title="cpp/container/deque">std::deque</a></span> hard to implement:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> X <span class="br0">{</span> <span class="kw4">const</span> <span class="kw4">int</span> n<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">union</span> U <span class="br0">{</span> X x<span class="sy4">;</span> <span class="kw4">float</span> f<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> tong<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    U u <span class="sy1">=</span> <span class="br0">{</span> <span class="br0">{</span><span class="nu0">1</span><span class="br0">}</span> <span class="br0">}</span><span class="sy4">;</span>
    u.<span class="me1">f</span> <span class="sy1">=</span> <span class="nu0">5</span>.<span class="me1">f</span><span class="sy4">;</span>                          <span class="co1">// OK: creates new subobject of 'u'</span>
    X <span class="sy2">*</span>p <span class="sy1">=</span> new <span class="br0">(</span><span class="sy3">&amp;</span>u.<span class="me1">x</span><span class="br0">)</span> X <span class="br0">{</span><span class="nu0">2</span><span class="br0">}</span><span class="sy4">;</span>            <span class="co1">// OK: creates new subobject of 'u'</span>
    <a href="../error/assert.html"><span class="kw778">assert</span></a><span class="br0">(</span>p<span class="sy2">-</span><span class="sy1">&gt;</span>n <span class="sy1">==</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>                  <span class="co1">// OK</span>
    <a href="../error/assert.html"><span class="kw778">assert</span></a><span class="br0">(</span>u.<span class="me1">x</span>.<span class="me1">n</span> <span class="sy1">==</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>                 <span class="co1">// undefined until RU007:</span>
                                        <span class="co1">// 'u.x' does not name the new subobject</span>
    <a href="../error/assert.html"><span class="kw778">assert</span></a><span class="br0">(</span><span class="sy2">*</span><a href="../utility/launder.html"><span class="kw1130">std::<span class="me2">launder</span></span></a><span class="br0">(</span><span class="sy3">&amp;</span>u.<span class="me1">x</span>.<span class="me1">n</span><span class="br0">)</span> <span class="sy1">==</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK even until RU007</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=6" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/119.html">CWG 119</a>
</td>
<td>C++98
</td>
<td>an object of a class type with a non-trivial constructor can<br>only start its lifetime when the constructor call has completed
</td>
<td>lifetime also started<br>for other initializations
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/201.html">CWG 201</a>
</td>
<td>C++98
</td>
<td>lifetime of a temporary object in a default argument<br>of a default constructor was required to end<br>when the initialization of the array completes
</td>
<td>lifetime ends before<br>initializing the next<br>element (also resolves<br><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/124.html">CWG issue 124</a>)
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/274.html">CWG 274</a>
</td>
<td>C++98
</td>
<td>an lvalue designating an out-of-lifetime object could be<br>used as the operand of static_cast only if the conversion<br>was ultimately to cv-unqualified <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span><span class="sy3">&amp;</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span><span class="sy3">&amp;</span></span>
</td>
<td>cv-qualified <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span><span class="sy3">&amp;</span></span><br>and <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span><span class="sy3">&amp;</span></span><br>also allowed
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/597.html">CWG 597</a>
</td>
<td>C++98
</td>
<td>the following behaviors were undefined:<br>1. a pointer to an out-of-lifetime object is implicitly<br>converted to a pointer to a non-virtual base class<br>2. an lvalue referring to an out-of-lifetime object<br>is bound to a reference to a non-virtual base class<br>3. an lvalue referring to an out-of-lifetime object is used<br>as the operand of a <span class="mw-geshi cpp source-cpp"><span class="kw1">static_cast</span></span> (with a few exceptions)
</td>
<td>made well-defined
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2012.html">CWG 2012</a>
</td>
<td>C++98
</td>
<td>lifetime of references was specified to match storage duration,<br>requiring that extern references are alive before their initializers run
</td>
<td>lifetime begins<br>at initialization
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2107.html">CWG 2107</a>
</td>
<td>C++98
</td>
<td>the resolution of <a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/124.html">CWG issue 124</a> was not applied to copy constructors
</td>
<td>applied
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2256.html">CWG 2256</a>
</td>
<td>C++98
</td>
<td>lifetime of trivially destructible objects were inconsistent with other objects
</td>
<td>made consistent
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2470.html">CWG 2470</a>
</td>
<td>C++98
</td>
<td>more than one arrays could provide storage for the same object
</td>
<td>only one provides
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2489.html">CWG 2489</a>
</td>
<td>C++98
</td>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">char</span><span class="br0">[</span><span class="br0">]</span></span> cannot provide storage, but objects<br>could be implicitly created within its storage
</td>
<td>objects cannot be<br>implicitly created within<br> the storage of <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span><span class="br0">[</span><span class="br0">]</span></span>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2527.html">CWG 2527</a>
</td>
<td>C++98
</td>
<td>if a destructor is not invoked because of reusing storage and the<br>program depends on its side effects, the behavior was undefined
</td>
<td>the behavior is well-<br>defined in this case
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2721.html">CWG 2721</a>
</td>
<td>C++98
</td>
<td>the exact time point of storage reuse was unclear for placement <span class="mw-geshi cpp source-cpp">new</span>
</td>
<td>made clear
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2849.html">CWG 2849</a>
</td>
<td>C++23
</td>
<td>function parameter objects were considered as temporary<br>objects for range-<span class="mw-geshi cpp source-cpp"><span class="kw1">for</span></span> loop temporary object lifetime extension
</td>
<td>not considered as<br>temporary objects
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2854.html">CWG 2854</a>
</td>
<td>C++98
</td>
<td>exception objects were temporary objects
</td>
<td>they are not<br>temporary objects
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2867.html">CWG 2867</a>
</td>
<td>C++17
</td>
<td>the lifetime of temporary objects created in<br>structured binding declarations were not extended
</td>
<td>extended to the end<br>of the declaration
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://wg21.link/P0137R1">P0137R1</a>
</td>
<td>C++98
</td>
<td>creating an object in an array of <span class="mw-geshi cpp source-cpp"><span class="kw4">unsigned</span> <span class="kw4">char</span></span> reused its storage
</td>
<td>its storage is not reused
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://wg21.link/P0593R6">P0593R6</a>
</td>
<td>C++98
</td>
<td>a pseudo-destructor call had no effects
</td>
<td>it destroys the object
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://wg21.link/P1971R0">P1971R0</a>
</td>
<td>C++98
</td>
<td>a non-static data member of a const-qualified type or a reference type<br>prevented its containing object from being transparently replaceable
</td>
<td>restriction removed
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://wg21.link/P2103R0">P2103R0</a>
</td>
<td>C++98
</td>
<td>transparently replaceability did not require keeping the original structure
</td>
<td>requires
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=7" title="Edit section: References">edit</a>]</span> <span class="mw-headline" id="References">References</span></h3>
<div class="t-ref-std-c++23">
<ul><li> C++23 standard (ISO/IEC 14882:2024): 
</li></ul>
<dl><dd><ul><li> 6.7.3 Object lifetime [basic.life] 
</li></ul>
</dd></dl>
<dl><dd><ul><li> 11.9.5 Construction and destruction [class.cdtor] 
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c++20">
<ul><li> C++20 standard (ISO/IEC 14882:2020): 
</li></ul>
<dl><dd><ul><li> 6.7.3 Object lifetime [basic.life] 
</li></ul>
</dd></dl>
<dl><dd><ul><li> 11.10.4 Construction and destruction [class.cdtor] 
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c++17">
<ul><li> C++17 standard (ISO/IEC 14882:2017): 
</li></ul>
<dl><dd><ul><li> 6.8 Object lifetime [basic.life] 
</li></ul>
</dd></dl>
<dl><dd><ul><li> 15.7 Construction and destruction [class.cdtor] 
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c++14">
<ul><li> C++14 standard (ISO/IEC 14882:2014): 
</li></ul>
<dl><dd><ul><li> 3 Object lifetime [basic.life] 
</li></ul>
</dd></dl>
<dl><dd><ul><li> 12.7 Construction and destruction [class.cdtor] 
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c++11">
<ul><li> C++11 standard (ISO/IEC 14882:2011): 
</li></ul>
<dl><dd><ul><li> 3.8 Object lifetime [basic.life] 
</li></ul>
</dd></dl>
<dl><dd><ul><li> 12.7 Construction and destruction [class.cdtor] 
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c++03">
<ul><li> C++03 standard (ISO/IEC 14882:2003): 
</li></ul>
<dl><dd><ul><li> 3.8 Object lifetime [basic.life] 
</li></ul>
</dd></dl>
<dl><dd><ul><li> 12.7 Construction and destruction [class.cdtor] 
</li></ul>
</dd></dl>
</div>
<div class="t-ref-std-c++98">
<ul><li> C++98 standard (ISO/IEC 14882:1998): 
</li></ul>
<dl><dd><ul><li> 3.8 Object lifetime [basic.life] 
</li></ul>
</dd></dl>
<dl><dd><ul><li> 12.7 Construction and destruction [class.cdtor] 
</li></ul>
</dd></dl>
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;action=edit&amp;section=8" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see"><span><a href="https://en.cppreference.com/w/c/language/lifetime" title="c/language/lifetime">C documentation</a></span> for <span class=""><span>Lifetime</span></span></div>
</td></tr>

</tbody></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 5878/1000000
Preprocessor generated node count: 15630/1000000
Post‐expand include size: 163159/4194304 bytes
Template argument size: 30435/4194304 bytes
Highest expansion depth: 20/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:13096-0!*!0!!en!*!* and timestamp 20250103105218 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;oldid=174479">https://en.cppreference.com/mwiki/index.php?title=cpp/language/lifetime&amp;oldid=174479</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 5.348 secs. -->
	




</body><!-- Cached 20250103105218 --><!-- Mirrored from en.cppreference.com/w/cpp/language/lifetime by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:38 GMT --></html>