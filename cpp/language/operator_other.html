<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/operator_other by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:33:50 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>Other operators</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_operator_other skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">Other operators</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<table class="wikitable" style="font-size:85%;">

<tbody><tr>
<th rowspan="2">Operator<br>name
</th>
<th rowspan="2" style="width: 9%">Syntax
</th>
<th rowspan="2"><a href="operators.html" title="cpp/language/operators">Over​load​able</a>
</th>
<th colspan="2">Prototype examples (for <span class="mw-geshi cpp source-cpp"><span class="kw1">class</span> T</span>)
</th></tr>
<tr>
<th>Inside class definition
</th>
<th>Outside class definition
</th></tr>
<tr>
<td>function call
</td>
<td><code>a(a1, a2)</code>
</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Yes
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">R T<span class="sy4">::</span><span class="me2">operator</span><span class="br0">(</span><span class="br0">)</span><span class="br0">(</span>Arg1 <span class="sy3">&amp;</span>a1, Arg2 <span class="sy3">&amp;</span>a2, ...<span class="br0">)</span><span class="sy4">;</span></span></span>
</td>
<td style="background: #ececec; color: grey; vertical-align: middle; text-align: center;" class="table-na"> <small>N/A</small>
</td></tr>
<tr>
<td>comma
</td>
<td><code>a, b</code>
</td>
<td style="background: #90ff90; color: black; vertical-align: middle; text-align: center;" class="table-yes">Yes
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">T2<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span>,<span class="br0">(</span>T2 <span class="sy3">&amp;</span>b<span class="br0">)</span><span class="sy4">;</span></span></span>
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">T2<span class="sy3">&amp;</span> operator,<span class="br0">(</span><span class="kw4">const</span> T <span class="sy3">&amp;</span>a, T2 <span class="sy3">&amp;</span>b<span class="br0">)</span><span class="sy4">;</span></span></span>
</td></tr>
<tr>
<td>conditional operator
</td>
<td><code>a&nbsp;? b&nbsp;: c</code>
</td>
<td style="background:#ff9090; color:black; vertical-align: middle; text-align: center;" class="table-no"> No
</td>
<td style="background: #ececec; color: grey; vertical-align: middle; text-align: center;" class="table-na"> <small>N/A</small>
</td>
<td style="background: #ececec; color: grey; vertical-align: middle; text-align: center;" class="table-na"> <small>N/A</small>
</td></tr></tbody></table>
<p>The <i>function call</i> operator provides function semantics for any object.
</p><p>The <i>conditional operator</i> (colloquially referred to as <i>ternary conditional</i> ﻿) checks the boolean value of the first expression and,  depending on the resulting value, evaluates and returns either the second or the third expression.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Built-in_function_call_operator"><span class="tocnumber">1</span> <span class="toctext">Built-in function call operator</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Built-in_comma_operator"><span class="tocnumber">2</span> <span class="toctext">Built-in comma operator</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Conditional_operator"><span class="tocnumber">3</span> <span class="toctext">Conditional operator</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="#Overloads"><span class="tocnumber">3.1</span> <span class="toctext">Overloads</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Standard_library"><span class="tocnumber">4</span> <span class="toctext">Standard library</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Defect_reports"><span class="tocnumber">5</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;action=edit&amp;section=1" title="Edit section: Built-in function call operator">edit</a>]</span> <span class="mw-headline" id="Built-in_function_call_operator">Built-in function call operator</span></h3>
<p>Function call expressions have the following form:
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td class="t-sdsc-nopad"> <span class="t-spar">function</span> ﻿<code><b>(</b></code><span class="t-spar">arg1</span><code><b>,</b></code> <span class="t-spar">arg2</span><code><b>,</b></code> <span class="t-spar">arg3</span><code><b>,</b></code>...<code><b>)</b></code>
</td>
<td class="t-sdsc-nopad">
</td>
<td class="t-sdsc-nopad">
</td></tr>

 

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<table class="t-par-begin">


<tbody><tr class="t-par">
<td> <span class="t-spar">function</span>
</td>
<td> -
</td>
<td> an expression function type or function pointer type
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">arg1</span><code><b>,</b></code> <span class="t-spar">arg2</span><code><b>,</b></code> <span class="t-spar">arg3</span><code><b>,</b></code>...
</td>
<td> -
</td>
<td> a possibly empty list of arbitrary expressions<span class="t-rev-inl t-since-cxx11"><span> or <a href="initialization.html" title="cpp/language/initialization">brace-enclosed initializer lists</a></span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>, except the comma operator is not allowed at the top level to avoid ambiguity
</td></tr></tbody></table>
<p>For a call to a non-member function or to a <a href="static.html" title="cpp/language/static">static member function</a>, <span class="t-spar">function</span> can be an lvalue that refers to a function (in which case the <a href="implicit_conversion.html#Function-to-pointer_conversion" title="cpp/language/implicit conversion">function-to-pointer conversion</a> is suppressed), or a prvalue of function pointer type.
</p><p>The function (or member) name specified by <span class="t-spar">function</span> can be overloaded, <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a> rules used to decide which overload is to be called.
</p><p>If <span class="t-spar">function</span> specifies a member function, it may be virtual, in which case the final overrider of that function will be called, using dynamic dispatch at runtime.
</p><p>To call the function, 
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx17"><td>
<p>The expression <span class="t-spar">function</span> as well as all expressions <span class="t-spar">arg1</span>, <span class="t-spar">arg2</span>, <span class="t-spar">arg3</span>, etc, provided as arguments are evaluated in arbitrary order, <a href="eval_order.html" title="cpp/language/eval order">unsequenced</a> with respect to each other.
</p>
</td>
<td><span class="t-mark-rev t-until-cxx17">(until C++17)</span></td></tr>
<tr class="t-rev t-since-cxx17"><td>
<p><span class="t-spar">function</span> is sequenced before each of <span class="t-spar">arg1</span>, <span class="t-spar">arg2</span>, <span class="t-spar">arg3</span> as well as <a href="default_arguments.html" title="cpp/language/default arguments">default arguments</a>, if any. The argument expressions are evaluated in arbitrary order, <a href="eval_order.html" title="cpp/language/eval order">indeterminately sequenced</a> with respect to each other.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<p>Each function parameter is initialized with its corresponding argument after <a href="implicit_conversion.html" title="cpp/language/implicit conversion">implicit conversion</a> if necessary.
</p>
<ul><li> If there is no corresponding argument, the corresponding <a href="default_arguments.html" title="cpp/language/default arguments">default argument</a> is used, and if there is none, the program is ill-formed.
</li><li> If the call is made to a member function, then the <span class="t-c"><span class="mw-geshi cpp source-cpp">this</span></span> pointer to current object is converted as if by explicit cast to the <span class="t-c"><span class="mw-geshi cpp source-cpp">this</span></span> pointer expected by the function.
</li><li> The initialization and destruction of each parameter occurs in the context of the <a href="expressions.html#Full-expressions" title="cpp/language/expressions">full-expression</a> where the function call appears, which means, for example, that if a constructor or destructor of a parameter throws an exception, the <a href="try.html#Function_try_block" title="cpp/language/try">function <span class="mw-geshi cpp source-cpp"><span class="kw1">try</span></span> blocks</a> of the called function are not considered.
</li></ul>
<p>If the function is a variadic function, <a href="variadic_arguments.html#Default_conversions" title="cpp/language/variadic arguments">default argument promotions</a> are applied to all arguments matched by the ellipsis parameter.
</p><p>It is implementation-defined whether a parameter is destroyed when the function in which it is defined exits or at the end of the enclosing full-expression. Parameters are always destroyed in the reverse order of their construction.
</p><p>The return type of a function call expression is the return type of the chosen function, decided using static binding (ignoring the <span class="mw-geshi cpp source-cpp"><span class="kw1">virtual</span></span> keyword), even if the overriding function that is actually called returns a different type. This allows the overriding functions to return pointers or references to classes that are derived from the return type returned by the base function, i.e. C++ supports <a href="https://en.wikipedia.org/wiki/Covariant_return_type" class="extiw" title="enwiki:Covariant return type">covariant return types</a>. If <span class="t-spar">function</span> specifies a destructor, the return type is <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>.
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<p>When an object of class type <code>X</code> is passed to or returned from a function, if each copy constructor, move constructor, and destructor of <code>X</code> is either trivial or deleted, and <code>X</code> has at least one non-deleted copy or move constructor, implementations are permitted to create a temporary object to hold the function parameter or result object.
</p><p>The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the non-deleted trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).
</p><p>This allows objects of small class types, such as <span class="t-lc"><a href="../numeric/complex.html" title="cpp/numeric/complex">std::complex</a></span> or <span class="t-lc">std::span</span>, to be passed to or returned from functions in registers.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<p>The value category of a function call expression is lvalue if the function returns an lvalue reference or an rvalue reference to function, is an xvalue if the function returns an rvalue reference to object, and is a prvalue otherwise. If the function call expression is a prvalue of object type, it must have <a href="type.html#Incomplete_type" title="cpp/language/type">complete type</a><span class="t-rev-inl t-since-cxx11"><span> except when used as the operand of <a href="decltype.html" title="cpp/language/decltype"><code>decltype</code></a> (or as the right operand of a <a href="#Built-in_comma_operator">built-in comma operator</a> that is the operand of <span class="mw-geshi cpp source-cpp">decltype</span>)</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.
</p><p>Function call expression is similar in syntax to value initialization <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="br0">(</span><span class="br0">)</span></span></span>, to <a href="explicit_cast.html" title="cpp/language/explicit cast">function-style cast</a> expression <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="br0">(</span>A1<span class="br0">)</span></span></span>, and to direct initialization of a temporary <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="br0">(</span>A1, A2, A3, ...<span class="br0">)</span></span></span>, where <code>T</code> is the name of a type.
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;cstdio&gt;</span>
&nbsp;
<span class="kw1">struct</span> S
<span class="br0">{</span>
    <span class="kw4">int</span> f1<span class="br0">(</span><span class="kw4">double</span> d<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">return</span> printf<span class="br0">(</span><span class="st0">"%f <span class="es1">\n</span>"</span>, d<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// variable argument function call</span>
    <span class="br0">}</span>
&nbsp;
    <span class="kw4">int</span> f2<span class="br0">(</span><span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">return</span> f1<span class="br0">(</span><span class="nu0">7</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// member function call, same as this-&gt;f1()</span>
                      <span class="co1">// integer argument converted to double</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    puts<span class="br0">(</span><span class="st0">"function called"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// function call</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// function call</span>
    S s<span class="sy4">;</span>
    s.<span class="me1">f2</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// member function call</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">function called
7.000000</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;action=edit&amp;section=2" title="Edit section: Built-in comma operator">edit</a>]</span> <span class="mw-headline" id="Built-in_comma_operator">Built-in comma operator</span></h3>
<p>Comma expressions have the following form:
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td class="t-sdsc-nopad"> <span class="t-spar">E1</span> <code><b>,</b></code> <span class="t-spar">E2</span>
</td>
<td class="t-sdsc-nopad">
</td>
<td class="t-sdsc-nopad">
</td></tr>

 

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<p>In a comma expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E1, E2</span></span>, the expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E1</span></span> is evaluated, its result is <a href="expressions.html#Discarded-value_expressions" title="cpp/language/expressions">discarded</a> (although if it has class type, it won't be destroyed <a href="lifetime.html#Temporary_object_lifetime" title="cpp/language/lifetime">until the end of the containing full expression</a>), and its side effects are completed before evaluation of the expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> begins <span class="t-rev-inl t-until-cxx17"><span>(note that a user-defined <code>operator,</code> cannot guarantee sequencing)</span><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span>. 
</p><p>The type, value, and value category of the result of the comma expression are exactly the type, value, and value category of the second operand, <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span>. If <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> is a temporary <span class="t-rev-inl t-since-cxx17"><span>expression</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>, the result of the expression is that temporary <span class="t-rev-inl t-since-cxx17"><span>expression</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>. If <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> is a bit-field, the result is a bit-field.
</p><p>The comma in various comma-separated lists, such as function argument lists (<span class="t-c"><span class="mw-geshi cpp source-cpp">f<span class="br0">(</span>a, b, c<span class="br0">)</span></span></span>) and initializer lists <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw4">int</span> a<span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="nu0">2</span>, <span class="nu0">3</span><span class="br0">}</span></span></span>, is not the comma operator. If the comma operator needs to be used in such contexts, it has to be parenthesized: <span class="t-c"><span class="mw-geshi cpp source-cpp">f<span class="br0">(</span>a, <span class="br0">(</span>n<span class="sy2">++</span>, n <span class="sy2">+</span> b<span class="br0">)</span>, c<span class="br0">)</span></span></span>.
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx20 t-until-cxx23"><td>
<p>Using an unparenthesized comma expression as second (right) argument of a <a href="operator_member_access.html#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator</a> is deprecated.
</p><p>For example, <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="br0">[</span>b, c<span class="br0">]</span></span></span> is deprecated and <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="br0">[</span><span class="br0">(</span>b, c<span class="br0">)</span><span class="br0">]</span></span></span> is not.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span><br><span class="t-mark-rev t-until-cxx23">(until C++23)</span></td></tr>
<tr class="t-rev t-since-cxx23"><td>
<p>An unparenthesized comma expression cannot be second (right) argument of a <a href="operator_member_access.html#Built-in_subscript_operator" title="cpp/language/operator member access">subscript operator</a>. For example, <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="br0">[</span>b, c<span class="br0">]</span></span></span> is either ill-formed or equivalent to <span class="t-c"><span class="mw-geshi cpp source-cpp">a.<span class="me1">operator</span><span class="br0">[</span><span class="br0">]</span><span class="br0">(</span>b, c<span class="br0">)</span></span></span>.
</p><p>Parentheses are needed when using a comma expression as the subscript, e.g., <span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="br0">[</span><span class="br0">(</span>b, c<span class="br0">)</span><span class="br0">]</span></span></span>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td></tr>
</tbody></table>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// comma is often used to execute more than one expression</span>
    <span class="co1">// where the language grammar allows only one expression:</span>
&nbsp;
    <span class="co1">// * in the third component of the for loop</span>
    <span class="kw1">for</span> <span class="br0">(</span><span class="kw4">int</span> i <span class="sy1">=</span> <span class="nu0">0</span>, j <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span> i <span class="sy1">&lt;=</span> j<span class="sy4">;</span> <span class="sy2">++</span>i, <span class="sy2">--</span>j<span class="br0">)</span>
    <span class="co1">//            ^list separator      ^comma operator</span>
        <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"i = "</span> <span class="sy1">&lt;&lt;</span> i <span class="sy1">&lt;&lt;</span> <span class="st0">" j = "</span> <span class="sy1">&lt;&lt;</span> j <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
&nbsp;
    <span class="co1">// * in a return statement</span>
    <span class="co1">// return log("an error!"), -1;</span>
&nbsp;
    <span class="co1">// * in an initializer expression</span>
    <span class="co1">// MyClass(const Arg&amp; arg)</span>
    <span class="co1">//&nbsp;: member{ throws_if_bad(arg), arg }</span>
&nbsp;
    <span class="co1">// etc.</span>
&nbsp;
    <span class="co1">// comma operators can be chained; the result of the last</span>
    <span class="co1">// (rightmost) expression is the result of the whole chain:</span>
    <span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <span class="kw4">int</span> m <span class="sy1">=</span> <span class="br0">(</span><span class="sy2">++</span>n, <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"n = "</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span>, <span class="sy2">++</span>n, <span class="nu0">2</span> <span class="sy2">*</span> n<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    <span class="co1">// m is now 6</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"m = "</span> <span class="sy1">&lt;&lt;</span> <span class="br0">(</span><span class="sy2">++</span>m, m<span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">i = 0 j = 10
i = 1 j = 9
i = 2 j = 8
i = 3 j = 7
i = 4 j = 6
i = 5 j = 5
n = 2
m = 7</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;action=edit&amp;section=3" title="Edit section: Conditional operator">edit</a>]</span> <span class="mw-headline" id="Conditional_operator">Conditional operator</span></h3>
<p>The conditional operator expressions have the form 
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td class="t-sdsc-nopad"> <span class="t-spar">E1</span> <code><b>?</b></code> <span class="t-spar">E2</span> <code><b>:</b></code> <span class="t-spar">E3</span>
</td>
<td class="t-sdsc-nopad">
</td>
<td class="t-sdsc-nopad">
</td></tr>

 

<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<p>The first operand of the conditional operator is evaluated and <a href="implicit_conversion.html" title="cpp/language/implicit conversion">contextually converted</a> to <span class="mw-geshi cpp source-cpp"><span class="kw4">bool</span></span>. After both the value evaluation and all side effects of the first operand are completed, if the result was <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span>, the second operand is evaluated. If the result was <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">false</span></span></span>, the third operand is evaluated.
</p><p>The type and value category of the conditional expression <span class="t-c"><span class="mw-geshi cpp source-cpp">E1 <span class="sy4">?</span> E2 <span class="sy4">:</span> E3</span></span> are determined according to the following rules:
</p>
<ul><li> If either <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> or <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> has type <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>:
</li></ul>
<dl><dd><ul><li> If both <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> are of type <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>, the result is a prvalue of type <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>.
</li><li> Otherwise, if the operand of type <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> is a (possibly parenthesized) <a href="throw.html" title="cpp/language/throw"><span class="mw-geshi cpp source-cpp"><span class="kw1">throw</span></span> expression</a>, the result has the type and the value category of the other expression. If the other expression is a <a href="bit_field.html" title="cpp/language/bit field">bit-field</a>, the result is a bit-field.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">[1]</a></sup>
</li><li> Otherwise, the program is ill-formed.
</li></ul>
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="nu0">2</span> <span class="sy2">+</span> <span class="nu0">2</span> <span class="sy1">==</span> <span class="nu0">4</span> <span class="sy4">?</span> <span class="kw1">throw</span> <span class="nu0">123</span> <span class="sy4">:</span> <span class="kw1">throw</span> <span class="nu0">456</span><span class="sy4">;</span>
&nbsp;
<a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a> str <span class="sy1">=</span> <span class="nu0">2</span> <span class="sy2">+</span> <span class="nu0">2</span> <span class="sy1">==</span> <span class="nu0">4</span> <span class="sy4">?</span> <span class="st0">"OK"</span> <span class="sy4">:</span> <span class="kw1">throw</span> <a href="../error/logic_error.html"><span class="kw769">std::<span class="me2">logic_error</span></span></a><span class="br0">(</span><span class="st0">"2 + 2&nbsp;!= 4"</span><span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<ul><li> Otherwise, if <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> or <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> are <span class="t-rev-inl t-until-cxx11"><span>lvalue bit-fields</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>glvalue bit-fields of the same value category</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> and of types <i>cv1</i> <code>T</code> and <i>cv2</i> <code>T</code>, respectively, the operands are considered to be of type <i>cv</i> <code>T</code> for the remainder of this section, where cv is the union of <i>cv1</i> and <i>cv2</i>.
</li></ul>
<ul><li> Otherwise, if <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> have different types, at least one of which is a (possibly cv-qualified) class type, or both are <span class="t-rev-inl t-until-cxx11"><span>lvalues</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>glvalues of the same value category</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> and have the same type except for cv-qualification, then an attempt is made to form an <a href="implicit_conversion.html" title="cpp/language/implicit conversion">implicit conversion sequence</a>.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2">[2]</a></sup>
</li></ul>
<dl><dd> Attempts are made to form an implicit conversion sequence from an operand expression <span class="t-c"><span class="mw-geshi cpp source-cpp">X</span></span> of type <code>TX</code> to a <i>target type</i> related to the type <code>TY</code> of the operand expression <span class="t-c"><span class="mw-geshi cpp source-cpp">Y</span></span> as follows:
<ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">Y</span></span> is an lvalue, the target type is <code>TY&amp;</code>, but an implicit conversion sequence can only be formed if the reference would <a href="reference_initialization.html#Direct_binding" title="cpp/language/reference initialization">bind directly</a> to <span class="t-rev-inl t-until-cxx11"><span>an lvalue</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>a glvalue</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.
</li></ul>
</dd></dl>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<dl><dd><ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">Y</span></span> is an xvalue, the target type is <code>TY&amp;&amp;</code>, but an implicit conversion sequence can only be formed if the reference would bind directly.
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<dl><dd><ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">Y</span></span> is <span class="t-rev-inl t-until-cxx11"><span>an rvalue</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>a prvalue</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> or if none of the conversion sequences above can be formed, and at least one of <code>TX</code> and <code>TY</code> is a (possibly cv-qualified) class type:
</li></ul>
<dl><dd><ul><li> If <code>TX</code> and <code>TY</code> are the same class type (ignoring cv-qualification):
</li></ul>
<dl><dd><ul><li> If <code>TY</code> is at least as cv-qualified as <code>TX</code>, the target type is <code>TY</code>.
</li><li> Otherwise, no conversion sequence is formed.
</li></ul>
</dd></dl>
<ul><li> Otherwise, if <code>TY</code> is a base class of <code>TX</code>, the target type is <code>TY</code> with the cv-qualifiers of <code>TX</code>.
</li><li> Otherwise, the target type is the type of <span class="t-c"><span class="mw-geshi cpp source-cpp">Z</span></span>, where <span class="t-c"><span class="mw-geshi cpp source-cpp">Z</span></span> is the value of <span class="t-c"><span class="mw-geshi cpp source-cpp">Y</span></span> after applying the lvalue-to-rvalue, array-to-pointer, and function-to-pointer <a href="implicit_conversion.html" title="cpp/language/implicit conversion">standard conversions</a>.
</li></ul>
</dd></dl>
<ul><li> Otherwise, no conversion sequence is formed.
</li></ul>
</dd><dd> Using this process, it is determined whether an implicit conversion sequence can be formed from <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> to the target type determined for the <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span>, and vice versa.
<ul><li> If both sequences can be formed, or one can be formed but it is the ambiguous conversion sequence, the program is ill-formed.
</li><li> If no conversion sequence can be formed, the operands are left unchanged.
</li><li> Otherwise, if exactly one conversion sequence can be formed, that conversion is applied to the chosen operand and the converted operand is used in place of the original operand for the remaining process.
</li></ul>
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> B <span class="sy4">:</span> A <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">using</span> T <span class="sy1">=</span> <span class="kw4">const</span> B<span class="sy4">;</span>
&nbsp;
A a <span class="sy1">=</span> <span class="kw2">true</span> <span class="sy4">?</span> A<span class="br0">(</span><span class="br0">)</span> <span class="sy4">:</span> T<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Y = A(), TY = A, X = T(), TX = const B, Target = const A</span></pre></div></div>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx11"><td>
<ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> are lvalues of the same type, then the result is an lvalue of that type, and is a bit-field if at least one of <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> is a bit-field.
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td></tr>
<tr class="t-rev t-since-cxx11"><td>
<ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> are glvalues of the same type and the same value category, then the result has the same type and value category, and is a bit-field if at least one of <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> is a bit-field.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<ul><li> Otherwise, the result is <span class="t-rev-inl t-until-cxx11"><span>an rvalue</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>a prvalue</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>.
</li></ul>
<dl><dd><ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> do not have the same type, and either has (possibly cv-qualified) class type, <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a> is performed using the <a href="#Overloads">built-in candidates</a> to attempt to convert the operands to built-in types.
</li></ul>
<dl><dd><ul><li> If the overload resolution fails, the program is ill-formed.
</li><li> Otherwise, the selected conversions are applied and the converted operands are used in place of the original operands for the remaining process.
</li></ul>
</dd></dl>
<ul><li> The array-to-pointer and function-to-pointer conversions are applied to (possibly-converted) <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span>. After those conversions, at least one of the following conditions must hold, otherwise the program is ill-formed:
</li></ul>
<dl><dd><ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> have the same type. In this case, the result is of that type and the result is <a href="copy_initialization.html" title="cpp/language/copy initialization">copy-initialized</a> using the selected operand.
</li><li> Both <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> have arithmetic or enumeration type. In this case, <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> are applied to bring them to their common type, and the result is of that type.
</li><li> At least one of <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> is a pointer. In this case, lvalue-to-rvalue, pointer<span class="t-rev-inl t-since-cxx17"><span>, function pointer</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> and qualification conversions are applied to bring them to their <a href="pointer.html#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>, and the result is of that type.
</li><li> At least one of <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> is a pointer to members. In this case, lvalue-to-rvalue, pointer-to-member<span class="t-rev-inl t-since-cxx17"><span>, function pointer</span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span> and qualification conversions are applied to bring them to their <a href="pointer.html#Composite_pointer_type" title="cpp/language/pointer">composite pointer type</a>, and the result is of that type.
</li></ul>
</dd></dl>
</dd></dl>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<dl><dd><dl><dd><ul><li> Both <span class="t-c"><span class="mw-geshi cpp source-cpp">E2</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">E3</span></span> are null pointer constants, and at least one of which is of type <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span>. In this case, the result is of type <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span>.
</li></ul>
</dd></dl>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span><span class="sy2">*</span> intPtr<span class="sy4">;</span>
&nbsp;
<span class="kw1">using</span> Mixed <span class="sy1">=</span> decltype<span class="br0">(</span><span class="kw2">true</span> <span class="sy4">?</span> nullptr <span class="sy4">:</span> intPtr<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
static_assert<span class="br0">(</span><a href="../types/is_same.html"><span class="kw592">std::<span class="me2">is_same_v</span></span></a><span class="sy1">&lt;</span>Mixed, <span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// nullptr becoming int*</span>
&nbsp;
<span class="kw1">struct</span> A
<span class="br0">{</span>
    <span class="kw4">int</span><span class="sy2">*</span> m_ptr<span class="sy4">;</span>
<span class="br0">}</span> a<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span><span class="sy2">*</span> A<span class="sy4">::</span><span class="sy2">*</span> memPtr <span class="sy1">=</span> <span class="sy3">&amp;</span>A<span class="sy4">::</span><span class="me2">m_ptr</span><span class="sy4">;</span> <span class="co1">// memPtr is a pointer to member m_ptr of A</span>
&nbsp;
<span class="co1">// memPtr makes nullptr as type of pointer to member m_ptr of A</span>
static_assert<span class="br0">(</span><a href="../types/is_same.html"><span class="kw592">std::<span class="me2">is_same_v</span></span></a><span class="sy1">&lt;</span>decltype<span class="br0">(</span><span class="kw2">false</span> <span class="sy4">?</span> memPtr <span class="sy4">:</span> nullptr<span class="br0">)</span>, <span class="kw4">int</span><span class="sy2">*</span>A<span class="sy4">::</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
<span class="co1">// a.*memPtr is now just pointer to int and nullptr also becomes pointer to int</span>
static_assert<span class="br0">(</span><a href="../types/is_same.html"><span class="kw592">std::<span class="me2">is_same_v</span></span></a><span class="sy1">&lt;</span>decltype<span class="br0">(</span><span class="kw2">false</span> <span class="sy4">?</span> a.<span class="sy2">*</span>memPtr <span class="sy4">:</span> nullptr<span class="br0">)</span>, <span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">)</span><span class="sy4">;</span></pre></div></div>
<ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><a href="#cite_ref-1">↑</a></span> <span class="reference-text"> Such conditional operator was commonly used in C++11 <a href="constexpr.html" title="cpp/language/constexpr">constexpr programming</a> prior to C++14.</span>
</li>
<li id="cite_note-2"><span class="mw-cite-backlink"><a href="#cite_ref-2">↑</a></span> <span class="reference-text">Member access<span class="t-rev-inl t-since-cxx11"><span>, whether a conversion function is deleted</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> and whether an operand is a bit-field are ignored.</span>
</li>
</ol>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tbody><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">This section is incomplete<br>Reason: any chance to make this more readable without losing the fine point? At the very least, a one-line micro-example for each bullet point would help tremendously </td></tr></tbody></table>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;action=edit&amp;section=4" title="Edit section: Overloads">edit</a>]</span> <span class="mw-headline" id="Overloads">Overloads</span></h4>
<p>For every pair of promoted arithmetic types <code>L</code> and <code>R</code> and for every type <code>P</code>, where <code>P</code> is a pointer, pointer-to-member, or scoped enumeration type, the following function signatures participate in overload resolution:
</p>
<table class="t-dcl-begin"><tbody>
<tr class="t-dcl">
<td class="t-dcl-nopad"> <div><span class="mw-geshi cpp source-cpp">LR operator<span class="sy4">?:</span><span class="br0">(</span><span class="kw4">bool</span>, L, R<span class="br0">)</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td class="t-dcl-nopad">  </td>
</tr>
<tr class="t-dcl">
<td class="t-dcl-nopad"> <div><span class="mw-geshi cpp source-cpp">P operator<span class="sy4">?:</span><span class="br0">(</span><span class="kw4">bool</span>, P, P<span class="br0">)</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td class="t-dcl-nopad">  </td>
</tr>
<tr class="t-dcl-sep"><td></td><td></td><td></td></tr>
</tbody></table>
<p>where LR is the result of <a href="usual_arithmetic_conversions.html" title="cpp/language/usual arithmetic conversions">usual arithmetic conversions</a> performed on <code>L</code> and <code>R</code>.
</p><p>The operator “<code>?:</code>” cannot be overloaded, these function signatures only exist for the purpose of overload resolution.
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<p>The result type of a conditional operator is also accessible as the binary type trait <span class="t-lc"><a href="../types/common_type.html" title="cpp/types/common type">std::common_type</a></span>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
&nbsp;
<span class="kw1">struct</span> Node
<span class="br0">{</span>
    Node<span class="sy2">*</span> next<span class="sy4">;</span>
    <span class="kw4">int</span> data<span class="sy4">;</span>
&nbsp;
    <span class="co1">// deep-copying copy constructor</span>
    Node<span class="br0">(</span><span class="kw4">const</span> Node<span class="sy3">&amp;</span> other<span class="br0">)</span>
        <span class="sy4">:</span> next<span class="br0">(</span>other.<span class="me1">next</span> <span class="sy4">?</span> new Node<span class="br0">(</span><span class="sy2">*</span>other.<span class="me1">next</span><span class="br0">)</span> <span class="sy4">:</span> <a href="../types/NULL.html"><span class="kw110">NULL</span></a><span class="br0">)</span>
        , data<span class="br0">(</span>other.<span class="me1">data</span><span class="br0">)</span>
    <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    Node<span class="br0">(</span><span class="kw4">int</span> d<span class="br0">)</span> <span class="sy4">:</span> next<span class="br0">(</span><a href="../types/NULL.html"><span class="kw110">NULL</span></a><span class="br0">)</span>, data<span class="br0">(</span>d<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    ~Node<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span> delete next<span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>   
    <span class="co1">// simple rvalue example</span>
    <span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">1</span> <span class="sy1">&gt;</span> <span class="nu0">2</span> <span class="sy4">?</span> <span class="nu0">10</span> <span class="sy4">:</span> <span class="nu0">11</span><span class="sy4">;</span>  <span class="co1">// 1 &gt; 2 is false, so n = 11</span>
&nbsp;
    <span class="co1">// simple lvalue example</span>
    <span class="kw4">int</span> m <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span> 
    <span class="br0">(</span>n <span class="sy1">==</span> m <span class="sy4">?</span> n <span class="sy4">:</span> m<span class="br0">)</span> <span class="sy1">=</span> <span class="nu0">7</span><span class="sy4">;</span> <span class="co1">// n == m is false, so m = 7</span>
&nbsp;
    <span class="co1">//output the result</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"n = "</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\n</span>m = "</span> <span class="sy1">&lt;&lt;</span> m<span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">n = 11
m = 7</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;action=edit&amp;section=5" title="Edit section: Standard library">edit</a>]</span> <span class="mw-headline" id="Standard_library">Standard library</span></h3>
<p>Many classes in the standard library overload <code>operator()</code> to be used as function objects.
</p>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../memory/default_delete.html" title="cpp/memory/default delete"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   deletes the object or array  <br> <span class="t-mark">(public member function of <code>std::default_delete&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/memory/default_delete/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/plus.html" title="cpp/utility/functional/plus"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the sum of two arguments <br> <span class="t-mark">(public member function of <code>std::plus&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/plus/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/minus.html" title="cpp/utility/functional/minus"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the difference between two arguments <br> <span class="t-mark">(public member function of <code>std::minus&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/minus/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/multiplies.html" title="cpp/utility/functional/multiplies"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the product of two arguments <br> <span class="t-mark">(public member function of <code>std::multiplies&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/multiplies/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/divides.html" title="cpp/utility/functional/divides"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the result of the division of the first argument by the second argument  <br> <span class="t-mark">(public member function of <code>std::divides&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/divides/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/modulus.html" title="cpp/utility/functional/modulus"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the remainder from the division of the first argument by the second argument  <br> <span class="t-mark">(public member function of <code>std::modulus&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/modulus/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/negate.html" title="cpp/utility/functional/negate"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the negation of the argument <br> <span class="t-mark">(public member function of <code>std::negate&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/negate/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/equal_to.html" title="cpp/utility/functional/equal to"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   checks if the arguments are equal <br> <span class="t-mark">(public member function of <code>std::equal_to&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/equal_to/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/not_equal_to.html" title="cpp/utility/functional/not equal to"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   checks if the arguments are not equal <br> <span class="t-mark">(public member function of <code>std::not_equal_to&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/not_equal_to/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/greater.html" title="cpp/utility/functional/greater"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   checks if the first argument is greater than the second <br> <span class="t-mark">(public member function of <code>std::greater&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/greater/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/less.html" title="cpp/utility/functional/less"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   checks if the first argument is less than the second <br> <span class="t-mark">(public member function of <code>std::less&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/less/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/greater_equal.html" title="cpp/utility/functional/greater equal"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   checks if the first argument is greater than or equal to the second <br> <span class="t-mark">(public member function of <code>std::greater_equal&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/greater_equal/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/less_equal.html" title="cpp/utility/functional/less equal"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   checks if the first argument is less than or equal to the second <br> <span class="t-mark">(public member function of <code>std::less_equal&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/less_equal/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/logical_and.html" title="cpp/utility/functional/logical and"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the logical AND of the two arguments <br> <span class="t-mark">(public member function of <code>std::logical_and&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/logical_and/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/logical_or.html" title="cpp/utility/functional/logical or"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the logical OR of the two arguments <br> <span class="t-mark">(public member function of <code>std::logical_or&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/logical_or/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/logical_not.html" title="cpp/utility/functional/logical not"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the logical NOT of the argument <br> <span class="t-mark">(public member function of <code>std::logical_not&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/logical_not/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/bit_and.html" title="cpp/utility/functional/bit and"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the result of bitwise AND of two arguments <br> <span class="t-mark">(public member function of <code>std::bit_and&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/bit_and/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/bit_or.html" title="cpp/utility/functional/bit or"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the result of bitwise OR of two arguments <br> <span class="t-mark">(public member function of <code>std::bit_or&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/bit_or/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/bit_xor.html" title="cpp/utility/functional/bit xor"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the result of bitwise XOR of two arguments <br> <span class="t-mark">(public member function of <code>std::bit_xor&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/bit_xor/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/unary_negate.html" title="cpp/utility/functional/unary negate"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the logical complement of the result of a call to the stored predicate <br> <span class="t-mark">(public member function of <code>std::unary_negate&lt;Predicate&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/unary_negate/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/binary_negate.html" title="cpp/utility/functional/binary negate"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   returns the logical complement of the result of a call to the stored predicate <br> <span class="t-mark">(public member function of <code>std::binary_negate&lt;Predicate&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/binary_negate/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/reference_wrapper/operator().html" title="cpp/utility/functional/reference wrapper/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>  calls the stored function <br> <span class="t-mark">(public member function of <code>std::reference_wrapper&lt;T&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/reference_wrapper/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/function/operator().html" title="cpp/utility/functional/function/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>  invokes the target <br> <span class="t-mark">(public member function of <code>std::function&lt;R(Args...)&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/function/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/move_only_function/operator().html" title="cpp/utility/functional/move only function/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>  invokes the target <br> <span class="t-mark">(public member function of <code>std::move_only_function</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/move_only_function/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../utility/functional/copyable_function/operator().html" title="cpp/utility/functional/copyable function/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>  invokes the target <br> <span class="t-mark">(public member function of <code>std::copyable_function</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/utility/functional/copyable_function/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://en.cppreference.com/mwiki/index.php?title=cpp/coroutine/coroutine_handle/operator()&amp;action=edit&amp;redlink=1" class="new" title="cpp/coroutine/coroutine handle/operator()（页面不存在）"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   resumes execution of the coroutine <br> <span class="t-mark">(public member function of <code>std::coroutine_handle&lt;Promise&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/coroutine/coroutine_handle/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../locale/locale/operator().html" title="cpp/locale/locale/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>  lexicographically compares two strings using this locale's collate facet <br> <span class="t-mark">(public member function of <code>std::locale</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/locale/locale/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../container/map/value_compare.html" title="cpp/container/map/value compare"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   compares two values of type <code>value_type</code> <br> <span class="t-mark">(public member function of <code>std::map&lt;Key,T,Compare,Allocator&gt;::value_compare</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/value_compare/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../container/multimap/value_compare.html" title="cpp/container/multimap/value compare"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>   compares two values of type <code>value_type</code> <br> <span class="t-mark">(public member function of <code>std::multimap&lt;Key,T,Compare,Allocator&gt;::value_compare</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/container/value_compare/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../thread/packaged_task/operator().html" title="cpp/thread/packaged task/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>  executes the function <br> <span class="t-mark">(public member function of <code>std::packaged_task&lt;R(Args...)&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/thread/packaged_task/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../numeric/random/linear_congruential_engine/operator().html" title="cpp/numeric/random/linear congruential engine/operator()"> <span class="t-lines"><span>operator()</span></span></a></div></div>
</td>
<td>  advances the engine's state and returns the generated value <br> <span class="t-mark">(public member function of <code>std::linear_congruential_engine&lt;UIntType,a,c,m&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/engine/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../numeric/random/uniform_int_distribution/operator().html" title="cpp/numeric/random/uniform int distribution/operator()"> <span class="t-lines"><span>operator()</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>  generates the next random number in the distribution <br> <span class="t-mark">(public member function of <code>std::uniform_int_distribution&lt;IntType&gt;</code>)</span> <span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/numeric/random/distribution/dsc_operator()&amp;action=edit">[edit]</a></span>
</td></tr>
</tbody></table>
<p>The comma operator is not overloaded by any class in the standard library. The boost library uses <span class="t-c"><span class="mw-geshi cpp source-cpp">operator,</span></span> in <a rel="nofollow" class="external text" href="https://www.boost.org/doc/libs/release/libs/assign/doc/index.html#intro">boost.assign</a>, <a rel="nofollow" class="external text" href="https://www.boost.org/doc/libs/release/libs/spirit/doc/html/index.html">boost.spirit</a>, and other libraries. The database access library <a rel="nofollow" class="external text" href="https://soci.sourceforge.net/doc.html">SOCI</a> also overloads <span class="t-c"><span class="mw-geshi cpp source-cpp">operator,</span></span>.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;action=edit&amp;section=6" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/446.html">CWG 446</a>
</td>
<td>C++98
</td>
<td>it was unspecified whether a temporary is created for an<br>lvalue-to-rvalue conversion on the conditional operator
</td>
<td>always creates a temporary if<br>the operator returns a class rvalue
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/462.html">CWG 462</a>
</td>
<td>C++98
</td>
<td>if the second operand of a comma operator is a temporary,<br>it was unspecified whether its lifetime will be extended when<br>the result of the comma expression is bound to a reference
</td>
<td>the result of the comma expression<br>is the temporary in this case<br>(hence its lifetime is extended)
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/587.html">CWG 587</a>
</td>
<td>C++98
</td>
<td>when the second and third operands of a conditional<br>operator are lvalues of the same type except for<br>cv-qualification, the result was an lvalue if these<br>operands have class types or an rvalue otherwise
</td>
<td>the result is always<br>an lvalue in this case
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1029.html">CWG 1029</a>
</td>
<td>C++98
</td>
<td>the type of a destructor call was unspecified
</td>
<td>specified as <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1550.html">CWG 1550</a>
</td>
<td>C++98
</td>
<td>parenthesized <span class="mw-geshi cpp source-cpp"><span class="kw1">throw</span></span> expressions were not allowed in<br>conditional expressions if other operand is non-<span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>
</td>
<td>accepted
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1560.html">CWG 1560</a>
</td>
<td>C++98
</td>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> operand of conditional operators caused<br>gratuitous lvalue-to-rvalue conversion on the<br>other operand, always resulting in rvalue
</td>
<td>a conditional expression<br>with a <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> can be lvalue
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1642.html">CWG 1642</a>
</td>
<td>C++98
</td>
<td>the expression <span class="t-spar">function</span> in a function call<br>expression could be a function pointer lvalue
</td>
<td>not allowed
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1805.html">CWG 1805</a>
</td>
<td>C++98
</td>
<td>when determining the target type for the implicit conversion<br>sequence, the way to convert <span class="t-c"><span class="mw-geshi cpp source-cpp">Y</span></span> to <span class="t-c"><span class="mw-geshi cpp source-cpp">Z</span></span> was unclear
</td>
<td>made clear
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1895.html">CWG 1895</a>
</td>
<td>C++98<br>C++11
</td>
<td>unclear if deleted (C++11) or inaccessible (C++98)<br>conversion function prevents conversion in<br>conditional expressions, and conversions from base<br>class to derived class prvalue were not considered
</td>
<td>handled like<br>overload resolution
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1932.html">CWG 1932</a>
</td>
<td>C++98
</td>
<td>same-type bit-fields were missing in conditional expressions
</td>
<td>handled by underlying types
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2226.html">CWG 2226</a>
</td>
<td>C++11
</td>
<td>when determining the target type of the other<br>operand of a conditional operator, reference could<br>not bind to an xvalue if that operand is an lvalue
</td>
<td>allowed
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2283.html">CWG 2283</a>
</td>
<td>C++17
</td>
<td>the type completeness requirement for function call<br>operator was accidently removed by <a rel="nofollow" class="external text" href="https://wg21.link/P0135R1">P0135R1</a>
</td>
<td>restored the requirement
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2321.html">CWG 2321</a>
</td>
<td>C++98
</td>
<td>when determining the target type of the other operand<br>of a conditional operator, a derived class type could<br>not be converted to a less cv-qualified base class type
</td>
<td>allowed to convert to the base<br>class type with the cv-qualification<br>from the derived class operand
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2715.html">CWG 2715</a>
</td>
<td>C++98
</td>
<td>the initialization and destruction of each<br>parameter would occur within the context of<br>the calling function, which might not exist<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">[1]</a></sup>
</td>
<td>occurs within the context of<br>the enclosing full-expression
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2850.html">CWG 2850</a>
</td>
<td>C++98
</td>
<td>the destruction order of parameters was unclear
</td>
<td>made clear
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2865.html">CWG 2865</a>
</td>
<td>C++98
</td>
<td>if <code>TX</code> and <code>TY</code> are the same class type and <code>TX</code> is<br>more cv-qualified than <code>TY</code>, an implicit conversion<br>sequence could still be formed from a prvalue <span class="t-c"><span class="mw-geshi cpp source-cpp">Y</span></span>
</td>
<td>no conversion sequence<br>will be formed in this case
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2906.html">CWG 2906</a>
</td>
<td>C++98
</td>
<td>lvalue-to-rvalue conversions were unconditionally applied<br>in the rvalue result case for the conditional operator
</td>
<td>only applied in some cases
</td></tr></tbody></table>
<ol class="references">
<li id="cite_note-3"><span class="mw-cite-backlink"><a href="#cite_ref-3">↑</a></span> <span class="reference-text">For example, functions can be called in the initializer of a namespace-scope variable, there is no “calling function” in this context.</span>
</li>
</ol>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;action=edit&amp;section=7" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<p><a href="operator_precedence.html" title="cpp/language/operator precedence">Operator precedence</a><br>
<a href="operators.html" title="cpp/language/operators">Operator overloading</a>
</p>
<table class="wikitable">

<tbody><tr style="text-align:center">
<th colspan="7">Common operators
</th></tr>
<tr style="text-align:center">
<td><a href="operator_assignment.html" title="cpp/language/operator assignment">assignment</a>
</td>
<td><a href="operator_incdec.html" title="cpp/language/operator incdec">increment<br>decrement</a>
</td>
<td><a href="operator_arithmetic.html" title="cpp/language/operator arithmetic">arithmetic</a>
</td>
<td><a href="operator_logical.html" title="cpp/language/operator logical">logical</a>
</td>
<td><a href="operator_comparison.html" title="cpp/language/operator comparison">comparison</a>
</td>
<td><a href="operator_member_access.html" title="cpp/language/operator member access">member<br>access</a>
</td>
<td><strong class="selflink">other</strong>
</td></tr>
<tr style="text-align:center">
<td rowspan="3">
<p><span class="t-c"><span class="mw-geshi cpp source-cpp">a <span class="sy1">=</span> b<br>
a <span class="sy2">+</span><span class="sy1">=</span> b<br>
a <span class="sy2">-</span><span class="sy1">=</span> b<br>
a <span class="sy2">*</span><span class="sy1">=</span> b<br>
a <span class="sy2">/</span><span class="sy1">=</span> b<br>
a <span class="sy2">%</span><span class="sy1">=</span> b<br>
a <span class="sy3">&amp;</span><span class="sy1">=</span> b<br>
a <span class="sy3">|</span><span class="sy1">=</span> b<br>
a <span class="sy3">^</span><span class="sy1">=</span> b<br>
a <span class="sy1">&lt;&lt;=</span> b<br>
a <span class="sy1">&gt;&gt;=</span> b</span></span>
</p>
</td>
<td rowspan="3">
<p><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">++</span>a<br>
<span class="sy2">--</span>a<br>
a<span class="sy2">++</span><br>
a<span class="sy2">--</span></span></span>
</p>
</td>
<td rowspan="3">
<p><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy2">+</span>a<br>
<span class="sy2">-</span>a<br>
a <span class="sy2">+</span> b<br>
a <span class="sy2">-</span> b<br>
a <span class="sy2">*</span> b<br>
a <span class="sy2">/</span> b<br>
a <span class="sy2">%</span> b<br>
~a<br>
a <span class="sy3">&amp;</span> b<br>
a <span class="sy3">|</span> b<br>
a <span class="sy3">^</span> b<br>
a <span class="sy1">&lt;&lt;</span> b<br>
a <span class="sy1">&gt;&gt;</span> b</span></span>
</p>
</td>
<td rowspan="3">
<p><span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">!</span>a<br>
a <span class="sy3">&amp;&amp;</span> b<br>
a <span class="sy3">||</span> b</span></span>
</p>
</td>
<td rowspan="3">
<p><span class="t-c"><span class="mw-geshi cpp source-cpp">a <span class="sy1">==</span> b<br>
a <span class="sy3">!</span><span class="sy1">=</span> b<br>
a <span class="sy1">&lt;</span> b<br>
a <span class="sy1">&gt;</span> b<br>
a <span class="sy1">&lt;=</span> b<br>
a <span class="sy1">&gt;=</span> b<br>
a <span class="sy1">&lt;=&gt;</span> b</span></span>
</p>
</td>
<td rowspan="3">
<p><span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="br0">[</span>...<span class="br0">]</span><br>
<span class="sy2">*</span>a<br>
<span class="sy3">&amp;</span>a<br>
a<span class="sy2">-</span><span class="sy1">&gt;</span>b<br>
a.<span class="me1">b</span><br>
a<span class="sy2">-</span><span class="sy1">&gt;</span><span class="sy2">*</span>b<br>
a.<span class="sy2">*</span>b</span></span>
</p>
</td>
<td>function call<br><br><span class="t-c"><span class="mw-geshi cpp source-cpp">a<span class="br0">(</span>...<span class="br0">)</span></span></span>
</td></tr>
<tr style="text-align:center">
<td>comma<br><br><span class="t-c"><span class="mw-geshi cpp source-cpp">a, b</span></span>
</td></tr>
<tr style="text-align:center">
<td>conditional<br><br><span class="t-c"><span class="mw-geshi cpp source-cpp">a <span class="sy4">?</span> b <span class="sy4">:</span> c</span></span>
</td></tr>
<tr>
<th colspan="7">Special operators
</th></tr>
<tr>
<td colspan="7">
<p><a href="static_cast.html" title="cpp/language/static cast"><tt>static_cast</tt></a> converts one type to another related type<br>
<a href="dynamic_cast.html" title="cpp/language/dynamic cast"><tt>dynamic_cast</tt></a> converts within inheritance hierarchies<br>
<a href="const_cast.html" title="cpp/language/const cast"><tt>const_cast</tt></a> adds or removes <a href="cv.html" title="cpp/language/cv">cv</a>-qualifiers<br>
<a href="reinterpret_cast.html" title="cpp/language/reinterpret cast"><tt>reinterpret_cast</tt></a> converts type to unrelated type<br>
<a href="explicit_cast.html" title="cpp/language/explicit cast">C-style cast</a> converts one type to another by a mix of <span class="mw-geshi cpp source-cpp"><span class="kw1">static_cast</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw1">const_cast</span></span>, and <span class="mw-geshi cpp source-cpp"><span class="kw1">reinterpret_cast</span></span><br>
<a href="new.html" title="cpp/language/new"><tt>new</tt></a> creates objects with dynamic storage duration<br>
<a href="delete.html" title="cpp/language/delete"><tt>delete</tt></a> destructs objects previously created by the new expression and releases obtained memory area<br>
<a href="sizeof.html" title="cpp/language/sizeof"><tt>sizeof</tt></a> queries the size of a type<br>
<a href="sizeof...html" title="cpp/language/sizeof..."><tt>sizeof...</tt></a> queries the size of a <a href="pack.html" title="cpp/language/pack">pack</a> <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br>
<a href="typeid.html" title="cpp/language/typeid"><tt>typeid</tt></a> queries the type information of a type<br>
<a href="noexcept.html" title="cpp/language/noexcept"><tt>noexcept</tt></a> checks if an expression can throw an exception <span class="t-mark-rev t-since-cxx11">(since C++11)</span><br>
<a href="alignof.html" title="cpp/language/alignof"><tt>alignof</tt></a> queries alignment requirements of a type <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</p>
</td></tr></tbody></table>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see"><span><a href="https://en.cppreference.com/w/c/language/operator_other" title="c/language/operator other">C documentation</a></span> for <span class=""><span>Other operators</span></span></div>
</td></tr>

</tbody></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 15492/1000000
Preprocessor generated node count: 26577/1000000
Post‐expand include size: 382653/4194304 bytes
Template argument size: 85962/4194304 bytes
Highest expansion depth: 37/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:708-0!*!0!!en!*!* and timestamp 20250122092204 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;oldid=179794">https://en.cppreference.com/mwiki/index.php?title=cpp/language/operator_other&amp;oldid=179794</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="https://en.cppreference.com/w/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="https://en.cppreference.com/w/Category:Todo_with_reason" title="Category:Todo with reason">Todo with reason</a></li></ul></div></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 0.041 secs. -->
	




</body><!-- Cached 20250122092244 --><!-- Mirrored from en.cppreference.com/w/cpp/language/operator_other by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:33:52 GMT --></html>