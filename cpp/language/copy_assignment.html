<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/copy_assignment by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:36 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>Copy assignment operator</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_copy_assignment skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">Copy assignment operator</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>A copy assignment operator is a non-template <a href="member_functions.html" title="cpp/language/member functions">non-static member function</a> with the name <span class="mw-geshi cpp source-cpp">operator<span class="sy1">=</span></span> that can be called with an argument of the same class type and copies the content of the argument without mutating the argument.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Explanation"><span class="tocnumber">2</span> <span class="toctext">Explanation</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Implicitly-declared_copy_assignment_operator"><span class="tocnumber">3</span> <span class="toctext">Implicitly-declared copy assignment operator</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Implicitly-defined_copy_assignment_operator"><span class="tocnumber">4</span> <span class="toctext">Implicitly-defined copy assignment operator</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Deleted_copy_assignment_operator"><span class="tocnumber">5</span> <span class="toctext">Deleted copy assignment operator</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Trivial_copy_assignment_operator"><span class="tocnumber">6</span> <span class="toctext">Trivial copy assignment operator</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Eligible_copy_assignment_operator"><span class="tocnumber">7</span> <span class="toctext">Eligible copy assignment operator</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Notes"><span class="tocnumber">8</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Example"><span class="tocnumber">9</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Defect_reports"><span class="tocnumber">10</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#See_also"><span class="tocnumber">11</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=1" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span></h3>
<p>For the formal copy assignment operator syntax, see <a href="function.html" title="cpp/language/function">function declaration</a>. The syntax list below only demonstrates a subset of all valid copy assignment operator syntaxes.
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>);</b></code>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>)</b></code> <span class="t-spar">function-body</span>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list-no-default</span> ﻿<code><b>) = default;</b></code>
</td>
<td> (3)
</td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>) = delete;</b></code>
</td>
<td> (4)
</td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <span class="t-spar">class-name</span> ﻿<code><b>::</b></code><code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>)</b></code> <span class="t-spar">function-body</span>
</td>
<td> (5)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <span class="t-spar">class-name</span> ﻿<code><b>::</b></code><code><b>operator=(</b></code><span class="t-spar">parameter-list-no-default</span> ﻿<code><b>) = default;</b></code>
</td>
<td> (6)
</td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span>
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<table class="t-par-begin">


<tbody><tr class="t-par">
<td> <span class="t-spar">class-name</span>
</td>
<td> -
</td>
<td> the class whose copy assignment operator is being declared, the class type is given as <code>T</code> in the descriptions below
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">parameter-list</span>
</td>
<td> -
</td>
<td> a <a href="function.html#Parameter_list" title="cpp/language/function">parameter list</a> of only one parameter, which is of type <code>T</code>, <code>T&amp;</code>, <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T<span class="sy3">&amp;</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span> T<span class="sy3">&amp;</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">volatile</span> T<span class="sy3">&amp;</span></span>
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">parameter-list-no-default</span>
</td>
<td> -
</td>
<td> a <a href="function.html#Parameter_list" title="cpp/language/function">parameter list</a> of only one parameter, which is of type <code>T</code>, <code>T&amp;</code>, <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T<span class="sy3">&amp;</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span> T<span class="sy3">&amp;</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">volatile</span> T<span class="sy3">&amp;</span></span> and does not have a default argument
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">function-body</span>
</td>
<td> -
</td>
<td> the <a href="constructor.html" title="cpp/language/constructor">function body</a> of the copy assignment operator
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">return-type</span>
</td>
<td> -
</td>
<td> any type, but <code>T&amp;</code> is favored in order to allow chaining asssignments
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=2" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span></h3>
<div class="t-li1"><span class="t-li">1)</span> Declaration of a copy assignment operator inside of class definition.</div>
<div class="t-li1"><span class="t-li">2-4)</span> Definition of a copy assignment operator inside of class definition.</div>
<div class="t-li2"><span class="t-li">3)</span> The copy assignment operator is explicitly-defaulted.</div>
<div class="t-li2"><span class="t-li">4)</span> The copy assignment operator is deleted.</div>
<div class="t-li1"><span class="t-li">5,6)</span> Definition of a copy assignment operator outside of class definition (the class must contain a declaration <span class="t-v">(1)</span>).</div>
<div class="t-li2"><span class="t-li">6)</span> The copy assignment operator is explicitly-defaulted.</div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> X
<span class="br0">{</span>
    X<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>X<span class="sy3">&amp;</span> other<span class="br0">)</span><span class="sy4">;</span>     <span class="co1">// copy assignment operator</span>
    X operator<span class="sy1">=</span><span class="br0">(</span>X other<span class="br0">)</span><span class="sy4">;</span>       <span class="co1">// pass-by-value is allowed</span>
<span class="co1">//  X operator=(const X other); // Error: incorrect parameter type</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">union</span> Y
<span class="br0">{</span>
    <span class="co1">// copy assignment operators can have syntaxes not listed above,</span>
    <span class="co1">// as long as they follow the general function declaration syntax</span>
    <span class="co1">// and do not viloate the restrictions listed above</span>
    <span class="kw4">auto</span> operator<span class="sy1">=</span><span class="br0">(</span>Y<span class="sy3">&amp;</span> other<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> Y<span class="sy3">&amp;</span><span class="sy4">;</span>       <span class="co1">// OK: trailing return type</span>
    Y<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>this Y<span class="sy3">&amp;</span> self, Y<span class="sy3">&amp;</span> other<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: explicit object parameter</span>
<span class="co1">//  Y&amp; operator=(Y&amp;, int num = 1);        // Error: has other non-object parameters</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>The copy assignment operator is called whenever selected by <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>, e.g. when an object appears on the left side of an assignment expression.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=3" title="Edit section: Implicitly-declared copy assignment operator">edit</a>]</span> <span class="mw-headline" id="Implicitly-declared_copy_assignment_operator">Implicitly-declared copy assignment operator</span></h3>
<p>If no user-defined copy assignment operators are provided for a class type, the compiler will always declare one as an <span class="mw-geshi cpp source-cpp"><span class="kw1">inline</span> <span class="kw1">public</span></span> member of the class. This implicitly-declared copy assignment operator has the form <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="br0">)</span></span></span> if all of the following is true:
</p>
<ul><li> each direct base <code>B</code> of <code>T</code> has a copy assignment operator whose parameters are <code>B</code> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> B<span class="sy3">&amp;</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">volatile</span> B<span class="sy3">&amp;</span></span>;
</li><li> each non-static data member <code>M</code> of <code>T</code> of class type or array of class type has a copy assignment operator whose parameters are <code>M</code> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> M<span class="sy3">&amp;</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">volatile</span> M<span class="sy3">&amp;</span></span>.
</li></ul>
<p>Otherwise the implicitly-declared copy assignment operator is declared as <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span>T<span class="sy3">&amp;</span><span class="br0">)</span></span></span>.
</p><p>Due to these rules, the implicitly-declared copy assignment operator cannot bind to a <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span></span> lvalue argument.
</p><p>A class can have multiple copy assignment operators, e.g. both <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span>T<span class="sy3">&amp;</span><span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span>T<span class="br0">)</span></span></span>. <span class="t-rev-inl t-since-cxx11"><span>If some user-defined copy assignment operators are present, the user may still force the generation of the implicitly declared copy assignment operator with the keyword <span class="mw-geshi cpp source-cpp"><span class="kw1">default</span></span>.</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span>
</p><p>The implicitly-declared (or defaulted on its first declaration) copy assignment operator has an exception specification as described in <span class="t-rev-inl t-until-cxx17"><span><a href="except_spec.html" title="cpp/language/except spec">dynamic exception specification</a></span><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept specification</a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>
</p><p>Because the copy assignment operator is always declared for any class, the base class assignment operator is always hidden. If a <a href="using_declaration.html#In_class_definition" title="cpp/language/using declaration">using-declaration</a> is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=4" title="Edit section: Implicitly-defined copy assignment operator">edit</a>]</span> <span class="mw-headline" id="Implicitly-defined_copy_assignment_operator">Implicitly-defined copy assignment operator</span></h3>
<p>If the implicitly-declared copy assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if <a href="definition.html#ODR-use" title="cpp/language/definition">odr-used</a><span class="t-rev-inl t-since-cxx14"><span> or <a href="constant_expression.html#Functions_and_variables_needed_for_constant_evaluation" title="cpp/language/constant expression">needed for constant evaluation</a></span><span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>. For union types, the implicitly-defined copy assignment copies the object representation (as by <span class="t-lc"><a href="../string/byte/memmove.html" title="cpp/string/byte/memmove">std::memmove</a></span>). For non-union class types, the operator performs member-wise copy assignment of the object's direct bases and non-static data members, in their initialization order, using built-in assignment for the scalars, memberwise copy-assignment for arrays, and copy assignment operator for class types (called non-virtually).
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx14 t-until-cxx23"><td>
<p>The implicitly-defined copy assignment operator for a class <code>T</code> is <a href="constexpr.html" title="cpp/language/constexpr"><code>constexpr</code></a> if
</p>
<ul><li> <code>T</code> is a <a href="../named_req/LiteralType.html" title="cpp/named req/LiteralType">literal type</a>, and
</li><li> the assignment operator selected to copy each direct base class subobject is a constexpr function, and
</li><li> for each non-static data member of <code>T</code> that is of class type (or array thereof), the assignment operator selected to copy that member is a constexpr function.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span><br><span class="t-mark-rev t-until-cxx23">(until C++23)</span></td></tr>
<tr class="t-rev t-since-cxx23"><td>
<p>The implicitly-defined copy assignment operator for a class <code>T</code> is <a href="constexpr.html" title="cpp/language/constexpr"><code>constexpr</code></a>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td></tr>
</tbody></table>
<p><br>
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<p>The generation of the implicitly-defined copy assignment operator is deprecated if <code>T</code> has a user-declared destructor or user-declared copy constructor.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=5" title="Edit section: Deleted copy assignment operator">edit</a>]</span> <span class="mw-headline" id="Deleted_copy_assignment_operator">Deleted copy assignment operator</span></h3>
<p>An implicitly-declared<span class="t-rev-inl t-since-cxx11"><span> or explicitly-defaulted</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> copy assignment operator for class <code>T</code> is <span class="t-rev-inl t-until-cxx11"><span>undefined</span><span><span class="t-mark-rev t-until-cxx11">(until C++11)</span></span></span><span class="t-rev-inl t-since-cxx11"><span>defined as deleted</span><span><span class="t-mark-rev t-since-cxx11">(since C++11)</span></span></span> if any of the following conditions is satisfied:
</p>
<ul><li> <code>T</code> has a non-static data member of a const-qualified non-class type (or possibly multi-dimensional array thereof).
</li><li> <code>T</code> has a non-static data member of a reference type.
</li><li> <code>T</code> has a <a href="object.html#Potentially_constructed_subobject" title="cpp/language/object">potentially constructed subobject</a> of class type <code>M</code> (or possibly multi-dimensional array thereof) such that the overload resolution as applied to find <code>M</code>'s copy assignment operator
</li></ul>
<dl><dd><ul><li> does not result in a usable candidate, or
</li><li> in the case of the subobject being a <a href="union.html#Union-like_classes" title="cpp/language/union">variant member</a>, selects a non-trivial function.
</li></ul>
</dd></dl>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<p>The implicitly-declared copy assignment operator for class <code>T</code> is defined as deleted if <code>T</code> declares a <a href="move_constructor.html" title="cpp/language/move constructor">move constructor</a> or <a href="move_assignment.html" title="cpp/language/move assignment">move assignment operator</a>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=6" title="Edit section: Trivial copy assignment operator">edit</a>]</span> <span class="mw-headline" id="Trivial_copy_assignment_operator">Trivial copy assignment operator</span></h3>
<p>The copy assignment operator for class <code>T</code> is trivial if all of the following is true:
</p>
<ul><li> it is not user-provided (meaning, it is implicitly-defined or defaulted);
</li><li> <code>T</code> has no virtual member functions;
</li><li> <code>T</code> has no virtual base classes;
</li><li> the copy assignment operator selected for every direct base of <code>T</code> is trivial;
</li><li> the copy assignment operator selected for every non-static class type (or array of class type) member of <code>T</code> is trivial.
</li></ul>
<p>A trivial copy assignment operator makes a copy of the object representation as if by <span class="t-lc"><a href="../string/byte/memmove.html" title="cpp/string/byte/memmove">std::memmove</a></span>. All data types compatible with the C language (POD types) are trivially copy-assignable.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=7" title="Edit section: Eligible copy assignment operator">edit</a>]</span> <span class="mw-headline" id="Eligible_copy_assignment_operator">Eligible copy assignment operator</span></h3>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx11"><td>
<p>A copy assignment operator is eligible if it is either user-declared or both implicitly-declared and definable.
</p>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td></tr>
<tr class="t-rev t-since-cxx11 t-until-cxx20"><td>
<p>A copy assignment operator is eligible if it is not deleted.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span><br><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<p>A copy assignment operator is eligible if all following conditions are satisfied:
</p>
<ul><li> It is not deleted.
</li><li> Its <a href="constraints.html" title="cpp/language/constraints">associated constraints</a> (if any) are satisfied.
</li><li> No copy assignment operator whose associated constraints are satisfied is <a href="constraints.html#Partial_ordering_of_constraints" title="cpp/language/constraints">more constrained</a>.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</tbody></table>
<p>Triviality of eligible copy assignment operators determines whether the class is a <a href="../named_req/TriviallyCopyable.html" title="cpp/named req/TriviallyCopyable">trivially copyable type</a>.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=8" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<p>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an <a href="value_category.html" title="cpp/language/value category">rvalue</a> (either a <a href="value_category.html" title="cpp/language/value category">prvalue</a> such as a nameless temporary or an <a href="value_category.html" title="cpp/language/value category">xvalue</a> such as the result of <a href="../utility/move.html" title="cpp/utility/move"><tt>std::move</tt></a>), and selects the copy assignment if the argument is an <a href="value_category.html" title="cpp/language/value category">lvalue</a> (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.
</p><p>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined copy assignment operator (same applies to <a href="move_assignment.html" title="cpp/language/move assignment">move assignment</a>).
</p><p>See <a href="operators.html#Assignment_operator" title="cpp/language/operators">assignment operator overloading</a> for additional detail on the expected behavior of a user-defined copy-assignment operator.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=9" title="Edit section: Example">edit</a>]</span> <span class="mw-headline" id="Example">Example</span></h3>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;algorithm&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;memory&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
&nbsp;
<span class="kw1">struct</span> A
<span class="br0">{</span>
    <span class="kw4">int</span> n<span class="sy4">;</span>
    <a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a> s1<span class="sy4">;</span>
&nbsp;
    A<span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
    A<span class="br0">(</span>A <span class="kw4">const</span><span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span>
&nbsp;
    <span class="co1">// user-defined copy assignment (copy-and-swap idiom)</span>
    A<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>A other<span class="br0">)</span>
    <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"copy assignment of A<span class="es1">\n</span>"</span><span class="sy4">;</span>
        <a href="../algorithm/swap.html"><span class="kw1611">std::<span class="me2">swap</span></span></a><span class="br0">(</span>n, other.<span class="me1">n</span><span class="br0">)</span><span class="sy4">;</span>
        <a href="../algorithm/swap.html"><span class="kw1611">std::<span class="me2">swap</span></span></a><span class="br0">(</span>s1, other.<span class="me1">s1</span><span class="br0">)</span><span class="sy4">;</span>
        <span class="kw1">return</span> <span class="sy2">*</span>this<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> B <span class="sy4">:</span> A
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a> s2<span class="sy4">;</span>
    <span class="co1">// implicitly-defined copy assignment</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> C
<span class="br0">{</span>
    <a href="../memory/unique_ptr.html"><span class="kw737">std::<span class="me2">unique_ptr</span></span></a><span class="sy1">&lt;</span><span class="kw4">int</span><span class="br0">[</span><span class="br0">]</span><span class="sy1">&gt;</span> data<span class="sy4">;</span>
    <a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a> size<span class="sy4">;</span>
&nbsp;
    <span class="co1">// user-defined copy assignment (non copy-and-swap idiom)</span>
    <span class="co1">// note: copy-and-swap would always reallocate resources</span>
    C<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> C<span class="sy3">&amp;</span> other<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="kw1">if</span> <span class="br0">(</span>this <span class="sy3">!</span><span class="sy1">=</span> <span class="sy3">&amp;</span>other<span class="br0">)</span> <span class="co1">// not a self-assignment</span>
        <span class="br0">{</span>
            <span class="kw1">if</span> <span class="br0">(</span>size <span class="sy3">!</span><span class="sy1">=</span> other.<span class="me1">size</span><span class="br0">)</span> <span class="co1">// resource cannot be reused</span>
            <span class="br0">{</span>
                data.<span class="me1">reset</span><span class="br0">(</span>new <span class="kw4">int</span><span class="br0">[</span>other.<span class="me1">size</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
                size <span class="sy1">=</span> other.<span class="me1">size</span><span class="sy4">;</span>
            <span class="br0">}</span>
            <a href="../algorithm/copy.html"><span class="kw1594">std::<span class="me2">copy</span></span></a><span class="br0">(</span><span class="sy3">&amp;</span>other.<span class="me1">data</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span>, <span class="sy3">&amp;</span>other.<span class="me1">data</span><span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span> <span class="sy2">+</span> size, <span class="sy3">&amp;</span>data<span class="br0">[</span><span class="nu0">0</span><span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
        <span class="br0">}</span>
        <span class="kw1">return</span> <span class="sy2">*</span>this<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    A a1, a2<span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"a1 = a2 calls "</span><span class="sy4">;</span>
    a1 <span class="sy1">=</span> a2<span class="sy4">;</span> <span class="co1">// user-defined copy assignment</span>
&nbsp;
    B b1, b2<span class="sy4">;</span>
    b2.<span class="me1">s1</span> <span class="sy1">=</span> <span class="st0">"foo"</span><span class="sy4">;</span>
    b2.<span class="me1">s2</span> <span class="sy1">=</span> <span class="st0">"bar"</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"b1 = b2 calls "</span><span class="sy4">;</span>
    b1 <span class="sy1">=</span> b2<span class="sy4">;</span> <span class="co1">// implicitly-defined copy assignment</span>
&nbsp;
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"b1.s1 = "</span> <span class="sy1">&lt;&lt;</span> b1.<span class="me1">s1</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"; b1.s2 = "</span> <span class="sy1">&lt;&lt;</span> b1.<span class="me1">s2</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">a1 = a2 calls copy assignment of A
b1 = b2 calls copy assignment of A
b1.s1 = foo; b1.s2 = bar</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=10" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1353.html">CWG 1353</a>
</td>
<td>C++98
</td>
<td>the conditions where implicitly-declared copy assignment operators<br>are undefined did not consider multi-dimensional array types
</td>
<td>consider these types
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2094.html">CWG 2094</a>
</td>
<td>C++11
</td>
<td>a volatile subobject made defaulted copy<br>assignment operators non-trivial (<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/496.html">CWG issue 496</a>)
</td>
<td>triviality not affected
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2171.html">CWG 2171</a>
</td>
<td>C++11
</td>
<td><span class="t-c"><span class="mw-geshi cpp source-cpp">operator<span class="sy1">=</span><span class="br0">(</span>X<span class="sy3">&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span></span></span> was non-trivial
</td>
<td>made trivial
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2180.html">CWG 2180</a>
</td>
<td>C++11
</td>
<td>a defaulted copy assignment operator for class <code>T</code> was not defined as deleted<br>if <code>T</code> is abstract and has non-copy-assignable direct virtual base classes
</td>
<td>the operator is defined<br>as deleted in this case
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2595.html">CWG 2595</a>
</td>
<td>C++20
</td>
<td>a copy assignment operator was not eligible if there<br>is another copy assignment operator which is more<br>constrained but does not satisfy its associated constraints
</td>
<td>it can be eligible<br>in this case
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;action=edit&amp;section=11" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<ul><li> <a href="converting_constructor.html" title="cpp/language/converting constructor">converting constructor</a>
</li><li> <a href="copy_constructor.html" title="cpp/language/copy constructor">copy constructor</a>
</li><li> <a href="copy_elision.html" title="cpp/language/copy elision">copy elision</a>
</li><li> <a href="default_constructor.html" title="cpp/language/default constructor">default constructor</a>
</li><li> <a href="destructor.html" title="cpp/language/destructor">destructor</a>
</li><li> <a href="explicit.html" title="cpp/language/explicit"><code>explicit</code></a>
</li><li> <a href="initialization.html" title="cpp/language/initialization">initialization</a>
<ul><li> <a href="aggregate_initialization.html" title="cpp/language/aggregate initialization">aggregate initialization</a>
</li><li> <a href="constant_initialization.html" title="cpp/language/constant initialization">constant initialization</a>
</li><li> <a href="copy_initialization.html" title="cpp/language/copy initialization">copy initialization</a>
</li><li> <a href="default_initialization.html" title="cpp/language/default initialization">default initialization</a>
</li><li> <a href="direct_initialization.html" title="cpp/language/direct initialization">direct initialization</a>
</li><li> <a href="constructor.html" title="cpp/language/initializer list" class="mw-redirect">initializer list</a>
</li><li> <a href="list_initialization.html" title="cpp/language/list initialization">list initialization</a>
</li><li> <a href="reference_initialization.html" title="cpp/language/reference initialization">reference initialization</a>
</li><li> <a href="value_initialization.html" title="cpp/language/value initialization">value initialization</a>
</li><li> <a href="zero_initialization.html" title="cpp/language/zero initialization">zero initialization</a>
</li></ul>
</li><li> <a href="move_assignment.html" title="cpp/language/move assignment">move assignment</a>
</li><li> <a href="move_constructor.html" title="cpp/language/move constructor">move constructor</a>
</li><li> <a href="new.html" title="cpp/language/new"><code>new</code></a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor visited node count: 5305/1000000
Preprocessor generated node count: 12136/1000000
Post‐expand include size: 167196/4194304 bytes
Template argument size: 31125/4194304 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9136-0!*!0!!en!*!* and timestamp 20250103104726 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;oldid=169520">https://en.cppreference.com/mwiki/index.php?title=cpp/language/copy_assignment&amp;oldid=169520</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 3.215 secs. -->
	




</body><!-- Cached 20250103104726 --><!-- Mirrored from en.cppreference.com/w/cpp/language/copy_assignment by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:36 GMT --></html>