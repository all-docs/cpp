<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/pointer by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:49 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>Pointer declaration</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_pointer skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">Pointer declaration</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>Declares a variable of a pointer or pointer-to-member type.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Pointers"><span class="tocnumber">2</span> <span class="toctext">Pointers</span></a>
<ul>
<li class="toclevel-2 tocsection-3"><a href="#Pointers_to_objects"><span class="tocnumber">2.1</span> <span class="toctext">Pointers to objects</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Pointers_to_void"><span class="tocnumber">2.2</span> <span class="toctext">Pointers to <span><span>void</span></span></span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Pointers_to_functions"><span class="tocnumber">2.3</span> <span class="toctext">Pointers to functions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-6"><a href="#Pointers_to_members"><span class="tocnumber">3</span> <span class="toctext">Pointers to members</span></a>
<ul>
<li class="toclevel-2 tocsection-7"><a href="#Pointers_to_data_members"><span class="tocnumber">3.1</span> <span class="toctext">Pointers to data members</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Pointers_to_member_functions"><span class="tocnumber">3.2</span> <span class="toctext">Pointers to member functions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-9"><a href="#Null_pointers"><span class="tocnumber">4</span> <span class="toctext">Null pointers</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Invalid_pointers"><span class="tocnumber">5</span> <span class="toctext">Invalid pointers</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Constness"><span class="tocnumber">6</span> <span class="toctext">Constness</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Composite_pointer_type"><span class="tocnumber">7</span> <span class="toctext">Composite pointer type</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Defect_reports"><span class="tocnumber">8</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#See_also"><span class="tocnumber">9</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=1" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span></h3>
<p>A pointer declaration is any simple declaration whose <a href="declarations.html" title="cpp/language/declarations">declarator</a> has the form
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <code><b>*</b></code> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">declarator</span>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">nested-name-specifier</span> <code><b>*</b></code> <span class="t-spar">attr</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">cv</span> ﻿<span class="t-mark">(optional)</span> <span class="t-spar">declarator</span>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<div class="t-li1"><span class="t-li">1)</span> <b>Pointer declarator</b>: the declaration <span class="t-c"><span class="mw-geshi cpp source-cpp">S<span class="sy2">*</span> D<span class="sy4">;</span></span></span> declares <span class="t-c"><span class="mw-geshi cpp source-cpp">D</span></span> as a pointer to the type determined by the <a href="declarations.html#Specifiers" title="cpp/language/declarations">declaration specifier sequence</a> <code>S</code>.</div>
<div class="t-li1"><span class="t-li">2)</span> <b>Pointer to member declarator</b>: the declaration <span class="t-c"><span class="mw-geshi cpp source-cpp">S C<span class="sy4">::</span><span class="sy2">*</span> D<span class="sy4">;</span></span></span> declares <span class="t-c"><span class="mw-geshi cpp source-cpp">D</span></span> as a pointer to non-static member of <code>C</code> of type determined by the declaration specifier sequence <code>S</code>.</div>
<table class="t-par-begin">


<tbody><tr class="t-par">
<td> <span class="t-spar">nested-name-specifier</span>
</td>
<td> -
</td>
<td> a <a href="identifiers.html#Qualified_identifiers" title="cpp/language/identifiers">sequence of names and scope resolution operators <code><b>::</b></code></a>
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">attr</span>
</td>
<td> -
</td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> a list of <a href="attributes.html" title="cpp/language/attributes">attributes</a>
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">cv</span>
</td>
<td> -
</td>
<td> const/volatile qualification which apply to the pointer that is being declared (not to the pointed-to type, whose qualifications are part of declaration specifier sequence)
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">declarator</span>
</td>
<td> -
</td>
<td> any <a href="declarations.html" title="cpp/language/declarations">declarator</a> other than a reference declarator (there are no pointers to references). It can be another pointer declarator (pointer to pointers are allowed)
</td></tr></tbody></table>
<p>There are no pointers to <a href="reference.html" title="cpp/language/reference">references</a> and there are no pointers to <a href="bit_field.html" title="cpp/language/bit field">bit-fields</a>. 
Typically, mentions of "pointers" without elaboration do not include pointers to (non-static) members.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=2" title="Edit section: Pointers">edit</a>]</span> <span class="mw-headline" id="Pointers">Pointers</span></h3>
<p>Every value of pointer type is one of the following:
</p>
<ul><li> a <i>pointer to an object or function</i> (in which case the pointer is said to <i>point to</i> the object or function), or
</li><li> a <i>pointer past the end of an object</i>, or
</li><li> the <i><a href="#Null_pointers">null pointer value</a></i> for that type, or
</li><li> an <i><a href="#Invalid_pointers">invalid pointer value</a></i>.
</li></ul>
<p>A pointer that points to an object <i>represents the address</i> of the first byte in memory occupied by the object. A pointer past the end of an object <i>represents the address</i> of the first byte in memory after the end of the storage occupied by the object.
</p><p>Note that two pointers that represent the same address may nonetheless have different values.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C
<span class="br0">{</span>
    <span class="kw4">int</span> x, y<span class="sy4">;</span>
<span class="br0">}</span> c<span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span><span class="sy2">*</span> px <span class="sy1">=</span> <span class="sy3">&amp;</span>c.<span class="me1">x</span><span class="sy4">;</span>   <span class="co1">// value of px is "pointer to c.x"</span>
<span class="kw4">int</span><span class="sy2">*</span> pxe<span class="sy1">=</span> px <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span> <span class="co1">// value of pxe is "pointer past the end of c.x"</span>
<span class="kw4">int</span><span class="sy2">*</span> py <span class="sy1">=</span> <span class="sy3">&amp;</span>c.<span class="me1">y</span><span class="sy4">;</span>   <span class="co1">// value of py is "pointer to c.y"</span>
&nbsp;
<a href="../error/assert.html"><span class="kw778">assert</span></a><span class="br0">(</span>pxe <span class="sy1">==</span> py<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// == tests if two pointers represent the same address</span>
                   <span class="co1">// may or may not fire</span>
&nbsp;
<span class="sy2">*</span>pxe <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> <span class="co1">// undefined behavior even if the assertion does not fire</span></pre></div></div>
<p>Indirection through an invalid pointer value and passing an invalid pointer value to a deallocation function have undefined behavior. Any other use of an invalid pointer value has implementation-defined behavior. Some implementations might define that copying an invalid pointer value causes a system-generated runtime fault.
</p>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=3" title="Edit section: Pointers to objects">edit</a>]</span> <span class="mw-headline" id="Pointers_to_objects">Pointers to objects</span></h4>
<p>A pointer to object can be initialized with the return value of the <a href="operator_member_access.html" title="cpp/language/operator member access">address-of operator</a> applied to any expression of object type, including another pointer type:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> np <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span>          <span class="co1">// pointer to int</span>
<span class="kw4">int</span><span class="sy2">*</span> <span class="kw4">const</span><span class="sy2">*</span> npp <span class="sy1">=</span> <span class="sy3">&amp;</span>np<span class="sy4">;</span> <span class="co1">// non-const pointer to const pointer to non-const int</span>
&nbsp;
<span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>ap<span class="br0">)</span><span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>a<span class="sy4">;</span>     <span class="co1">// pointer to array of int</span>
&nbsp;
<span class="kw1">struct</span> S <span class="br0">{</span> <span class="kw4">int</span> n<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
S s <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> sp <span class="sy1">=</span> <span class="sy3">&amp;</span>s.<span class="me1">n</span><span class="sy4">;</span>        <span class="co1">// pointer to the int that is a member of s</span></pre></div></div>
<p>Pointers may appear as operands to the built-in indirection operator (unary <span class="t-c"><span class="mw-geshi cpp source-cpp">operator<span class="sy2">*</span></span></span>), which returns the <a href="value_category.html#lvalue" title="cpp/language/value category">lvalue expression</a> identifying the pointed-to object:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span>     <span class="co1">// pointer to n</span>
<span class="kw4">int</span><span class="sy3">&amp;</span> r <span class="sy1">=</span> <span class="sy2">*</span>p<span class="sy4">;</span>     <span class="co1">// reference is bound to the lvalue expression that identifies n</span>
r <span class="sy1">=</span> <span class="nu0">7</span><span class="sy4">;</span>           <span class="co1">// stores the int 7 in n</span>
<a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="sy2">*</span>p<span class="sy4">;</span> <span class="co1">// lvalue-to-rvalue implicit conversion reads the value from n</span></pre></div></div>
<p>Pointers to class objects may also appear as the left-hand operands of the member access operators <a href="operator_member_access.html#Built-in_member_access_operators" title="cpp/language/operator member access"><code>operator-&gt;</code></a> and <a href="operator_member_access.html#Built-in_pointer-to-member_access_operators" title="cpp/language/operator member access"><code>operator-&gt;*</code></a>.
</p><p>Because of the <a href="implicit_conversion.html" title="cpp/language/implicit cast" class="mw-redirect">array-to-pointer</a> implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">2</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p1 <span class="sy1">=</span> a<span class="sy4">;</span> <span class="co1">// pointer to the first element a[0] (an int) of the array a</span>
&nbsp;
<span class="kw4">int</span> b<span class="br0">[</span><span class="nu0">6</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p2<span class="br0">)</span><span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">8</span><span class="br0">]</span> <span class="sy1">=</span> b<span class="sy4">;</span> <span class="co1">// pointer to the first element b[0] of the array b,</span>
                     <span class="co1">// which is an array of 3 arrays of 8 ints</span></pre></div></div>
<p>Because of the <a href="implicit_conversion.html" title="cpp/language/implicit cast" class="mw-redirect">derived-to-base</a> implicit conversion for pointers, pointer to a base class can be initialized with the address of a derived class:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
Derived d<span class="sy4">;</span>
Base<span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>d<span class="sy4">;</span></pre></div></div>
<p>If <code>Derived</code> is <a href="object.html#Polymorphic_objects" title="cpp/language/object">polymorphic</a>, such a pointer may be used to make <a href="virtual.html" title="cpp/language/virtual">virtual function calls</a>.
</p><p>Certain <a href="operator_arithmetic.html#Additive_operators" title="cpp/language/operator arithmetic">addition, subtraction</a>, <a href="operator_incdec.html" title="cpp/language/operator incdec">increment, and decrement</a> operators are defined for pointers to elements of arrays: such pointers satisfy the <a href="../named_req/RandomAccessIterator.html" title="cpp/named req/RandomAccessIterator"><span style="font-family: Georgia, 'DejaVu Serif', serif; font-style:italic">LegacyRandomAccessIterator</span></a> requirements and allow the C++ library <a href="../algorithm.html" title="cpp/algorithm">algorithms</a> to work with raw arrays.
</p><p><a href="operator_comparison.html#Pointer_comparison_operators" title="cpp/language/operator comparison">Comparison operators</a> are defined for pointers to objects in some situations: two pointers that represent the same address compare equal, two null pointer values compare equal, pointers to elements of the same array compare the same as the array indices of those elements, and pointers to non-static data members with the same <a href="access.html" title="cpp/language/access">member access</a> compare in order of declaration of those members.
</p><p>Many implementations also provide <a href="https://en.wikipedia.org/wiki/Total_order#Strict_total_order" class="extiw" title="enwiki:Total order">strict total ordering</a> of pointers of random origin, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of <span class="t-lc"><a href="../utility/functional/less.html" title="cpp/utility/functional/less">std::less</a></span> for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as <span class="t-lc"><a href="../container/set.html" title="cpp/container/set">std::set</a></span> or <span class="t-lc"><a href="../container/map.html" title="cpp/container/map">std::map</a></span>.
</p><p><span id="Pointers_to_void"></span>
</p>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=4" title="Edit section: Pointers to void">edit</a>]</span> <span class="mw-headline" id="Pointers_to_void">Pointers to <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span></span></h4>
<p>Pointer to object of any type can be <a href="implicit_conversion.html" title="cpp/language/implicit cast" class="mw-redirect">implicitly converted</a> to pointer to (possibly <a href="cv.html" title="cpp/language/cv">cv-qualified</a>) <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>; the pointer value is unchanged. The reverse conversion, which requires <a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> or <a href="explicit_cast.html" title="cpp/language/explicit cast">explicit cast</a>, yields the original pointer value:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p1 <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span>
<span class="kw4">void</span><span class="sy2">*</span> pv <span class="sy1">=</span> p1<span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p2 <span class="sy1">=</span> <span class="kw1">static_cast</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>pv<span class="br0">)</span><span class="sy4">;</span>
<a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="sy2">*</span>p2 <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1</span></pre></div></div>
<p>If the original pointer is pointing to a base class subobject within an object of some polymorphic type, <a href="dynamic_cast.html" title="cpp/language/dynamic cast"><code>dynamic_cast</code></a> may be used to obtain a <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span> that is pointing at the complete object of the most derived type.
</p><p>Pointers to <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> have the same size, representation and alignment as pointers to <span class="mw-geshi cpp source-cpp"><span class="kw4">char</span></span>.
</p><p>Pointers to <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> are used to pass objects of unknown type, which is common in C interfaces: <span class="t-lc"><a href="../memory/c/malloc.html" title="cpp/memory/c/malloc">std::malloc</a></span> returns <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span>, <span class="t-lc"><a href="../algorithm/qsort.html" title="cpp/algorithm/qsort">std::qsort</a></span> expects a user-provided callback that accepts two <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">void</span><span class="sy2">*</span></span> arguments. <a rel="nofollow" class="external text" href="https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html"><code>pthread_create</code></a> expects a user-provided callback that accepts and returns <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span><span class="sy2">*</span></span>. In all cases, it is the caller's responsibility to cast the pointer to the correct type before use.
</p>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=5" title="Edit section: Pointers to functions">edit</a>]</span> <span class="mw-headline" id="Pointers_to_functions">Pointers to functions</span></h4>
<p>A pointer to function can be initialized with an address of a non-member function or a static member function. Because of the <a href="implicit_conversion.html" title="cpp/language/implicit cast" class="mw-redirect">function-to-pointer</a> implicit conversion, the address-of operator is optional:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>p1<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>f<span class="sy4">;</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>p2<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// same as &amp;f</span></pre></div></div>
<p>Unlike functions or references to functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, etc.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">void</span> <span class="br0">(</span>a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// Error: array of functions</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy3">&amp;</span>a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// Error: array of references</span>
<span class="kw4">void</span> <span class="br0">(</span><span class="sy2">*</span>a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: array of pointers to functions</span></pre></div></div>
<p>Note: declarations involving pointers to functions can often be simplified with type aliases:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">using</span> F <span class="sy1">=</span> <span class="kw4">void</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// named type alias to simplify declarations</span>
F a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy4">;</span>  <span class="co1">// Error: array of functions</span>
F<span class="sy3">&amp;</span> a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// Error: array of references</span>
F<span class="sy2">*</span> a<span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy4">;</span> <span class="co1">// OK: array of pointers to functions</span></pre></div></div>
<p>A pointer to function can be used as the left-hand operand of the <a href="operator_other.html" title="cpp/language/operator other">function call operator</a>, this invokes the pointed-to function:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span>
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
    <span class="kw1">return</span> n <span class="sy2">*</span> n<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span>
    <span class="kw4">int</span> x <span class="sy1">=</span> p<span class="br0">(</span><span class="nu0">7</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Dereferencing a function pointer yields the lvalue identifying the pointed-to function:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span>  <span class="co1">// pointer p is pointing to f</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy3">&amp;</span>r<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy2">*</span>p<span class="sy4">;</span> <span class="co1">// the lvalue that identifies f is bound to a reference</span>
r<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>             <span class="co1">// function f invoked through lvalue reference</span>
<span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>          <span class="co1">// function f invoked through the function lvalue</span>
p<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>             <span class="co1">// function f invoked directly through the pointer</span></pre></div></div>
<p>A pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see <a href="overloaded_address.html" title="cpp/language/overloaded address">address of an overloaded function</a> for more detail):
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> T<span class="sy1">&gt;</span>
T f<span class="br0">(</span>T n<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> n<span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw4">double</span> f<span class="br0">(</span><span class="kw4">double</span> n<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> n<span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// instantiates and selects f&lt;int&gt;</span>
<span class="br0">}</span></pre></div></div>
<p><a href="operator_comparison.html#Pointer_comparison_operators" title="cpp/language/operator comparison">Equality comparison operators</a> are defined for pointers to functions (they compare equal if pointing to the same function).
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=6" title="Edit section: Pointers to members">edit</a>]</span> <span class="mw-headline" id="Pointers_to_members">Pointers to members</span></h3>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=7" title="Edit section: Pointers to data members">edit</a>]</span> <span class="mw-headline" id="Pointers_to_data_members">Pointers to data members</span></h4>
<p>A pointer to non-static member object <code>m</code> which is a member of class <code>C</code> can be initialized with the expression <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;</span>C<span class="sy4">::</span><span class="me2">m</span></span></span> exactly. Expressions such as <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;</span><span class="br0">(</span>C<span class="sy4">::</span><span class="me2">m</span><span class="br0">)</span></span></span> or <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;</span>m</span></span> inside <code>C</code>'s member function do not form pointers to members.
</p><p>Such a pointer may be used as the right-hand operand of the <a href="operator_member_access.html" title="cpp/language/operator member access">pointer-to-member access operators</a> <span class="t-c"><span class="mw-geshi cpp source-cpp">operator.<span class="sy2">*</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">operator<span class="sy2">-</span><span class="sy1">&gt;</span><span class="sy2">*</span></span></span>:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C <span class="br0">{</span> <span class="kw4">int</span> m<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> C<span class="sy4">::</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>C<span class="sy4">::</span><span class="me2">m</span><span class="sy4">;</span>          <span class="co1">// pointer to data member m of class C</span>
    C c <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">7</span><span class="br0">}</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> c.<span class="sy2">*</span>p <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>   <span class="co1">// prints 7</span>
    C<span class="sy2">*</span> cp <span class="sy1">=</span> <span class="sy3">&amp;</span>c<span class="sy4">;</span>
    cp<span class="sy2">-</span><span class="sy1">&gt;</span>m <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> cp<span class="sy2">-</span><span class="sy1">&gt;</span><span class="sy2">*</span>p <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 10</span>
<span class="br0">}</span></pre></div></div>
<p>Pointer to data member of an accessible unambiguous non-virtual base class can be <a href="implicit_conversion.html" title="cpp/language/implicit cast" class="mw-redirect">implicitly converted</a> to pointer to the same data member of a derived class:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span> <span class="kw4">int</span> m<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> Base<span class="sy4">::</span><span class="sy2">*</span> bp <span class="sy1">=</span> <span class="sy3">&amp;</span>Base<span class="sy4">::</span><span class="me2">m</span><span class="sy4">;</span>
    <span class="kw4">int</span> Derived<span class="sy4">::</span><span class="sy2">*</span> dp <span class="sy1">=</span> bp<span class="sy4">;</span>
    Derived d<span class="sy4">;</span>
    d.<span class="me1">m</span> <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> d.<span class="sy2">*</span>dp <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span> <span class="sy1">&lt;&lt;</span> d.<span class="sy2">*</span>bp <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1 1</span>
<span class="br0">}</span></pre></div></div>
<p>Conversion in the opposite direction, from a pointer to data member of a derived class to a pointer to data member of an unambiguous non-virtual base class, is allowed with <a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> and <a href="explicit_cast.html" title="cpp/language/explicit cast">explicit cast</a>, even if the base class does not have that member (but the most-derived class does, when the pointer is used for access):
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span> <span class="kw4">int</span> m<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> Derived<span class="sy4">::</span><span class="sy2">*</span> dp <span class="sy1">=</span> <span class="sy3">&amp;</span>Derived<span class="sy4">::</span><span class="me2">m</span><span class="sy4">;</span>
    <span class="kw4">int</span> Base<span class="sy4">::</span><span class="sy2">*</span> bp <span class="sy1">=</span> <span class="kw1">static_cast</span><span class="sy1">&lt;</span><span class="kw4">int</span> Base<span class="sy4">::</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>dp<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    Derived d<span class="sy4">;</span>
    d.<span class="me1">m</span> <span class="sy1">=</span> <span class="nu0">7</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> d.<span class="sy2">*</span>bp <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// okay: prints 7</span>
&nbsp;
    Base b<span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> b.<span class="sy2">*</span>bp <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// undefined behavior</span>
<span class="br0">}</span></pre></div></div>
<p>The pointed-to type of a pointer-to-member may be a pointer-to-member itself: pointers to members can be multilevel, and can be cv-qualified differently at every level. Mixed multi-level combinations of pointers and pointers-to-members are also allowed:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> A
<span class="br0">{</span>
    <span class="kw4">int</span> m<span class="sy4">;</span>
    <span class="co1">// const pointer to non-const member</span>
    <span class="kw4">int</span> A<span class="sy4">::</span><span class="sy2">*</span> <span class="kw4">const</span> p<span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// non-const pointer to data member which is a const pointer to non-const member</span>
    <span class="kw4">int</span> A<span class="sy4">::</span><span class="sy2">*</span> <span class="kw4">const</span> A<span class="sy4">::</span><span class="sy2">*</span> p1 <span class="sy1">=</span> <span class="sy3">&amp;</span>A<span class="sy4">::</span><span class="me2">p</span><span class="sy4">;</span>
&nbsp;
    <span class="kw4">const</span> A a <span class="sy1">=</span> <span class="br0">{</span><span class="nu0">1</span>, <span class="sy3">&amp;</span>A<span class="sy4">::</span><span class="me2">m</span><span class="br0">}</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> a.<span class="sy2">*</span><span class="br0">(</span>a.<span class="sy2">*</span>p1<span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1</span>
&nbsp;
    <span class="co1">// regular non-const pointer to a const pointer-to-member</span>
    <span class="kw4">int</span> A<span class="sy4">::</span><span class="sy2">*</span> <span class="kw4">const</span><span class="sy2">*</span> p2 <span class="sy1">=</span> <span class="sy3">&amp;</span>a.<span class="me1">p</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> a.<span class="sy2">**</span>p2 <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="co1">// prints 1</span>
<span class="br0">}</span></pre></div></div>
<h4><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=8" title="Edit section: Pointers to member functions">edit</a>]</span> <span class="mw-headline" id="Pointers_to_member_functions">Pointers to member functions</span></h4>
<p>A pointer to non-static member function <span class="t-c"><span class="mw-geshi cpp source-cpp">f</span></span> which is a member of class <code>C</code> can be initialized with the expression <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;</span>C<span class="sy4">::</span><span class="me2">f</span></span></span> exactly. Expressions such as <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;</span><span class="br0">(</span>C<span class="sy4">::</span><span class="me2">f</span><span class="br0">)</span></span></span> or <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="sy3">&amp;</span>f</span></span> inside <code>C</code>'s member function do not form pointers to member functions.
</p><p>Such a pointer may be used as the right-hand operand of the <a href="operator_member_access.html" title="cpp/language/operator member access">pointer-to-member access operators</a> <span class="t-c"><span class="mw-geshi cpp source-cpp">operator.<span class="sy2">*</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">operator<span class="sy2">-</span><span class="sy1">&gt;</span><span class="sy2">*</span></span></span>. The <a href="value_category.html#Pending_member_function_call" title="cpp/language/value category">resulting expression</a> can be used only as the left-hand operand of a function-call operator:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> C
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">void</span> <span class="br0">(</span>C<span class="sy4">::</span><span class="sy2">*</span> p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>C<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span> <span class="co1">// pointer to member function f of class C</span>
    C c<span class="sy4">;</span>
    <span class="br0">(</span>c.<span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>                  <span class="co1">// prints 1</span>
    C<span class="sy2">*</span> cp <span class="sy1">=</span> <span class="sy3">&amp;</span>c<span class="sy4">;</span>
    <span class="br0">(</span>cp<span class="sy2">-</span><span class="sy1">&gt;</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>                <span class="co1">// prints 2</span>
<span class="br0">}</span></pre></div></div>
<p><br>
Pointer to member function of a base class can be <a href="implicit_conversion.html" title="cpp/language/implicit cast" class="mw-redirect">implicitly converted</a> to pointer to the same member function of a derived class:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">void</span> <span class="br0">(</span>Base<span class="sy4">::</span><span class="sy2">*</span> bp<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>Base<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span>
    <span class="kw4">void</span> <span class="br0">(</span>Derived<span class="sy4">::</span><span class="sy2">*</span> dp<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> bp<span class="sy4">;</span>
    Derived d<span class="sy4">;</span>
    <span class="br0">(</span>d.<span class="sy2">*</span>dp<span class="br0">)</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="br0">(</span>d.<span class="sy2">*</span>bp<span class="br0">)</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Conversion in the opposite direction, from a pointer to member function of a derived class to a pointer to member function of an unambiguous non-virtual base class, is allowed with <a href="static_cast.html" title="cpp/language/static cast"><code>static_cast</code></a> and <a href="explicit_cast.html" title="cpp/language/explicit cast">explicit cast</a>, even if the base class does not have that member function (but the most-derived class does, when the pointer is used for access):
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> Base <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
<span class="kw1">struct</span> Derived <span class="sy4">:</span> Base
<span class="br0">{</span>
    <span class="kw4">void</span> f<span class="br0">(</span><span class="kw4">int</span> n<span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span> <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">void</span> <span class="br0">(</span>Derived<span class="sy4">::</span><span class="sy2">*</span> dp<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="sy3">&amp;</span>Derived<span class="sy4">::</span><span class="me2">f</span><span class="sy4">;</span>
    <span class="kw4">void</span> <span class="br0">(</span>Base<span class="sy4">::</span><span class="sy2">*</span> bp<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">static_cast</span><span class="sy1">&lt;</span><span class="kw4">void</span> <span class="br0">(</span>Base<span class="sy4">::</span><span class="sy2">*</span><span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy1">&gt;</span><span class="br0">(</span>dp<span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    Derived d<span class="sy4">;</span>
    <span class="br0">(</span>d.<span class="sy2">*</span>bp<span class="br0">)</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// okay: prints 1</span>
&nbsp;
    Base b<span class="sy4">;</span>
    <span class="br0">(</span>b.<span class="sy2">*</span>bp<span class="br0">)</span><span class="br0">(</span><span class="nu0">2</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// undefined behavior</span>
<span class="br0">}</span></pre></div></div>
<p>Pointers to member functions may be used as callbacks or as function objects, often after applying <span class="t-lc"><a href="../utility/functional/mem_fn.html" title="cpp/utility/functional/mem fn">std::mem_fn</a></span> or <span class="t-lc"><a href="../utility/functional/bind.html" title="cpp/utility/functional/bind">std::bind</a></span>:
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;algorithm&gt;</span>
<span class="co2">#include &lt;cstddef&gt;</span>
<span class="co2">#include &lt;functional&gt;</span>
<span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../container/vector.html"><span class="kw1277">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a><span class="sy1">&gt;</span> v <span class="sy1">=</span> <span class="br0">{</span><span class="st0">"a"</span>, <span class="st0">"ab"</span>, <span class="st0">"abc"</span><span class="br0">}</span><span class="sy4">;</span>
    <a href="../container/vector.html"><span class="kw1277">std::<span class="me2">vector</span></span></a><span class="sy1">&lt;</span><a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a><span class="sy1">&gt;</span> l<span class="sy4">;</span>
    transform<span class="br0">(</span>v.<span class="me1">begin</span><span class="br0">(</span><span class="br0">)</span>, v.<span class="me1">end</span><span class="br0">(</span><span class="br0">)</span>, <a href="../iterator/back_inserter.html"><span class="kw670">std::<span class="me2">back_inserter</span></span></a><span class="br0">(</span>l<span class="br0">)</span>,
              <a href="../utility/functional/mem_fn.html"><span class="kw1064">std::<span class="me2">mem_fn</span></span></a><span class="br0">(</span><span class="sy3">&amp;</span>std<span class="sy4">::</span><span class="me2">string</span><span class="sy4">::</span><span class="me2">size</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">for</span> <span class="br0">(</span><a href="../types/size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a> n <span class="sy4">:</span> l<span class="br0">)</span>
        <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">' '</span><span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">'<span class="es1">\n</span>'</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">1 2 3</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=9" title="Edit section: Null pointers">edit</a>]</span> <span class="mw-headline" id="Null_pointers">Null pointers</span></h3>
<p>Pointers of every type have a special value known as <i>null pointer value</i> of that type. A pointer whose value is null does not point to an object or a function (the behavior of dereferencing a null pointer is undefined), and compares equal to all pointers of the same type whose value is also <i>null</i>.
</p><p>A <i>null pointer constant</i> can be used to initialize a pointer to null or to assign the null value to an existing pointer, it is one of the following values:
</p>
<ul><li> An integer literal with value zero.
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<ul><li> A prvalue of type <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span> (usually <span class="t-c"><span class="mw-geshi cpp source-cpp">nullptr</span></span>).
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<p>The macro <span class="t-lc"><a href="../types/NULL.html" title="cpp/types/NULL">NULL</a></span> can also be used, it expands to an implementation-defined null pointer constant.
</p><p><a href="zero_initialization.html" title="cpp/language/zero initialization">Zero-initialization</a> and <a href="value_initialization.html" title="cpp/language/value initialization">value-initialization</a> also initialize pointers to their null values.
</p><p>Null pointers can be used to indicate the absence of an object (e.g. <a href="../utility/functional/function/target.html" title="cpp/utility/functional/function/target"><tt>std::function::target()</tt></a>), or as other error condition indicators (e.g. <a href="dynamic_cast.html" title="cpp/language/dynamic cast">dynamic_cast</a>). In general, a function that receives a pointer argument almost always needs to check if the value is null and handle that case differently (for example, the <a href="delete.html" title="cpp/language/delete">delete expression</a> does nothing when a null pointer is passed).
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=10" title="Edit section: Invalid pointers">edit</a>]</span> <span class="mw-headline" id="Invalid_pointers">Invalid pointers</span></h3>
<p>A pointer value <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span> is <i>valid in the context of</i> an evaluation <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> if one of the following condition is satisfied:
</p>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span> is a null pointer value.
</li><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span> it is a pointer to or past the end of an object <span class="t-c"><span class="mw-geshi cpp source-cpp">o</span></span>, and <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> is in the duration of the region of storage for <span class="t-c"><span class="mw-geshi cpp source-cpp">o</span></span>.
</li></ul>
<p>If a pointer value <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span> is used in an evaluation <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span>, and <span class="t-c"><span class="mw-geshi cpp source-cpp">p</span></span> is not valid in the context of <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span>, then:
</p>
<ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">e</span></span> is an <a href="operator_member_access.html#Built-in_indirection_operator" title="cpp/language/operator member access">indirection</a> or an invocation of a <a href="../memory/new/operator_delete.html" title="cpp/memory/new/operator delete">deallocation function</a>, the behavior is undefined.
</li><li> Otherwise, the behavior is implementation-defined.
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw4">int</span><span class="sy2">*</span> f<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw4">int</span> obj<span class="sy4">;</span>
    <span class="kw4">int</span><span class="sy2">*</span> local_ptr <span class="sy1">=</span> new <span class="br0">(</span><span class="sy3">&amp;</span>obj<span class="br0">)</span> <span class="kw4">int</span><span class="sy4">;</span>
&nbsp;
    <span class="sy2">*</span>local_ptr <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span> <span class="co1">// OK, the evaluation “*local_ptr” is</span>
                    <span class="co1">// in the storage duration of “obj”</span>
&nbsp;
    <span class="kw1">return</span> local_ptr<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="kw4">int</span><span class="sy2">*</span> ptr <span class="sy1">=</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// the storage duration of “obj” is expired,</span>
                 <span class="co1">// therefore “ptr” is an invalid pointer in the following contexts</span>
&nbsp;
<span class="kw4">int</span><span class="sy2">*</span> copy <span class="sy1">=</span> ptr<span class="sy4">;</span> <span class="co1">// implementation-defined behavior</span>
<span class="sy2">*</span>ptr <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>        <span class="co1">// undefined behavior: indirection of an invalid pointer</span>
delete ptr<span class="sy4">;</span>      <span class="co1">// undefined behavior: deallocating storage from an invalid pointer</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=11" title="Edit section: Constness">edit</a>]</span> <span class="mw-headline" id="Constness">Constness</span></h3>
<ul><li> If <span class="t-spar">cv</span> appears before <code><b>*</b></code> in the pointer declaration, it is part of the declaration specifier sequence and applies to the pointed-to object.
</li><li> If <span class="t-spar">cv</span> appears after <code><b>*</b></code> in the pointer declaration, it is part of the <a href="declarations.html#Declarators" title="cpp/language/declarations">declarator</a> and applies to the pointer that's being declared.
</li></ul>
<table class="wikitable">

<tbody><tr>
<th>Syntax</th>
<th>meaning
</th></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T<span class="sy2">*</span></span></td>
<td>pointer to constant object
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp">T <span class="kw4">const</span><span class="sy2">*</span></span></td>
<td>pointer to constant object
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp">T<span class="sy2">*</span> <span class="kw4">const</span></span></td>
<td>constant pointer to object
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T<span class="sy2">*</span> <span class="kw4">const</span></span></td>
<td>constant pointer to constant object
</td></tr>
<tr>
<td><span class="mw-geshi cpp source-cpp">T <span class="kw4">const</span><span class="sy2">*</span> <span class="kw4">const</span></span></td>
<td>constant pointer to constant object
</td></tr>
</tbody></table>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// pc is a non-const pointer to const int</span>
<span class="co1">// cpc is a const pointer to const int</span>
<span class="co1">// ppc is a non-const pointer to non-const pointer to const int</span>
<span class="kw4">const</span> <span class="kw4">int</span> ci <span class="sy1">=</span> <span class="nu0">10</span>, <span class="sy2">*</span>pc <span class="sy1">=</span> <span class="sy3">&amp;</span>ci, <span class="sy2">*</span><span class="kw4">const</span> cpc <span class="sy1">=</span> pc, <span class="sy2">**</span>ppc<span class="sy4">;</span>
<span class="co1">// p is a non-const pointer to non-const int</span>
<span class="co1">// cp is a const pointer to non-const int</span>
<span class="kw4">int</span> i, <span class="sy2">*</span>p, <span class="sy2">*</span><span class="kw4">const</span> cp <span class="sy1">=</span> <span class="sy3">&amp;</span>i<span class="sy4">;</span>
&nbsp;
i <span class="sy1">=</span> ci<span class="sy4">;</span>    <span class="co1">// okay: value of const int copied into non-const int</span>
<span class="sy2">*</span>cp <span class="sy1">=</span> ci<span class="sy4">;</span>  <span class="co1">// okay: non-const int (pointed-to by const pointer) can be changed</span>
pc<span class="sy2">++</span><span class="sy4">;</span>      <span class="co1">// okay: non-const pointer (to const int) can be changed</span>
pc <span class="sy1">=</span> cpc<span class="sy4">;</span>  <span class="co1">// okay: non-const pointer (to const int) can be changed</span>
pc <span class="sy1">=</span> p<span class="sy4">;</span>    <span class="co1">// okay: non-const pointer (to const int) can be changed</span>
ppc <span class="sy1">=</span> <span class="sy3">&amp;</span>pc<span class="sy4">;</span> <span class="co1">// okay: address of pointer to const int is pointer to pointer to const int</span>
&nbsp;
ci <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>    <span class="co1">// error: const int cannot be changed</span>
ci<span class="sy2">++</span><span class="sy4">;</span>      <span class="co1">// error: const int cannot be changed</span>
<span class="sy2">*</span>pc <span class="sy1">=</span> <span class="nu0">2</span><span class="sy4">;</span>   <span class="co1">// error: pointed-to const int cannot be changed</span>
cp <span class="sy1">=</span> <span class="sy3">&amp;</span>ci<span class="sy4">;</span>  <span class="co1">// error: const pointer (to non-const int) cannot be changed</span>
cpc<span class="sy2">++</span><span class="sy4">;</span>     <span class="co1">// error: const pointer (to const int) cannot be changed</span>
p <span class="sy1">=</span> pc<span class="sy4">;</span>    <span class="co1">// error: pointer to non-const int cannot point to const int</span>
ppc <span class="sy1">=</span> <span class="sy3">&amp;</span>p<span class="sy4">;</span>  <span class="co1">// error: pointer to pointer to const int cannot point to</span>
           <span class="co1">// pointer to non-const int</span></pre></div></div>
<p>In general, implicit conversion from one multi-level pointer to another follows the rules described in <a href="implicit_conversion.html#Qualification_conversions" title="cpp/language/implicit cast" class="mw-redirect">qualification conversions</a>.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=12" title="Edit section: Composite pointer type">edit</a>]</span> <span class="mw-headline" id="Composite_pointer_type">Composite pointer type</span></h3>
<p>When an operand of a <a href="operator_comparison.html" title="cpp/language/operator comparison">comparison operator</a> or any of the second and third operands of a <a href="operator_other.html#Conditional_operator" title="cpp/language/operator other">conditional operator</a> is a pointer or pointer-to-member, a composite pointer type is determined to be the common type of these operands.
</p><p>Given two operands <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> having types <code>T1</code> and <code>T2</code>, respectively, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> can only have a composite pointer type if any of the following conditions are satisfied:
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx14"><td>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> are both pointers.
</li><li> One of <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> is a pointer and the other operand is a null pointer constant.
</li></ul>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx11"><td>
<ul><li> <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> are both null pointer constants, and at least one of <code>T1</code> and <code>T2</code> is a non-integral type.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
</td>
<td><span class="t-mark-rev t-until-cxx14">(until C++14)</span></td></tr>
<tr class="t-rev t-since-cxx14"><td>
<ul><li> At least one of <code>T1</code> and <code>T2</code> is a pointer type, pointer-to-member type or <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span>.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span></td></tr>
</tbody></table>
<p>The <i>composite pointer type</i> <code>C</code> of <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> is determined as follows:
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-until-cxx11"><td>
<ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> is a <a href="#Null_pointers">null pointer constant</a>, <code>C</code> is <code>T2</code>.
</li><li> Otherwise, if <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> is a null pointer constant, <code>C</code> is <code>T1</code>.
</li></ul>
</td>
<td><span class="t-mark-rev t-until-cxx11">(until C++11)</span></td></tr>
<tr class="t-rev t-since-cxx11"><td>
<ul><li> If <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> are both <a href="#Null_pointers">null pointer constants</a>, <code>C</code> is <span class="t-lc"><a href="../types/nullptr_t.html" title="cpp/types/nullptr t">std::nullptr_t</a></span>.
</li><li> Otherwise, if <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> is a null pointer constant, <code>C</code> is <code>T2</code>.
</li><li> Otherwise, if <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> is a null pointer constant, <code>C</code> is <code>T1</code>.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx11">(since C++11)</span></td></tr>
</tbody></table>
<ul><li> Otherwise, if all following conditions are satisfied:
</li></ul>
<dl><dd><ul><li> <code>T1</code> or <code>T2</code> is “pointer to <i>cv1</i> <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>”.
</li><li> The other type is “pointer to <i>cv2</i> <code>T</code>”, where <code>T</code> is an <a href="type.html" title="cpp/language/type">object type</a> or <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>.
</li></ul>
</dd><dd> <code>C</code> is “pointer to <i>cv12</i> <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span>”, where <i>cv12</i> is the union of <i>cv1</i> and <i>cv2</i>.
</dd></dl>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<ul><li> Otherwise, if all following conditions are satisfied:
</li></ul>
<dl><dd><ul><li> <code>T1</code> or <code>T2</code> is “pointer to function type <code>F1</code>”.
</li><li> The other type is “pointer to noexcept function type <code>F2</code>”.
</li><li> <code>F1</code> and <code>F2</code> are the same except noexcept.
</li></ul>
</dd><dd> <code>C</code> is “pointer to <code>F1</code>”.
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<ul><li> Otherwise, if all following conditions are satisfied:
</li></ul>
<dl><dd><ul><li> <code>T1</code> is “pointer to <code>C1</code>”.
</li><li> <code>T2</code> is “pointer to <code>C2</code>”.
</li><li> One of <code>C1</code> and <code>C2</code> is <a href="reference_initialization.html#Definitions" title="cpp/language/reference initialization">reference-related</a> to the other.
</li></ul>
</dd><dd> <code>C</code> is
<ul><li> the <a href="implicit_conversion.html#Combining_cv-qualifications" title="cpp/language/implicit conversion">qualification-combined type</a> of <code>T1</code> and <code>T2</code>, if <code>C1</code> is reference-related to <code>C2</code>, or
</li><li> the qualification-combined type of <code>T2</code> and <code>T1</code>, if <code>C2</code> is reference-related to <code>C1</code>.
</li></ul>
</dd></dl>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx17"><td>
<ul><li> Otherwise, if all following conditions are satisfied:
</li></ul>
<dl><dd><ul><li> <code>T1</code> or <code>T2</code> is “pointer to member of <code>C1</code> of function type <code>F1</code>”.
</li><li> The other type is “pointer to member of <code>C2</code> of noexcept function type <code>F2</code>”.
</li><li> One of <code>C1</code> and <code>C2</code> is reference-related to the other.
</li><li> <code>F1</code> and <code>F2</code> are the same except noexcept.
</li></ul>
</dd><dd> <code>C</code> is
<ul><li> “pointer to member of <code>C2</code> of type <code>F1</code>”, if <code>C1</code> is reference-related to <code>C2</code>, or
</li><li> “pointer to member of <code>C1</code> of type <code>F1</code>”, if <code>C2</code> is reference-related to <code>C1</code>.
</li></ul>
</dd></dl>
</td>
<td><span class="t-mark-rev t-since-cxx17">(since C++17)</span></td></tr>
</tbody></table>
<ul><li> Otherwise, if all following conditions are satisfied:
</li></ul>
<dl><dd><ul><li> <code>T1</code> is “pointer to member of <code>C1</code> of non-function type <code>M1</code>”.
</li><li> <code>T2</code> is “pointer to member of <code>C2</code> of non-function type <code>M2</code>”
</li><li> <code>M1</code> and <code>M2</code> are the same except top-level cv-qualifications.
</li><li> One of <code>C1</code> and <code>C2</code> is reference-related to the other.
</li></ul>
</dd><dd> <code>C</code> is
<ul><li> the qualification-combined type of <code>T2</code> and <code>T1</code>, if <code>C1</code> is reference-related to <code>C2</code>, or
</li><li> the qualification-combined type of <code>T1</code> and <code>T2</code>, if <code>C2</code> is reference-related to <code>C1</code>.
</li></ul>
</dd></dl>
<ul><li> Otherwise, if <code>T1</code> and <code>T2</code> are <a href="implicit_conversion.html#Similar_types" title="cpp/language/implicit conversion">similar types</a>, <code>C</code> is the qualification-combined type of <code>T1</code> and <code>T2</code>.
</li><li> Otherwise, <span class="t-c"><span class="mw-geshi cpp source-cpp">p1</span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">p2</span></span> do not have a composite pointer type, a program that necessitates the determination of <code>C</code> such a type is ill-formed.
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">using</span> p <span class="sy1">=</span> <span class="kw4">void</span><span class="sy2">*</span><span class="sy4">;</span>
<span class="kw1">using</span> q <span class="sy1">=</span> <span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span><span class="sy4">;</span>
<span class="co1">// The determination of the composite pointer type of “p” and “q”</span>
<span class="co1">// falls into the [“pointer to cv1 void” and “pointer to cv2 T”] case:</span>
<span class="co1">// cv1 = empty, cv2 = const, cv12 = const</span>
<span class="co1">// substitute “cv12 = const” into “pointer to cv12 void”:</span>
<span class="co1">// the composite pointer type is “const void*”</span>
&nbsp;
<span class="kw1">using</span> pi <span class="sy1">=</span> <span class="kw4">int</span><span class="sy2">**</span><span class="sy4">;</span>
<span class="kw1">using</span> pci <span class="sy1">=</span> <span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">**</span><span class="sy4">;</span>
<span class="co1">// The determination of the composite pointer type of “pi” and “pci”</span>
<span class="co1">// falls into the [pointers to similar types “C1” and “C2”] case:</span>
<span class="co1">// C1 = int*, C2 = const int*</span>
<span class="co1">// they are reference-related types (in both direction) because they are similar</span>
<span class="co1">// the composite pointer type is the qualification-combined type</span>
<span class="co1">// of “p1” and “pc1” (or that of “pci” and “pi”): “const void* const *”</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=13" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/73.html">CWG 73</a>
</td>
<td>C++98
</td>
<td>a pointer to an object never compares equal<br>to a pointer to one past the end of an array
</td>
<td>for non-null and non-function pointers,<br>compare the addresses they represent
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/903.html">CWG 903</a>
</td>
<td>C++98
</td>
<td>any integral constant expression that<br>evaluates to 0 was a null pointer constant
</td>
<td>limited to integer<br>literals with value 0
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1438.html">CWG 1438</a>
</td>
<td>C++98
</td>
<td>the behavior of using an invalid pointer<br>value in any way was undefined
</td>
<td>behaviors other than indirection and<br>passing to deallocation functions<br>are implementation-defined
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1512.html">CWG 1512</a><br>(<a rel="nofollow" class="external text" href="https://wg21.link/N3624">N3624</a>)
</td>
<td>C++98
</td>
<td>the rule of composite pointer type was incomplete, and thus<br>did not allow comparison between <span class="mw-geshi cpp source-cpp"><span class="kw4">int</span><span class="sy2">**</span></span> and <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">**</span></span>
</td>
<td>made complete
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2206.html">CWG 2206</a>
</td>
<td>C++98
</td>
<td>a pointer to <span class="mw-geshi cpp source-cpp"><span class="kw4">void</span></span> and a pointer to<br>function had a composite pointer type
</td>
<td>they do not have such a type
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2381.html">CWG 2381</a>
</td>
<td>C++17
</td>
<td>function pointer conversions were not allowed<br>when determining the composite pointer type
</td>
<td>allowed
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2822.html">CWG 2822</a>
</td>
<td>C++98
</td>
<td>reaching the end of the duration of a region<br>of storage could invalidate pointer values
</td>
<td>pointer validity is based<br>on the evaluation context
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;action=edit&amp;section=14" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td colspan="2"> <div class="t-dsc-see"><span><a href="https://en.cppreference.com/w/c/language/pointer" title="c/language/pointer">C documentation</a></span> for <span class=""><span>Pointer declaration</span></span></div>
</td></tr>

</tbody></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 8163/1000000
Preprocessor generated node count: 16305/1000000
Post‐expand include size: 209989/4194304 bytes
Template argument size: 41833/4194304 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:5596-0!*!0!!en!*!* and timestamp 20250108211043 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;oldid=172368">https://en.cppreference.com/mwiki/index.php?title=cpp/language/pointer&amp;oldid=172368</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 20.471 secs. -->
	




</body><!-- Cached 20250108211043 --><!-- Mirrored from en.cppreference.com/w/cpp/language/pointer by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:49 GMT --></html>