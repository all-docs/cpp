<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/language/move_assignment by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:36 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>Move assignment operator</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_language_move_assignment skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading">Move assignment operator</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<p>A move assignment operator is a non-template <a href="member_functions.html" title="cpp/language/member functions">non-static member function</a> with the name <span class="mw-geshi cpp source-cpp">operator<span class="sy1">=</span></span> that can be called with an argument of the same class type and copies the content of the argument, possibly mutating the argument.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Syntax"><span class="tocnumber">1</span> <span class="toctext">Syntax</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Explanation"><span class="tocnumber">2</span> <span class="toctext">Explanation</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Implicitly-declared_move_assignment_operator"><span class="tocnumber">3</span> <span class="toctext">Implicitly-declared move assignment operator</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Implicitly-defined_move_assignment_operator"><span class="tocnumber">4</span> <span class="toctext">Implicitly-defined move assignment operator</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Deleted_move_assignment_operator"><span class="tocnumber">5</span> <span class="toctext">Deleted move assignment operator</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#Trivial_move_assignment_operator"><span class="tocnumber">6</span> <span class="toctext">Trivial move assignment operator</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#Eligible_move_assignment_operator"><span class="tocnumber">7</span> <span class="toctext">Eligible move assignment operator</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="#Notes"><span class="tocnumber">8</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-9"><a href="#Example"><span class="tocnumber">9</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-10"><a href="#Defect_reports"><span class="tocnumber">10</span> <span class="toctext">Defect reports</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#See_also"><span class="tocnumber">11</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=1" title="Edit section: Syntax">edit</a>]</span> <span class="mw-headline" id="Syntax">Syntax</span></h3>
<p>For the formal move assignment operator syntax, see <a href="function.html" title="cpp/language/function">function declaration</a>. The syntax list below only demonstrates a subset of all valid move assignment operator syntaxes.
</p>
<table class="t-sdsc-begin">

<tbody><tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>);</b></code>
</td>
<td> (1)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>)</b></code> <span class="t-spar">function-body</span>
</td>
<td> (2)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list-no-default</span> ﻿<code><b>) = default;</b></code>
</td>
<td> (3)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>) = delete;</b></code>
</td>
<td> (4)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <span class="t-spar">class-name</span> ﻿<code><b>::</b></code><code><b>operator=(</b></code><span class="t-spar">parameter-list</span> ﻿<code><b>)</b></code> <span class="t-spar">function-body</span>
</td>
<td> (5)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr>
<tr class="t-sdsc">
<td> <span class="t-spar">return-type</span> <span class="t-spar">class-name</span> ﻿<code><b>::</b></code><code><b>operator=(</b></code><span class="t-spar">parameter-list-no-default</span> ﻿<code><b>) = default;</b></code>
</td>
<td> (6)
</td>
<td class="t-sdsc-nopad">
</td></tr>



<tr>
<td colspan="10" class="t-sdsc-sep">
</td></tr></tbody></table>
<table class="t-par-begin">


<tbody><tr class="t-par">
<td> <span class="t-spar">class-name</span>
</td>
<td> -
</td>
<td> the class whose move assignment operator is being declared, the class type is given as <code>T</code> in the descriptions below
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">parameter-list</span>
</td>
<td> -
</td>
<td> a <a href="function.html#Parameter_list" title="cpp/language/function">parameter list</a> of only one parameter, which is of type <code>T&amp;&amp;</code>, <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T<span class="sy3">&amp;&amp;</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span> T<span class="sy3">&amp;&amp;</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">volatile</span> T<span class="sy3">&amp;&amp;</span></span>
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">parameter-list-no-default</span>
</td>
<td> -
</td>
<td> a <a href="function.html#Parameter_list" title="cpp/language/function">parameter list</a> of only one parameter, which is of type <code>T&amp;&amp;</code>, <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> T<span class="sy3">&amp;&amp;</span></span>, <span class="mw-geshi cpp source-cpp"><span class="kw4">volatile</span> T<span class="sy3">&amp;&amp;</span></span> or <span class="mw-geshi cpp source-cpp"><span class="kw4">const</span> <span class="kw4">volatile</span> T<span class="sy3">&amp;&amp;</span></span> and does not have a default argument
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">function-body</span>
</td>
<td> -
</td>
<td> the <a href="constructor.html" title="cpp/language/constructor">function body</a> of the move assignment operator
</td></tr>
<tr class="t-par">
<td> <span class="t-spar">return-type</span>
</td>
<td> -
</td>
<td> any type, but <code>T&amp;</code> is favored in order to be consistent with scala types
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=2" title="Edit section: Explanation">edit</a>]</span> <span class="mw-headline" id="Explanation">Explanation</span></h3>
<div class="t-li1"><span class="t-li">1)</span> Declaration of a move assignment operator inside of class definition.</div>
<div class="t-li1"><span class="t-li">2-4)</span> Definition of a move assignment operator inside of class definition.</div>
<div class="t-li2"><span class="t-li">3)</span> The move assignment operator is explicitly-defaulted.</div>
<div class="t-li2"><span class="t-li">4)</span> The move assignment operator is deleted.</div>
<div class="t-li1"><span class="t-li">5,6)</span> Definition of a move assignment operator outside of class definition (the class must contain a declaration <span class="t-v">(1)</span>).</div>
<div class="t-li2"><span class="t-li">6)</span> The move assignment operator is explicitly-defaulted.</div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> X
<span class="br0">{</span>
    X<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>X<span class="sy3">&amp;&amp;</span> other<span class="br0">)</span><span class="sy4">;</span>    <span class="co1">// move assignment operator</span>
<span class="co1">//  X operator=(const X other); // Error: incorrect parameter type</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">union</span> Y
<span class="br0">{</span>
    <span class="co1">// move assignment operators can have syntaxes not listed above,</span>
    <span class="co1">// as long as they follow the general function declaration syntax</span>
    <span class="co1">// and do not viloate the restrictions listed above</span>
    <span class="kw4">auto</span> operator<span class="sy1">=</span><span class="br0">(</span>Y<span class="sy3">&amp;&amp;</span> other<span class="br0">)</span> <span class="sy2">-</span><span class="sy1">&gt;</span> Y<span class="sy3">&amp;</span><span class="sy4">;</span>       <span class="co1">// OK: trailing return type</span>
    Y<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>this Y<span class="sy3">&amp;&amp;</span> self, Y<span class="sy3">&amp;</span> other<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// OK: explicit object parameter</span>
<span class="co1">//  Y&amp; operator=(Y&amp;&amp;, int num = 1);        // Error: has other non-object parameters</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>The move assignment operator is called whenever it is selected by <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>, e.g. when an object appears on the left-hand side of an assignment expression, where the right-hand side is an rvalue of the same or implicitly convertible type.
</p><p>Move assignment operators typically transfer the resources held by the argument (e.g. pointers to dynamically-allocated objects, file descriptors, TCP sockets, thread handles, etc.), rather than make copies of them, and leave the argument in some valid but otherwise indeterminate state. Since move assignment doesn’t change the lifetime of the argument, the destructor will typically be called on the argument at a later point. For example, move-assigning from a <span class="t-lc"><a href="../string/basic_string.html" title="cpp/string/basic string">std::string</a></span> or from a <span class="t-lc"><a href="../container/vector.html" title="cpp/container/vector">std::vector</a></span> may result in the argument being left empty. A move assignment is less, not more restrictively defined than ordinary assignment; where ordinary assignment must leave two copies of data at completion, move assignment is required to leave only one.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=3" title="Edit section: Implicitly-declared move assignment operator">edit</a>]</span> <span class="mw-headline" id="Implicitly-declared_move_assignment_operator">Implicitly-declared move assignment operator</span></h3>
<p>If no user-defined move assignment operators are provided for a class type, and all of the following is true:
</p>
<ul><li> there are no user-declared <a href="copy_constructor.html" title="cpp/language/copy constructor">copy constructors</a>;
</li><li> there are no user-declared <a href="move_constructor.html" title="cpp/language/move constructor">move constructors</a>;
</li><li> there are no user-declared <a href="copy_assignment.html" title="cpp/language/copy assignment">copy assignment operators</a>;
</li><li> there is no user-declared <a href="destructor.html" title="cpp/language/destructor">destructor</a>,
</li></ul>
<p>then the compiler will declare a move assignment operator as an <span class="mw-geshi cpp source-cpp"><span class="kw1">inline</span> <span class="kw1">public</span></span> member of its class with the signature <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span>T<span class="sy3">&amp;&amp;</span><span class="br0">)</span></span></span>. 
</p><p>A class can have multiple move assignment operators, e.g. both <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;&amp;</span><span class="br0">)</span></span></span> and <span class="t-c"><span class="mw-geshi cpp source-cpp">T<span class="sy3">&amp;</span> T<span class="sy4">::</span><span class="me2">operator</span><span class="sy1">=</span><span class="br0">(</span>T<span class="sy3">&amp;&amp;</span><span class="br0">)</span></span></span>. If some user-defined move assignment operators are present, the user may still force the generation of the implicitly declared move assignment operator with the keyword <code>default</code>.
</p><p>The implicitly-declared move assignment operator has an exception specification as described in <span class="t-rev-inl t-until-cxx17"><span><a href="except_spec.html" title="cpp/language/except spec">dynamic exception specification</a></span><span><span class="t-mark-rev t-until-cxx17">(until C++17)</span></span></span><span class="t-rev-inl t-since-cxx17"><span><a href="noexcept_spec.html" title="cpp/language/noexcept spec">noexcept specification</a></span><span><span class="t-mark-rev t-since-cxx17">(since C++17)</span></span></span>.
</p><p>Because some assignment operator (move or copy) is always declared for any class, the base class assignment operator is always hidden. If a using-declaration is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=4" title="Edit section: Implicitly-defined move assignment operator">edit</a>]</span> <span class="mw-headline" id="Implicitly-defined_move_assignment_operator">Implicitly-defined move assignment operator</span></h3>
<p>If the implicitly-declared move assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if <a href="definition.html#ODR-use" title="cpp/language/definition">odr-used</a><span class="t-rev-inl t-since-cxx14"><span> or <a href="constant_expression.html#Functions_and_variables_needed_for_constant_evaluation" title="cpp/language/constant expression">needed for constant evaluation</a></span><span><span class="t-mark-rev t-since-cxx14">(since C++14)</span></span></span>.
</p><p>For union types, the implicitly-defined move assignment operator copies the object representation (as by <span class="t-lc"><a href="../string/byte/memmove.html" title="cpp/string/byte/memmove">std::memmove</a></span>).
</p><p>For non-union class types, the move assignment operator performs full member-wise move assignment of the object's direct bases and immediate non-static members, in their declaration order, using built-in assignment for the scalars, memberwise move-assignment for arrays, and move assignment operator for class types (called non-virtually).
</p>
<table class="t-rev-begin">
<tbody><tr class="t-rev t-since-cxx14 t-until-cxx23"><td>
<p>The implicitly-defined move assignment operator for a class <code>T</code> is <a href="constexpr.html" title="cpp/language/constexpr"><code>constexpr</code></a> if
</p>
<ul><li> <code>T</code> is a <a href="../named_req/LiteralType.html" title="cpp/named req/LiteralType">literal type</a>, and
</li><li> the assignment operator selected to move each direct base class subobject is a constexpr function, and
</li><li> for each non-static data member of <code>T</code> that is of class type (or array thereof), the assignment operator selected to move that member is a constexpr function.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx14">(since C++14)</span><br><span class="t-mark-rev t-until-cxx23">(until C++23)</span></td></tr>
<tr class="t-rev t-since-cxx23"><td>
<p>The implicitly-defined move assignment operator for a class <code>T</code> is <a href="constexpr.html" title="cpp/language/constexpr"><code>constexpr</code></a>.
</p>
</td>
<td><span class="t-mark-rev t-since-cxx23">(since C++23)</span></td></tr>
</tbody></table>
<p>As with copy assignment, it is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">struct</span> V
<span class="br0">{</span>
    V<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>V<span class="sy3">&amp;&amp;</span> other<span class="br0">)</span>
    <span class="br0">{</span>
        <span class="co1">// this may be called once or twice</span>
        <span class="co1">// if called twice, 'other' is the just-moved-from V subobject</span>
        <span class="kw1">return</span> <span class="sy2">*</span>this<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> A <span class="sy4">:</span> <span class="kw1">virtual</span> V <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// operator= calls V::operator=</span>
<span class="kw1">struct</span> B <span class="sy4">:</span> <span class="kw1">virtual</span> V <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// operator= calls V::operator=</span>
<span class="kw1">struct</span> C <span class="sy4">:</span> B, A <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>      <span class="co1">// operator= calls B::operator=, then A::operator=</span>
                         <span class="co1">// but they may only call V::operator= once</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    C c1, c2<span class="sy4">;</span>
    c2 <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>c1<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=5" title="Edit section: Deleted move assignment operator">edit</a>]</span> <span class="mw-headline" id="Deleted_move_assignment_operator">Deleted move assignment operator</span></h3>
<p>The implicitly-declared or defaulted move assignment operator for class <code>T</code> is defined as deleted if any of the following conditions is satisfied:
</p>
<ul><li> <code>T</code> has a non-static data member of a const-qualified non-class type (or possibly multi-dimensional array thereof).
</li><li> <code>T</code> has a non-static data member of a reference type.
</li><li> <code>T</code> has a <a href="object.html#Potentially_constructed_subobject" title="cpp/language/object">potentially constructed subobject</a> of class type <code>M</code> (or possibly multi-dimensional array thereof) such that the overload resolution as applied to find <code>M</code>'s move assignment operator
</li></ul>
<dl><dd><ul><li> does not result in a usable candidate, or
</li><li> in the case of the subobject being a <a href="union.html#Union-like_classes" title="cpp/language/union">variant member</a>, selects a non-trivial function.
</li></ul>
</dd></dl>
<p>A deleted implicitly-declared move assignment operator is ignored by <a href="overload_resolution.html" title="cpp/language/overload resolution">overload resolution</a>.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=6" title="Edit section: Trivial move assignment operator">edit</a>]</span> <span class="mw-headline" id="Trivial_move_assignment_operator">Trivial move assignment operator</span></h3>
<p>The move assignment operator for class <code>T</code> is trivial if all of the following is true:
</p>
<ul><li> It is not user-provided (meaning, it is implicitly-defined or defaulted);
</li><li> <code>T</code> has no virtual member functions;
</li><li> <code>T</code> has no virtual base classes;
</li><li> the move assignment operator selected for every direct base of <code>T</code> is trivial;
</li><li> the move assignment operator selected for every non-static class type (or array of class type) member of <code>T</code> is trivial.
</li></ul>
<p>A trivial move assignment operator performs the same action as the trivial copy assignment operator, that is, makes a copy of the object representation as if by <span class="t-lc"><a href="../string/byte/memmove.html" title="cpp/string/byte/memmove">std::memmove</a></span>. All data types compatible with the C language are trivially move-assignable.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=7" title="Edit section: Eligible move assignment operator">edit</a>]</span> <span class="mw-headline" id="Eligible_move_assignment_operator">Eligible move assignment operator</span></h3>
<table class="t-rev-begin">

<tbody><tr class="t-rev t-until-cxx20"><td>
<p>A move assignment operator is eligible if it is not deleted.
</p>
</td>
<td><span class="t-mark-rev t-until-cxx20">(until C++20)</span></td></tr>
<tr class="t-rev t-since-cxx20"><td>
<p>A move assignment operator is eligible if all following conditions are satisfied:
</p>
<ul><li> It is not deleted.
</li><li> Its <a href="constraints.html" title="cpp/language/constraints">associated constraints</a> (if any) are satisfied.
</li><li> No move assignment operator whose associated constraints are satisfied is <a href="constraints.html#Partial_ordering_of_constraints" title="cpp/language/constraints">more constrained</a>.
</li></ul>
</td>
<td><span class="t-mark-rev t-since-cxx20">(since C++20)</span></td></tr>
</tbody></table>
<p>Triviality of eligible move assignment operators determines whether the class is a <a href="../named_req/TriviallyCopyable.html" title="cpp/named req/TriviallyCopyable">trivially copyable type</a>.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=8" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<p>If both copy and move assignment operators are provided, overload resolution selects the move assignment if the argument is an <a href="value_category.html" title="cpp/language/value category"><i>rvalue</i></a> (either a <a href="value_category.html" title="cpp/language/value category"><i>prvalue</i></a> such as a nameless temporary or an <a href="value_category.html" title="cpp/language/value category"><i>xvalue</i></a> such as the result of <span class="t-lc">std::move</span>), and selects the copy assignment if the argument is an <a href="value_category.html" title="cpp/language/value category"><i>lvalue</i></a> (named object or a function/operator returning lvalue reference). If only the copy assignment is provided, all argument categories select it (as long as it takes its argument by value or as reference to const, since rvalues can bind to const references), which makes copy assignment the fallback for move assignment, when move is unavailable.
</p><p>It is unspecified whether virtual base class subobjects that are accessible through more than one path in the inheritance lattice, are assigned more than once by the implicitly-defined move assignment operator (same applies to <a href="copy_assignment.html" title="cpp/language/copy assignment">copy assignment</a>).
</p><p>See <a href="operators.html#Assignment_operator" title="cpp/language/operators">assignment operator overloading</a> for additional detail on the expected behavior of a user-defined move-assignment operator.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=9" title="Edit section: Example">edit</a>]</span> <span class="mw-headline" id="Example">Example</span></h3>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
<span class="co2">#include &lt;utility&gt;</span>
&nbsp;
<span class="kw1">struct</span> A
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a> s<span class="sy4">;</span>
&nbsp;
    A<span class="br0">(</span><span class="br0">)</span> <span class="sy4">:</span> s<span class="br0">(</span><span class="st0">"test"</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    A<span class="br0">(</span><span class="kw4">const</span> A<span class="sy3">&amp;</span> o<span class="br0">)</span> <span class="sy4">:</span> s<span class="br0">(</span>o.<span class="me1">s</span><span class="br0">)</span> <span class="br0">{</span> <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"move failed!<span class="es1">\n</span>"</span><span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
    A<span class="br0">(</span>A<span class="sy3">&amp;&amp;</span> o<span class="br0">)</span> <span class="sy4">:</span> s<span class="br0">(</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>o.<span class="me1">s</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    A<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span><span class="kw4">const</span> A<span class="sy3">&amp;</span> other<span class="br0">)</span>
    <span class="br0">{</span>
         s <span class="sy1">=</span> other.<span class="me1">s</span><span class="sy4">;</span>
         <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"copy assigned<span class="es1">\n</span>"</span><span class="sy4">;</span>
         <span class="kw1">return</span> <span class="sy2">*</span>this<span class="sy4">;</span>
    <span class="br0">}</span>
&nbsp;
    A<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>A<span class="sy3">&amp;&amp;</span> other<span class="br0">)</span>
    <span class="br0">{</span>
         s <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>other.<span class="me1">s</span><span class="br0">)</span><span class="sy4">;</span>
         <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"move assigned<span class="es1">\n</span>"</span><span class="sy4">;</span>
         <span class="kw1">return</span> <span class="sy2">*</span>this<span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
A f<span class="br0">(</span>A a<span class="br0">)</span> <span class="br0">{</span> <span class="kw1">return</span> a<span class="sy4">;</span> <span class="br0">}</span>
&nbsp;
<span class="kw1">struct</span> B <span class="sy4">:</span> A
<span class="br0">{</span>
    <a href="../string/basic_string.html"><span class="kw1238">std::<span class="me2">string</span></span></a> s2<span class="sy4">;</span> 
    <span class="kw4">int</span> n<span class="sy4">;</span>
    <span class="co1">// implicit move assignment operator B&amp; B::operator=(B&amp;&amp;)</span>
    <span class="co1">// calls A's move assignment operator</span>
    <span class="co1">// calls s2's move assignment operator</span>
    <span class="co1">// and makes a bitwise copy of n</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> C <span class="sy4">:</span> B
<span class="br0">{</span>
    ~C<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// destructor prevents implicit move assignment</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">struct</span> D <span class="sy4">:</span> B
<span class="br0">{</span>
    D<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
    ~D<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// destructor would prevent implicit move assignment</span>
    D<span class="sy3">&amp;</span> operator<span class="sy1">=</span><span class="br0">(</span>D<span class="sy3">&amp;&amp;</span><span class="br0">)</span> <span class="sy1">=</span> <span class="kw1">default</span><span class="sy4">;</span> <span class="co1">// force a move assignment anyway </span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    A a1, a2<span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Trying to move-assign A from rvalue temporary<span class="es1">\n</span>"</span><span class="sy4">;</span>
    a1 <span class="sy1">=</span> f<span class="br0">(</span>A<span class="br0">(</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// move-assignment from rvalue temporary</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Trying to move-assign A from xvalue<span class="es1">\n</span>"</span><span class="sy4">;</span>
    a2 <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>a1<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// move-assignment from xvalue</span>
&nbsp;
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\n</span>Trying to move-assign B<span class="es1">\n</span>"</span><span class="sy4">;</span>
    B b1, b2<span class="sy4">;</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"Before move, b1.s = <span class="es1">\"</span>"</span> <span class="sy1">&lt;&lt;</span> b1.<span class="me1">s</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\"</span><span class="es1">\n</span>"</span><span class="sy4">;</span>
    b2 <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>b1<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls implicit move assignment</span>
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"After move, b1.s = <span class="es1">\"</span>"</span> <span class="sy1">&lt;&lt;</span> b1.<span class="me1">s</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\"</span><span class="es1">\n</span>"</span><span class="sy4">;</span>
&nbsp;
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\n</span>Trying to move-assign C<span class="es1">\n</span>"</span><span class="sy4">;</span>
    C c1, c2<span class="sy4">;</span>
    c2 <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>c1<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// calls the copy assignment operator</span>
&nbsp;
    <a href="../io/cout.html"><span class="kw1775">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"<span class="es1">\n</span>Trying to move-assign D<span class="es1">\n</span>"</span><span class="sy4">;</span>
    D d1, d2<span class="sy4">;</span>
    d2 <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>d1<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">Trying to move-assign A from rvalue temporary
move assigned
Trying to move-assign A from xvalue
move assigned
&nbsp;
Trying to move-assign B
Before move, b1.s = "test"
move assigned
After move, b1.s = ""
&nbsp;
Trying to move-assign C
copy assigned
&nbsp;
Trying to move-assign D
move assigned</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=10" title="Edit section: Defect reports">edit</a>]</span> <span class="mw-headline" id="Defect_reports">Defect reports</span></h3>
<p>The following behavior-changing defect reports were applied retroactively to previously published C++ standards.
</p>
<table class="dsctable" style="font-size:0.8em">
<tbody><tr>
<th>DR
</th>
<th>Applied to
</th>
<th>Behavior as published
</th>
<th>Correct behavior
</th></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1353.html">CWG 1353</a>
</td>
<td>C++11
</td>
<td>the conditions where defaulted move assignment operators are<br>defined as deleted did not consider multi-dimensional array types
</td>
<td>consider these types
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1402.html">CWG 1402</a>
</td>
<td>C++11
</td>
<td>a defaulted move assignment operator that would<br>call a non-trivial copy assignment operator was<br>deleted; a defaulted move assignment operator that<br>is deleted still participated in overload resolution
</td>
<td>allows call to such<br>copy assignment<br>operator; made ignored<br>in overload resolution
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/1806.html">CWG 1806</a>
</td>
<td>C++11
</td>
<td>specification for a defaulted move assignment operator<br>involving a virtual base class was missing
</td>
<td>added
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2094.html">CWG 2094</a>
</td>
<td>C++11
</td>
<td>a volatile subobject made of a defaulted<br>move assignment operator non-trivial (<a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/496.html">CWG issue 496</a>)
</td>
<td>triviality not affected
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2180.html">CWG 2180</a>
</td>
<td>C++11
</td>
<td>a defaulted move assignment operator for class <code>T</code><br>was not defined as deleted if <code>T</code> is abstract and has<br>non-move-assignable direct virtual base classes
</td>
<td>the operator is defined<br>as deleted in this case
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2595.html">CWG 2595</a>
</td>
<td>C++20
</td>
<td>a move assignment operator was not eligible if there<br>is another move assignment operator which is more<br>constrained but does not satisfy its associated constraints
</td>
<td>it can be eligible in this case
</td></tr>
<tr>
<td><a rel="nofollow" class="external text" href="https://cplusplus.github.io/CWG/issues/2690.html">CWG 2690</a>
</td>
<td>C++11
</td>
<td>the implicitly-defined move assignment operator for<br>union types did not copy the object representation
</td>
<td>they copy the object<br>representation
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;action=edit&amp;section=11" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<ul><li> <a href="constructor.html" title="cpp/language/constructor">constructor</a>
</li><li> <a href="converting_constructor.html" title="cpp/language/converting constructor">converting constructor</a>
</li><li> <a href="copy_assignment.html" title="cpp/language/copy assignment">copy assignment</a>
</li><li> <a href="copy_constructor.html" title="cpp/language/copy constructor">copy constructor</a>
</li><li> <a href="default_constructor.html" title="cpp/language/default constructor">default constructor</a>
</li><li> <a href="destructor.html" title="cpp/language/destructor">destructor</a>
</li><li> <a href="initialization.html" title="cpp/language/initialization">initialization</a>
<ul><li> <a href="aggregate_initialization.html" title="cpp/language/aggregate initialization">aggregate initialization</a>
</li><li> <a href="constant_initialization.html" title="cpp/language/constant initialization">constant initialization</a>
</li><li> <a href="copy_initialization.html" title="cpp/language/copy initialization">copy initialization</a>
</li><li> <a href="default_initialization.html" title="cpp/language/default initialization">default initialization</a>
</li><li> <a href="direct_initialization.html" title="cpp/language/direct initialization">direct initialization</a>
</li><li> <a href="list_initialization.html" title="cpp/language/list initialization">list initialization</a>
</li><li> <a href="reference_initialization.html" title="cpp/language/reference initialization">reference initialization</a>
</li><li> <a href="value_initialization.html" title="cpp/language/value initialization">value initialization</a>
</li><li> <a href="zero_initialization.html" title="cpp/language/zero initialization">zero initialization</a>
</li></ul>
</li><li> <a href="move_constructor.html" title="cpp/language/move constructor">move constructor</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor visited node count: 4864/1000000
Preprocessor generated node count: 11478/1000000
Post‐expand include size: 162468/4194304 bytes
Template argument size: 31580/4194304 bytes
Highest expansion depth: 16/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:9134-0!*!0!!en!*!* and timestamp 20250103104323 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;oldid=175721">https://en.cppreference.com/mwiki/index.php?title=cpp/language/move_assignment&amp;oldid=175721</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 3.194 secs. -->
	




</body><!-- Cached 20250103104323 --><!-- Mirrored from en.cppreference.com/w/cpp/language/move_assignment by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:35:36 GMT --></html>