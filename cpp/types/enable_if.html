<!DOCTYPE html><html lang="en" dir="ltr" class="client-nojs"><!-- Mirrored from en.cppreference.com/w/cpp/types/enable_if by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:38:37 GMT --><!-- Added by HTTrack --><head><meta http-equiv="content-type" content="text/html;charset=UTF-8"><!-- /Added by HTTrack -->

<title>std::enable_if</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">







<meta name="ResourceLoaderDynamicStyles" content="">

<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_en_:resourceloader:filter:minify-css:7:472787eddcf4605d11de8c7ef047234f */</style>




<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_types_enable_if skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        
        <!-- /header -->
        <!-- content -->
<style type="text/css">
#carbonads {
  display: block;
  overflow: hidden;
  position: absolute;
  text-align: center;
  left: -170px;
  max-width: 150px;
  border-radius: 4px;
  border: solid 1px hsla(0, 0%, 0%, .1);
  background-color: hsl(0, 0%, 98%);
  font-size: 12px;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen-Sans, Ubuntu,
  Cantarell, "Helvetica Neue", Helvetica, Arial, sans-serif;
  line-height: 1.5;
}

#carbonads a {
  color: inherit;
  text-decoration: none;
}

#carbonads a:hover {
  color: inherit;
}

#carbonads span {
  position: relative;
  display: block;
  overflow: hidden;
}

.carbon-img {
  display: block;
  margin-bottom: 8px;
  max-width: 150px;
  line-height: 1;
}

.carbon-img img {
  display: block;
  margin: 0 auto;
  max-width: 150px !important;
  width: 150px;
  height: auto;
}

.carbon-text {
  display: block;
  padding: 0 1em 8px;
}

.carbon-poweredby {
  display: block;
  padding: 8px 12px;
  background: repeating-linear-gradient(-45deg, transparent, transparent 5px, hsla(0, 0%, 0%, .025) 5px, hsla(0, 0%, 0%, .025) 10px) hsla(203, 11%, 95%, .4);
  text-transform: uppercase;
  letter-spacing: .5px;
  font-weight: 600;
  font-size: 9px;
  line-height: 1;
}
html { font-variant-ligatures: no-common-ligatures; }
</style>
        <div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<script async type="text/javascript" src="http://cdn.carbonads.com/carbon.js?serve=CKYITK7M&amp;placement=cppreferencecom" id="_carbonads_js"></script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-8HW0LXMYCY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-8HW0LXMYCY');
</script>
                <h1 id="firstHeading" class="firstHeading"><span style="font-size:0.7em; line-height:130%">std::</span>enable_if</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr">
<table class="t-dcl-begin"><tbody>
<tr class="t-dsc-header">
<td> <div>Defined in header <code><a href="../header/type_traits.html" title="cpp/header/type traits">&lt;type_traits&gt;</a></code>
 </div></td>
<td></td>
<td></td>
</tr>
<tr class="t-dcl t-since-cxx11">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw4">bool</span> B, <span class="kw1">class</span> T <span class="sy1">=</span> <span class="kw4">void</span> <span class="sy1">&gt;</span><br>
<span class="kw1">struct</span> enable_if<span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx11">(since C++11)</span> </td>
</tr>
<tr class="t-dcl-sep"><td></td><td></td><td></td></tr>
</tbody></table>
<p>If <code>B</code> is <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span>, <code>std::enable_if</code> has a public member typedef <code>type</code>, equal to <code>T</code>; otherwise, there is no member typedef. 
</p><p>This metafunction is a convenient way to leverage <a href="../language/sfinae.html" title="cpp/language/sfinae">SFINAE</a> prior to C++20's <a href="../language/constraints.html" title="cpp/language/constraints">concepts</a>, in particular for conditionally removing functions from the <a href="../language/overload_resolution.html" title="cpp/language/overload resolution">candidate set</a> based on type traits, allowing separate function overloads or specializations based on those different type traits.
</p><p><code>std::enable_if</code> can be used in many forms, including:
</p>
<ul><li> as an additional function argument (not applicable to most operator overloads),
</li><li> as a return type (not applicable to constructors and destructors),
</li><li> as a class template or function template parameter.
</li></ul>
<p>If the program adds specializations for <code>std::enable_if</code>, the behavior is undefined.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Member_types"><span class="tocnumber">1</span> <span class="toctext">Member types</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#Helper_types"><span class="tocnumber">2</span> <span class="toctext">Helper types</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#Possible_implementation"><span class="tocnumber">3</span> <span class="toctext">Possible implementation</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#Notes"><span class="tocnumber">4</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Example"><span class="tocnumber">5</span> <span class="toctext">Example</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#See_also"><span class="tocnumber">6</span> <span class="toctext">See also</span></a></li>
</ul>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;action=edit&amp;section=1" title="Edit section: Member types">edit</a>]</span> <span class="mw-headline" id="Member_types">Member types</span></h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc-hitem">
<td> Type
</td>
<td> Definition
</td></tr>


<tr class="t-dsc">
<td> <code>type</code>
</td>
<td> either <code>T</code> or no such member, depending on the value of <code>B</code>
</td></tr>

</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;action=edit&amp;section=2" title="Edit section: Helper types">edit</a>]</span> <span class="mw-headline" id="Helper_types">Helper types</span></h3>
<table class="t-dcl-begin"><tbody>

<tr class="t-dcl t-since-cxx14">
<td> <div><span class="mw-geshi cpp source-cpp"><span class="kw1">template</span><span class="sy1">&lt;</span> <span class="kw4">bool</span> B, <span class="kw1">class</span> T <span class="sy1">=</span> <span class="kw4">void</span> <span class="sy1">&gt;</span><br>
<span class="kw1">using</span> enable_if_t <span class="sy1">=</span> <span class="kw1">typename</span> enable_if<span class="sy1">&lt;</span>B,T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span><span class="sy4">;</span></span></div></td>
<td class="t-dcl-nopad">  </td>
<td> <span class="t-mark-rev t-since-cxx14">(since C++14)</span> </td>
</tr>
<tr class="t-dcl-sep"><td></td><td></td><td></td></tr>
</tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;action=edit&amp;section=3" title="Edit section: Possible implementation">edit</a>]</span> <span class="mw-headline" id="Possible_implementation">Possible implementation</span></h3>
<table class="eq-fun-cpp-table">


<tbody><tr>
<td>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw4">bool</span> B, <span class="kw1">class</span> T <span class="sy1">=</span> <span class="kw4">void</span><span class="sy1">&gt;</span>
<span class="kw1">struct</span> enable_if <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">struct</span> enable_if<span class="sy1">&lt;</span><span class="kw2">true</span>, T<span class="sy1">&gt;</span> <span class="br0">{</span> <span class="kw1">typedef</span> T type<span class="sy4">;</span> <span class="br0">}</span><span class="sy4">;</span></pre></div></div>
</td></tr></tbody></table>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;action=edit&amp;section=4" title="Edit section: Notes">edit</a>]</span> <span class="mw-headline" id="Notes">Notes</span></h3>
<p>A common mistake is to declare two function templates that differ only in their default template arguments. This does not work because the declarations are treated as redeclarations of the same function template (default template arguments are not accounted for in <a href="../language/function_template.html#Function_template_overloading" title="cpp/language/function template">function template equivalence</a>).
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="coMULTI">/* WRONG */</span>
&nbsp;
<span class="kw1">struct</span> T
<span class="br0">{</span>
    <span class="kw2">enum</span> <span class="br0">{</span> int_t, float_t <span class="br0">}</span> type<span class="sy4">;</span>
&nbsp;
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> Integer,
             <span class="kw1">typename</span> <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span><a href="is_integral.html"><span class="kw463">std::<span class="me2">is_integral</span></span></a><span class="sy1">&lt;</span>Integer<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;&gt;</span>
    T<span class="br0">(</span>Integer<span class="br0">)</span> <span class="sy4">:</span> type<span class="br0">(</span>int_t<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> Floating,
             <span class="kw1">typename</span> <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span><a href="is_floating_point.html"><span class="kw465">std::<span class="me2">is_floating_point</span></span></a><span class="sy1">&lt;</span>Floating<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;&gt;</span>
    T<span class="br0">(</span>Floating<span class="br0">)</span> <span class="sy4">:</span> type<span class="br0">(</span>float_t<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// error: treated as redefinition</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="coMULTI">/* RIGHT */</span>
&nbsp;
<span class="kw1">struct</span> T
<span class="br0">{</span>
    <span class="kw2">enum</span> <span class="br0">{</span> int_t, float_t <span class="br0">}</span> type<span class="sy4">;</span>
&nbsp;
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> Integer,
             std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span><a href="is_integral.html"><span class="kw463">std::<span class="me2">is_integral</span></span></a><span class="sy1">&lt;</span>Integer<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span>, <span class="kw4">bool</span><span class="sy1">&gt;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy1">&gt;</span>
    T<span class="br0">(</span>Integer<span class="br0">)</span> <span class="sy4">:</span> type<span class="br0">(</span>int_t<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span>
&nbsp;
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">typename</span> Floating,
             std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span><a href="is_floating_point.html"><span class="kw465">std::<span class="me2">is_floating_point</span></span></a><span class="sy1">&lt;</span>Floating<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span>, <span class="kw4">bool</span><span class="sy1">&gt;</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy1">&gt;</span>
    T<span class="br0">(</span>Floating<span class="br0">)</span> <span class="sy4">:</span> type<span class="br0">(</span>float_t<span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// OK</span>
<span class="br0">}</span><span class="sy4">;</span></pre></div></div>
<p>Care should be taken when using <code>enable_if</code> in the type of a template non-type parameter of a namespace-scope function template. Some ABI specifications like the Itanium ABI do not include the instantiation-dependent portions of non-type template parameters in the mangling, meaning that specializations of two distinct function templates might end up with the same mangled name and be erroneously linked together. For example:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co1">// first translation unit</span>
&nbsp;
<span class="kw1">struct</span> X
<span class="br0">{</span>
    <span class="kw2">enum</span> <span class="br0">{</span> value1 <span class="sy1">=</span> <span class="kw2">true</span>, value2 <span class="sy1">=</span> <span class="kw2">true</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span>T<span class="sy4">::</span><span class="me2">value1</span>, <span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy1">&gt;</span>
<span class="kw4">void</span> func<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// #1</span>
&nbsp;
<span class="kw1">template</span> <span class="kw4">void</span> func<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #2</span>
&nbsp;
<span class="co1">// second translation unit</span>
&nbsp;
<span class="kw1">struct</span> X
<span class="br0">{</span>
    <span class="kw2">enum</span> <span class="br0">{</span> value1 <span class="sy1">=</span> <span class="kw2">true</span>, value2 <span class="sy1">=</span> <span class="kw2">true</span> <span class="br0">}</span><span class="sy4">;</span>
<span class="br0">}</span><span class="sy4">;</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span>T<span class="sy4">::</span><span class="me2">value2</span>, <span class="kw4">int</span><span class="sy1">&gt;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy1">&gt;</span>
<span class="kw4">void</span> func<span class="br0">(</span><span class="br0">)</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// #3</span>
&nbsp;
<span class="kw1">template</span> <span class="kw4">void</span> func<span class="sy1">&lt;</span>X<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// #4</span></pre></div></div>
<p>The function templates #1 and #3 have different signatures and are distinct templates. Nonetheless, #2 and #4, despite being instantiations of different function templates, have the same mangled name <a rel="nofollow" class="external text" href="https://github.com/itanium-cxx-abi/cxx-abi/issues/20">in the Itanium C++ ABI</a> (<code>_Z4funcI1XLi0EEvv</code>), meaning that the linker will erroneously consider them to be the same entity.
</p>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;action=edit&amp;section=5" title="Edit section: Example">edit</a>]</span> <span class="mw-headline" id="Example">Example</span></h3>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">Run this code</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;new&gt;</span>
<span class="co2">#include &lt;string&gt;</span>
<span class="co2">#include &lt;type_traits&gt;</span>
&nbsp;
<span class="kw1">namespace</span> detail
<span class="br0">{</span> 
    <span class="kw4">void</span><span class="sy2">*</span> voidify<span class="br0">(</span><span class="kw4">const</span> <span class="kw4">volatile</span> <span class="kw4">void</span><span class="sy2">*</span> ptr<span class="br0">)</span> <span class="kw1">noexcept</span> <span class="br0">{</span> <span class="kw1">return</span> <span class="kw1">const_cast</span><span class="sy1">&lt;</span><span class="kw4">void</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span>ptr<span class="br0">)</span><span class="sy4">;</span> <span class="br0">}</span> 
<span class="br0">}</span>
&nbsp;
<span class="co1">// #1, enabled via the return type</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">typename</span> std<span class="sy4">::</span><span class="me2">enable_if</span><span class="sy1">&lt;</span><a href="is_default_constructible.html"><span class="kw535">std::<span class="me2">is_trivially_default_constructible</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> 
    construct<span class="br0">(</span>T<span class="sy2">*</span><span class="br0">)</span> 
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1773">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"default constructing trivially default constructible T<span class="es1">\n</span>"</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// same as above</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">typename</span> std<span class="sy4">::</span><span class="me2">enable_if</span><span class="sy1">&lt;</span><span class="sy3">!</span><a href="is_default_constructible.html"><span class="kw535">std::<span class="me2">is_trivially_default_constructible</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> 
    construct<span class="br0">(</span>T<span class="sy2">*</span> p<span class="br0">)</span> 
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1773">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"default constructing non-trivially default constructible T<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="sy4">::</span><span class="me2">new</span><span class="br0">(</span>detail<span class="sy4">::</span><span class="me2">voidify</span><span class="br0">(</span>p<span class="br0">)</span><span class="br0">)</span> T<span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// #2</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span>... <span class="me1">Args</span><span class="sy1">&gt;</span>
std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span><a href="is_constructible.html"><span class="kw527">std::<span class="me2">is_constructible</span></span></a><span class="sy1">&lt;</span>T, Args<span class="sy3">&amp;&amp;</span>...<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;</span> <span class="co1">// Using helper type</span>
    construct<span class="br0">(</span>T<span class="sy2">*</span> p, Args<span class="sy3">&amp;&amp;</span>... <span class="me1">args</span><span class="br0">)</span> 
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1773">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"constructing T with operation<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="sy4">::</span><span class="me2">new</span><span class="br0">(</span>detail<span class="sy4">::</span><span class="me2">voidify</span><span class="br0">(</span>p<span class="br0">)</span><span class="br0">)</span> T<span class="br0">(</span><span class="kw1">static_cast</span><span class="sy1">&lt;</span>Args<span class="sy3">&amp;&amp;</span><span class="sy1">&gt;</span><span class="br0">(</span>args<span class="br0">)</span>...<span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// #3, enabled via a parameter</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw4">void</span> destroy<span class="br0">(</span>
    T<span class="sy2">*</span>, 
    <span class="kw1">typename</span> std<span class="sy4">::</span><span class="me2">enable_if</span><span class="sy1">&lt;</span>
        <a href="is_destructible.html"><span class="kw571">std::<span class="me2">is_trivially_destructible</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span>
    <span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span><span class="sy2">*</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="br0">)</span>
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1773">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"destroying trivially destructible T<span class="es1">\n</span>"</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// #4, enabled via a non-type template parameter</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T,
         <span class="kw1">typename</span> std<span class="sy4">::</span><span class="me2">enable_if</span><span class="sy1">&lt;</span>
             <span class="sy3">!</span><a href="is_destructible.html"><span class="kw571">std::<span class="me2">is_trivially_destructible</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span> <span class="sy3">&amp;&amp;</span>
             <span class="br0">(</span><a href="is_class.html"><span class="kw483">std::<span class="me2">is_class</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span> <span class="sy3">||</span> <a href="is_union.html"><span class="kw481">std::<span class="me2">is_union</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span><span class="br0">)</span>,
             <span class="kw4">bool</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span> <span class="sy1">=</span> <span class="kw2">true</span><span class="sy1">&gt;</span>
<span class="kw4">void</span> destroy<span class="br0">(</span>T<span class="sy2">*</span> t<span class="br0">)</span>
<span class="br0">{</span>
    <a href="../io/cout.html"><span class="kw1773">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"destroying non-trivially destructible T<span class="es1">\n</span>"</span><span class="sy4">;</span>
    t<span class="sy2">-</span><span class="sy1">&gt;</span>~T<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="co1">// #5, enabled via a type template parameter</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T,
	 <span class="kw1">typename</span> <span class="sy1">=</span> std<span class="sy4">::</span><span class="me2">enable_if_t</span><span class="sy1">&lt;</span><a href="is_array.html"><span class="kw467">std::<span class="me2">is_array</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;&gt;</span>
<span class="kw4">void</span> destroy<span class="br0">(</span>T<span class="sy2">*</span> t<span class="br0">)</span> <span class="co1">// note: function signature is unmodified</span>
<span class="br0">{</span>
    <span class="kw1">for</span> <span class="br0">(</span><a href="size_t.html"><span class="kw107">std::<span class="me2">size_t</span></span></a> i <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> i <span class="sy1">&lt;</span> <a href="extent.html"><span class="kw589">std::<span class="me2">extent</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">)</span>
        destroy<span class="br0">(</span><span class="br0">(</span><span class="sy2">*</span>t<span class="br0">)</span><span class="br0">[</span>i<span class="br0">]</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span>
&nbsp;
<span class="coMULTI">/*
template&lt;class T,
	 typename = std::enable_if_t&lt;std::is_void&lt;T&gt;::value&gt;&gt;
void destroy(T* t) {} // error: has the same signature with #5
*/</span>
&nbsp;
<span class="co1">// the partial specialization of A is enabled via a template parameter</span>
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Enable <span class="sy1">=</span> <span class="kw4">void</span><span class="sy1">&gt;</span>
<span class="kw1">class</span> A <span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// primary template</span>
&nbsp;
<span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
<span class="kw1">class</span> A<span class="sy1">&lt;</span>T, <span class="kw1">typename</span> std<span class="sy4">::</span><span class="me2">enable_if</span><span class="sy1">&lt;</span><a href="is_floating_point.html"><span class="kw465">std::<span class="me2">is_floating_point</span></span></a><span class="sy1">&lt;</span>T<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">value</span><span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">type</span><span class="sy1">&gt;</span>
<span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// specialization for floating point types</span>
&nbsp;
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">union</span> <span class="br0">{</span> <span class="kw4">int</span> i<span class="sy4">;</span> <span class="kw4">char</span> s<span class="br0">[</span>sizeof<span class="br0">(</span><a href="../string/basic_string.html"><span class="kw1236">std::<span class="me2">string</span></span></a><span class="br0">)</span><span class="br0">]</span><span class="sy4">;</span> <span class="br0">}</span> u<span class="sy4">;</span>
&nbsp;
    construct<span class="br0">(</span><span class="kw1">reinterpret_cast</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy3">&amp;</span>u<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    destroy<span class="br0">(</span><span class="kw1">reinterpret_cast</span><span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy3">&amp;</span>u<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    construct<span class="br0">(</span><span class="kw1">reinterpret_cast</span><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1236">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy3">&amp;</span>u<span class="br0">)</span>, <span class="st0">"Hello"</span><span class="br0">)</span><span class="sy4">;</span>
    destroy<span class="br0">(</span><span class="kw1">reinterpret_cast</span><span class="sy1">&lt;</span><a href="../string/basic_string.html"><span class="kw1236">std::<span class="me2">string</span></span></a><span class="sy2">*</span><span class="sy1">&gt;</span><span class="br0">(</span><span class="sy3">&amp;</span>u<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
&nbsp;
    A<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// OK: matches the primary template</span>
    A<span class="sy1">&lt;</span><span class="kw4">double</span><span class="sy1">&gt;</span><span class="br0">{</span><span class="br0">}</span><span class="sy4">;</span> <span class="co1">// OK: matches the partial specialization</span>
<span class="br0">}</span></pre></div></div>
<p>Output:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">default constructing trivially default constructible T
destroying trivially destructible T
constructing T with operation
destroying non-trivially destructible T</pre></div></div> 
</div>
<h3><span class="editsection">[<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;action=edit&amp;section=6" title="Edit section: See also">edit</a>]</span> <span class="mw-headline" id="See_also">See also</span></h3>
<table class="t-dsc-begin">

<tbody><tr class="t-dsc">
<td> <div class="t-dsc-member-div"><div><a href="void_t.html" title="cpp/types/void t"> <span class="t-lines"><span>void_t</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div></div>
</td>
<td>  void variadic alias template <br><span class="t-mark">(alias template)</span><span class="editsection noprint plainlinks" title="Edit this template"><a rel="nofollow" class="external text" href="https://en.cppreference.com/mwiki/index.php?title=Template:cpp/types/dsc_void_t&amp;action=edit">[edit]</a></span>
</td></tr>
</tbody></table>
<ul><li> <a href="../language/static_assert.html" title="cpp/language/static assert"><tt>static_assert</tt></a>
</li><li> <a href="../language/sfinae.html" title="cpp/language/sfinae">SFINAE</a>
</li><li> <a href="../language/constraints.html" title="cpp/language/constraints">Constraints and Concepts</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor visited node count: 8922/1000000
Preprocessor generated node count: 11191/1000000
Postâ€expand include size: 310516/4194304 bytes
Template argument size: 71307/4194304 bytes
Highest expansion depth: 20/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_en_:pcache:idhash:2716-0!*!0!!en!*!* and timestamp 20250103104456 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    Retrieved from "<a href="https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;oldid=171705">https://en.cppreference.com/mwiki/index.php?title=cpp/types/enable_if&amp;oldid=171705</a>"                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <div id="catlinks" class="catlinks catlinks-allhidden"></div>                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=skins.cppreference2&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.ColiruCompiler","ext.gadget.StandardRevisions","ext.gadget.MathJax"], null, true);
}</script>
<script src="https://en.cppreference.com/mwiki/load.php?debug=false&amp;lang=en&amp;modules=site&amp;only=scripts&amp;skin=cppreference2&amp;*"></script>
<!-- Served in 2.319 secs. -->
	




</body><!-- Cached 20250103104456 --><!-- Mirrored from en.cppreference.com/w/cpp/types/enable_if by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 29 Jan 2025 11:38:37 GMT --></html>